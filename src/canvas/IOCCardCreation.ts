/**
 * IOCCardCreation.ts - IOC card creation on canvas
 *
 * Provides the card selector modal trigger and the actual card creation
 * logic. Creates IOC cards as canvas text nodes with markdown+HTML content
 * generated by RenderIOCCards.
 */

import { App, ItemView, Notice } from 'obsidian';
import { IOC_TYPES } from '../types/IOCCardsTypes';
import { RenderIOCCardsModal } from './RenderIOCCardsModal';
import { createCardContent } from './RenderIOCCards';
import { DEBUG } from '../debug';
import { applyFullCardHeight } from './ReduceView';

/**
 * Opens the IOC card selector modal. The callback creates the card on
 * the active canvas.
 *
 * @param app - Obsidian App instance
 * @param createCard - Callback to create a card after type selection
 * @param title - Optional modal title ("Select Parent IOC Type" or "Select Child IOC Type")
 */
export function openIOCCardSelector(app: App, createCard: (iocTypeId: string, osType?: string) => void, title?: string): void {
    new RenderIOCCardsModal(
        app,
        IOC_TYPES,
        (iocTypeId: string, osType?: string) => {
            createCard(iocTypeId, osType);
        },
        title
    ).open();
}

/**
 * Creates an IOC card on the active canvas.
 *
 * Card Creation Flow:
 *   1. Validate canvas view - ensure user is in a canvas view
 *   2. Access internal canvas API via (view as any).canvas
 *   3. Generate timestamp-based card ID (#YYYYMMDD-HHMM)
 *   4. Generate card content via RenderIOCCards.createCardContent()
 *   5. Create canvas text node at random position within 400x400 area
 *   6. Persist to disk via canvas.requestSave()
 *
 * @param app - Obsidian App instance
 * @param iocTypeId - Snake_case IOC type key from IOC_TYPES (e.g., "ip_address")
 * @param osType - Optional OS variant for hostname cards
 * @param isChild - If true, card gets [C] prefix; if false, gets [P] prefix
 * @param autoFitHeight - If true, re-apply full card height after creation (waits for render)
 */
export function createIOCCard(app: App, iocTypeId: string, osType?: string, isChild: boolean = false, autoFitHeight: boolean = false): void {
    const activeView = app.workspace.getActiveViewOfType(ItemView);
    if (!activeView || activeView.getViewType() !== 'canvas') {
        new Notice('Please open a canvas first');
        return;
    }

    // Access internal canvas API (not publicly documented by Obsidian)
    const canvas = (activeView as any).canvas;
    if (!canvas) {
        new Notice('Please open a canvas first');
        return;
    }

    const iocType = IOC_TYPES[iocTypeId];
    if (!iocType) {
        new Notice('Unknown IOC type: ' + iocTypeId);
        return;
    }

    // Generate timestamp-based card ID (format: #YYYYMMDD-HHMM)
    const now = new Date();
    const year = now.getFullYear();
    const month = String(now.getMonth() + 1).padStart(2, '0');
    const day = String(now.getDate()).padStart(2, '0');
    const hours = String(now.getHours()).padStart(2, '0');
    const minutes = String(now.getMinutes()).padStart(2, '0');
    const cardId = `#${year}${month}${day}-${hours}${minutes}`;

    if (DEBUG) console.debug('[CardCreation] Creating card:', iocTypeId, cardId);

    // Generate markdown content for the IOC card
    const content = createCardContent(iocType, iocTypeId, osType || null, cardId, isChild);

    // Create text node on canvas with random position
    canvas.createTextNode({
        pos: { x: Math.random() * 400, y: Math.random() * 400 },  // Random placement
        size: { width: 400, height: 400 },  // Standard card size
        text: content  // Markdown with HTML header
    });
    canvas.requestSave();  // Persist to .canvas file

    // Re-apply full card height after markdown has rendered
    if (autoFitHeight) {
        setTimeout(() => applyFullCardHeight(app, true), 200);
    }

    new Notice(`Created ${iocType.name} card`);
}
