/**
 * IOCParser.ts - Shared IOC node parsing logic
 *
 * This module extracts the common parsing code that was duplicated in both
 * TimeTimelineProcessing.ts and LinkTimelineProcessing.ts. It provides a
 * single `parseIOCNode` function that detects IOC type, extracts field
 * values, and looks up icon/color from the IOC_TYPES constant.
 *
 * The parser works on the raw markdown text content stored inside Obsidian
 * canvas text nodes. IOC cards are generated by RenderIOCCards.ts which
 * produces markdown with an HTML header (containing the IOC type name and
 * inline SVG) followed by field values in code blocks and metadata fields
 * formatted as **Label:** value.
 */

import { IOC_TYPES } from './IOCCardsTypes';

/**
 * Structured data extracted from a single IOC canvas node.
 * Returned by `parseIOCNode` when the node text matches a known IOC type.
 */
export interface IOCNodeData {
    /** Canvas node ID */
    id: string;
    /** IOC type name (e.g. "IP Address", "File Hash") */
    type: string;
    /** Primary value extracted from the first code block */
    value: string;
    /** Time of Event timestamp string */
    time: string;
    /** Splunk query string */
    splunkQuery: string;
    /** MITRE ATT&CK tactic */
    tactic: string;
    /** MITRE ATT&CK technique */
    technique: string;
    /** Inline SVG string for the IOC type icon */
    icon: string;
    /** Hex color string for the IOC type */
    color: string;
}

/**
 * IOC type detection patterns.
 *
 * ORDER MATTERS: More specific patterns must come before less specific ones.
 * For example:
 *   - "File Hash" must appear before "File" to avoid "File" matching first
 *   - "Domain Name" must appear before generic patterns
 *   - "IP Address" and "Email Address" must appear before generic words
 *   - "Network" matches the IOC_TYPES constant key name (not "Network Traffic")
 *   - "Command Line" must appear before short generic patterns
 *
 * Each pattern uses case-insensitive matching against the full node text.
 */
const IOC_TYPE_PATTERNS: { pattern: RegExp; type: string }[] = [
    { pattern: /IP Address/i, type: "IP Address" },
    { pattern: /Domain Name/i, type: "Domain Name" },
    { pattern: /File Hash/i, type: "File Hash" },
    { pattern: /URL/i, type: "URL" },
    { pattern: /Email Address/i, type: "Email Address" },
    { pattern: /Hostname/i, type: "Hostname" },
    { pattern: /YARA Rule/i, type: "YARA Rule" },
    { pattern: /Sigma Rule/i, type: "Sigma Rule" },
    { pattern: /Registry Key/i, type: "Registry Key" },
    { pattern: /Process Name/i, type: "Process Name" },
    // FIX: The IOC_TYPES constant uses "Network" (not "Network Traffic").
    // The old code used "Network Traffic" which would never match the
    // IOC_TYPES lookup, so color and icon were never resolved for this type.
    { pattern: /Network/i, type: "Network" },
    { pattern: /Command Line/i, type: "Command Line" },
    { pattern: /File/i, type: "File" },
    { pattern: /Note/i, type: "Note" },
    { pattern: /DLL/i, type: "DLL" },
    { pattern: /C2/i, type: "C2" }
];

/**
 * Detect the IOC type from node text content.
 *
 * Iterates through IOC_TYPE_PATTERNS in order, returning the first match.
 * Because patterns are tested in sequence, specificity ordering prevents
 * false positives (e.g. "File Hash" node won't match generic "File").
 */
function detectIOCType(text: string): string {
    for (const { pattern, type } of IOC_TYPE_PATTERNS) {
        if (pattern.test(text)) {
            return type;
        }
    }
    return '';
}

/**
 * Extract the primary value from IOC card text.
 *
 * The FIRST FIELD of each card is always considered the "value" for timeline display,
 * regardless of what the field is named (IP, Domain, Hash, etc.).
 *
 * Format with ----- separators:
 *   </div></div>
 *   FirstFieldName:
 *
 *   value_text_here
 *   -----
 *
 *   SecondFieldName:
 *   ...
 *
 * This extracts the text between the first field label and the first "-----" separator.
 *
 * DEBUG: Console logs show extraction steps for troubleshooting.
 */
function extractValue(text: string): string {
    console.log('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━');
    console.log('[IOCParser] extractValue - ===== STARTING VALUE EXTRACTION =====');
    console.log('[IOCParser] extractValue - Input text length:', text.length);
    console.log('[IOCParser] extractValue - Full input text:');
    console.log(text);
    console.log('[IOCParser] extractValue - First 400 chars:', text.substring(0, 400));
    console.log('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━');

    // First try code blocks (legacy format for backward compatibility)
    console.log('[IOCParser] extractValue - Checking for legacy code block format...');
    const codeBlockMatch = text.match(/```([\s\S]*?)```/);
    if (codeBlockMatch && codeBlockMatch[1] && codeBlockMatch[1].trim()) {
        const value = codeBlockMatch[1].trim();
        console.log('[IOCParser] extractValue - ✓ Found code block value:', value);
        console.log('[IOCParser] extractValue - ===== EXTRACTION COMPLETE (code block) =====');
        return value;
    }
    console.log('[IOCParser] extractValue - ✗ No code block found, proceeding with field extraction');

    // Split by HTML header closing tag to get content after header
    console.log('[IOCParser] extractValue - Splitting by HTML header tag "</div></div>"...');
    const parts = text.split('</div></div>');
    console.log('[IOCParser] extractValue - Split resulted in', parts.length, 'parts');
    if (parts.length > 1) {
        console.log('[IOCParser] extractValue - Part 0 (header) length:', parts[0].length);
        console.log('[IOCParser] extractValue - Part 1 (content) length:', parts[1].length);
    }

    if (parts.length < 2) {
        console.log('[IOCParser] extractValue - ✗ ERROR: No HTML header found!');
        console.log('[IOCParser] extractValue - This means "</div></div>" was not found in the card text');
        console.log('[IOCParser] extractValue - ===== EXTRACTION FAILED (no header) =====');
        return '';
    }

    console.log('[IOCParser] extractValue - ✓ HTML header found, processing content...');
    let afterHeader = parts[1].trim(); // Trim leading/trailing whitespace
    console.log('[IOCParser] extractValue - ===== CONTENT AFTER HEADER (FULL TEXT) =====');
    console.log('"""');
    console.log(afterHeader);
    console.log('"""');
    console.log('[IOCParser] extractValue - afterHeader length:', afterHeader.length);
    console.log('[IOCParser] extractValue - First 400 chars:', afterHeader.substring(0, 400));
    console.log('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━');

    // Find first field label (text ending with colon)
    // This regex matches any characters except newline/colon, then colon, then EITHER:
    //   - whitespace + newlines (value on next line), OR
    //   - space + content on same line
    console.log('[IOCParser] extractValue - Searching for first field label (pattern: [text]:)...');
    const fieldMatch = afterHeader.match(/[^:\n]+:\s*/);
    if (!fieldMatch) {
        console.log('[IOCParser] extractValue - ✗ ERROR: No field label found!');
        console.log('[IOCParser] extractValue - afterHeader starts with:', JSON.stringify(afterHeader.substring(0, 100)));
        console.log('[IOCParser] extractValue - Looking for pattern like "fieldname: \\n"');
        console.log('[IOCParser] extractValue - ===== EXTRACTION FAILED (no field label) =====');
        return '';
    }

    const firstFieldName = fieldMatch[0].trim();
    console.log('[IOCParser] extractValue - ✓ Found FIRST field:', JSON.stringify(firstFieldName));
    console.log('[IOCParser] extractValue - Field match raw text:', JSON.stringify(fieldMatch[0]));
    console.log('[IOCParser] extractValue - Field match index:', fieldMatch.index, 'length:', fieldMatch[0].length);
    console.log('[IOCParser] extractValue - This field will be used as the card VALUE');
    console.log('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━');

    // Get content after the field label
    // Extract everything after "FieldName: " (whether value is on same line or next line)
    console.log('[IOCParser] extractValue - Extracting content after field label...');
    const afterFieldLabel = afterHeader.substring(fieldMatch.index! + fieldMatch[0].length);
    console.log('[IOCParser] extractValue - ===== CONTENT AFTER FIELD LABEL (should contain value) =====');
    console.log('"""');
    console.log(afterFieldLabel);
    console.log('"""');
    console.log('[IOCParser] extractValue - afterFieldLabel length:', afterFieldLabel.length);
    console.log('[IOCParser] extractValue - First 300 chars:', afterFieldLabel.substring(0, 300));
    console.log('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━');

    // Find the first "-----" separator OR the first newline followed by another field
    // This handles both inline values (hash: value) and next-line values
    console.log('[IOCParser] extractValue - Searching for value delimiter (separator or next field)...');

    // Look for separator first
    const separatorMatch = afterFieldLabel.match(/\n?-----/);

    // Also look for next field label as a delimiter
    const nextFieldMatch = afterFieldLabel.match(/\n([^:\n]+:\s*)/);

    let value: string;
    let delimiterIndex: number | undefined;
    let delimiterType: string;

    // Determine which delimiter comes first
    if (separatorMatch && separatorMatch.index !== undefined) {
        delimiterIndex = separatorMatch.index;
        delimiterType = 'separator (-----)';
    }

    if (nextFieldMatch && nextFieldMatch.index !== undefined) {
        if (delimiterIndex === undefined || nextFieldMatch.index < delimiterIndex) {
            delimiterIndex = nextFieldMatch.index;
            delimiterType = 'next field';
        }
    }

    if (delimiterIndex === undefined) {
        // No separator or next field found - extract everything until Time of Event
        console.log('[IOCParser] extractValue - WARNING: No delimiter found!');
        console.log('[IOCParser] extractValue - Searching for Time of Event as fallback...');
        const timeIndex = afterFieldLabel.indexOf('Time of Event:');
        if (timeIndex === -1) {
            value = afterFieldLabel;
            console.log('[IOCParser] extractValue - No Time of Event either, using all remaining content');
        } else {
            value = afterFieldLabel.substring(0, timeIndex);
            console.log('[IOCParser] extractValue - Extracted until Time of Event at index', timeIndex);
        }
    } else {
        // Extract content before first delimiter
        value = afterFieldLabel.substring(0, delimiterIndex);
        console.log(`[IOCParser] extractValue - SUCCESS: Found ${delimiterType} at index`, delimiterIndex);
        console.log('[IOCParser] extractValue - Raw value (before trim):', JSON.stringify(value));
        console.log('[IOCParser] extractValue - Raw value length:', value.length);
    }

    // Trim whitespace and return
    console.log('[IOCParser] extractValue - Trimming whitespace from extracted value...');
    const trimmedValue = value.trim();
    console.log('[IOCParser] extractValue - ===== FINAL EXTRACTED VALUE =====');
    console.log('[IOCParser] extractValue - Value (trimmed):', JSON.stringify(trimmedValue));
    console.log('[IOCParser] extractValue - Value length:', trimmedValue.length);
    console.log('[IOCParser] extractValue - Value is empty?', trimmedValue.length === 0);
    if (trimmedValue.length === 0) {
        console.log('[IOCParser] extractValue - ⚠️  WARNING: Extracted value is EMPTY!');
        console.log('[IOCParser] extractValue - This means no content was found between field label and separator');
    } else {
        console.log('[IOCParser] extractValue - ✓ SUCCESS: Value extracted successfully');
    }
    console.log('[IOCParser] extractValue - ===== EXTRACTION COMPLETE =====');
    console.log('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━');
    return trimmedValue;
}

/**
 * Extract the "Time of Event" timestamp from node text.
 *
 * RenderIOCCards.ts generates timestamps in "YYYY-MM-DD HH:MM:SS" format
 * (via toISOString with T replaced by space). The patterns try progressively
 * less specific formats:
 *   1. **Time of Event:** followed by datetime
 *   2. **Time of Event:** followed by date only
 *   3. Bare "Time" label followed by datetime
 *   4. Any standalone datetime pattern in the text
 */
function extractTime(text: string): string {
    const timePatterns = [
        /\*\*Time of Event:\*\*\s*(\d{4}-\d{2}-\d{2}\s\d{2}:\d{2}:\d{2})/i,
        /\*\*Time of Event:\*\*\s*(\d{4}-\d{2}-\d{2})/i,
        /Time of Event[:\s]*(\d{4}-\d{2}-\d{2}[T\s]\d{2}:\d{2}:\d{2})/i,
        /Time of Event[:\s]*(\d{4}-\d{2}-\d{2})/i,
        /Time[:\s]*(\d{4}-\d{2}-\d{2}[T\s]\d{2}:\d{2}:\d{2})/i,
        /(\d{4}-\d{2}-\d{2}[T\s]\d{2}:\d{2}:\d{2})/i
    ];

    for (const pattern of timePatterns) {
        const match = text.match(pattern);
        if (match && match[1]) {
            return match[1].trim();
        }
    }
    return '';
}

/**
 * Extract the Splunk query from node text.
 *
 * RenderIOCCards.ts produces: **Splunk Query:** <query text>
 * The regex matches everything after the label up to the next bold marker
 * or end of string (non-greedy via [\s\S]*?).
 */
function extractSplunkQuery(text: string): string {
    const match = text.match(/\*\*Splunk Query:\*\*[:\s]*([\s\S]*?)(?=\*\*|$)/i);
    if (match && match[1] && match[1].trim()) {
        return match[1].trim();
    }
    return '';
}

/**
 * Extract the MITRE ATT&CK tactic from node text.
 *
 * Handles both formats:
 *   - Plain text: Mitre Tactic: <tactic>
 *   - Bold markdown: **Mitre Tactic:** <tactic>
 */
function extractTactic(text: string): string {
    // Try plain text format first (current template format)
    let match = text.match(/Mitre Tactic:\s*([^\n]+)/i);
    if (match && match[1] && match[1].trim()) {
        return match[1].trim();
    }

    // Fall back to bold markdown format (backwards compatibility)
    match = text.match(/\*\*Mitre Tactic:\*\*\s*([^\n]+)/i)
        || text.match(/\*\*Mitre Tactic:\*\*[:\s]*([\s\S]*?)(?=\*\*|$)/i);
    if (match && match[1]) {
        return match[1].trim();
    }

    return '';
}

/**
 * Extract the MITRE ATT&CK technique from node text.
 *
 * Handles both formats:
 *   - Plain text: Mitre Technique: <technique>
 *   - Bold markdown: **Mitre Technique:** <technique>
 */
function extractTechnique(text: string): string {
    // Try plain text format first (current template format)
    let match = text.match(/Mitre Technique:\s*([^\n]+)/i);
    if (match && match[1] && match[1].trim()) {
        return match[1].trim();
    }

    // Fall back to bold markdown format (backwards compatibility)
    match = text.match(/\*\*Mitre Technique:\*\*\s*([^\n]+)/i)
        || text.match(/\*\*Mitre Technique:\*\*[:\s]*([\s\S]*?)(?=\*\*|$)/i);
    if (match && match[1]) {
        return match[1].trim();
    }

    return '';
}

/**
 * Look up the SVG icon and hex color for a given IOC type name.
 *
 * Searches the IOC_TYPES constant (from IOCCardsTypes.ts) by comparing
 * each entry's `name` property against the detected type string.
 * Returns defaults if no match is found (empty icon, fallback color).
 */
function lookupTypeVisuals(iocType: string, fallbackColor: string): { icon: string; color: string } {
    let icon = '';
    let color = fallbackColor;

    if (IOC_TYPES && typeof IOC_TYPES === 'object') {
        for (const key of Object.keys(IOC_TYPES)) {
            if (IOC_TYPES[key].name === iocType) {
                icon = IOC_TYPES[key].svg;
                color = IOC_TYPES[key].color;
                break;
            }
        }
    }

    return { icon, color };
}

/**
 * Parse an Obsidian canvas text node and extract structured IOC data.
 *
 * This is the main entry point used by both TimeTimelineProcessing and
 * LinkTimelineProcessing. It combines all extraction steps:
 *   1. Detect IOC type from the node's text content
 *   2. Extract value, time, splunk query, tactic, and technique
 *   3. Look up the SVG icon and color from IOC_TYPES
 *
 * DEBUG: Console logs show parsing steps for troubleshooting.
 *
 * @param node - An Obsidian canvas node object with `id`, `text`, and
 *               optional `color` properties
 * @returns IOCNodeData with all fields populated, or null if the node
 *          text does not match any known IOC type
 */
export function parseIOCNode(node: any): IOCNodeData | null {
    console.log('[IOCParser] parseIOCNode - Processing node ID:', node.id);

    // Validate node has text content
    if (!node.text) {
        console.log('[IOCParser] parseIOCNode - Node has no text, skipping');
        return null;
    }

    const text = node.text;
    console.log('[IOCParser] parseIOCNode - Node text length:', text.length);

    // Step 1: Detect IOC type
    const iocType = detectIOCType(text);
    console.log('[IOCParser] parseIOCNode - Detected IOC type:', iocType || 'NONE');
    if (!iocType) {
        console.log('[IOCParser] parseIOCNode - No IOC type detected, returning null');
        return null;
    }

    // Step 2: Extract field values from the markdown content
    console.log('[IOCParser] parseIOCNode - Extracting fields for type:', iocType);
    console.log('[IOCParser] parseIOCNode - ===== VALUE EXTRACTION START =====');
    const value = extractValue(text);
    console.log('[IOCParser] parseIOCNode - ===== VALUE EXTRACTION END =====');
    console.log('[IOCParser] parseIOCNode - EXTRACTED VALUE:', value || '(empty/null)', '(length:', value ? value.length : 0, ')');

    const time = extractTime(text);
    const splunkQuery = extractSplunkQuery(text);
    const tactic = extractTactic(text);
    const technique = extractTechnique(text);

    console.log('[IOCParser] parseIOCNode - All extracted fields:');
    console.log('  - value:', value || '**EMPTY**');
    console.log('  - time:', time || '(empty)');
    console.log('  - splunkQuery:', splunkQuery || '(empty)');
    console.log('  - tactic:', tactic || '(empty)');
    console.log('  - technique:', technique || '(empty)');

    // Step 3: Look up icon and color from the IOC_TYPES constant
    const fallbackColor = node.color || '#333';
    const { icon, color } = lookupTypeVisuals(iocType, fallbackColor);
    console.log('[IOCParser] parseIOCNode - Looked up visuals - color:', color, 'icon length:', icon.length);

    const result = {
        id: node.id,
        type: iocType,
        value,
        time,
        splunkQuery,
        tactic,
        technique,
        icon,
        color
    };

    console.log('[IOCParser] parseIOCNode - ===== FINAL RESULT =====');
    console.log('[IOCParser] parseIOCNode - Returning node with value:', result.value || '**NO VALUE**');
    console.log('[IOCParser] parseIOCNode - Full result:', JSON.stringify(result, null, 2));
    console.log('[IOCParser] parseIOCNode - ===== END PARSING =====');
    return result;
}
