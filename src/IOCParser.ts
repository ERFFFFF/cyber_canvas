/**
 * IOCParser.ts - Shared IOC node parsing logic
 *
 * This module extracts the common parsing code that was duplicated in both
 * TimeTimelineProcessing.ts and LinkTimelineProcessing.ts. It provides a
 * single `parseIOCNode` function that detects IOC type, extracts field
 * values, and looks up icon/color from the IOC_TYPES constant.
 *
 * The parser works on the raw markdown text content stored inside Obsidian
 * canvas text nodes. IOC cards are generated by RenderIOCCards.ts which
 * produces markdown with an HTML header (containing the IOC type name and
 * inline SVG) followed by field values in code blocks and metadata fields
 * formatted as **Label:** value.
 */

import { IOC_TYPES } from './IOCCardsTypes';

/**
 * Structured data extracted from a single IOC canvas node.
 * Returned by `parseIOCNode` when the node text matches a known IOC type.
 */
export interface IOCNodeData {
    /** Canvas node ID */
    id: string;
    /** Timestamp-based card ID (e.g. "#20260214-1534") */
    cardId?: string;
    /** IOC type name (e.g. "IP Address", "File Hash") */
    type: string;
    /** Primary value extracted from the first code block */
    value: string;
    /** Time of Event timestamp string */
    time: string;
    /** Splunk query string */
    splunkQuery: string;
    /** MITRE ATT&CK tactic */
    tactic: string;
    /** MITRE ATT&CK technique */
    technique: string;
    /** Inline SVG string for the IOC type icon */
    icon: string;
    /** Hex color string for the IOC type */
    color: string;
}

/**
 * IOC type detection patterns.
 *
 * ORDER MATTERS: More specific patterns must come before less specific ones.
 * For example:
 *   - "File Hash" must appear before "File" to avoid "File" matching first
 *   - "Domain Name" must appear before generic patterns
 *   - "IP Address" and "Email Address" must appear before generic words
 *   - "Network" matches the IOC_TYPES constant key name (not "Network Traffic")
 *   - "Command Line" must appear before short generic patterns
 *
 * Each pattern uses case-insensitive matching against the full node text.
 */
const IOC_TYPE_PATTERNS: { pattern: RegExp; type: string }[] = [
    { pattern: /IP Address/i, type: "IP Address" },
    { pattern: /Domain Name/i, type: "Domain Name" },
    { pattern: /File Hash/i, type: "File Hash" },
    { pattern: /URL/i, type: "URL" },
    { pattern: /Email Address/i, type: "Email Address" },
    { pattern: /Hostname/i, type: "Hostname" },
    { pattern: /YARA Rule/i, type: "YARA Rule" },
    { pattern: /Sigma Rule/i, type: "Sigma Rule" },
    { pattern: /Registry Key/i, type: "Registry Key" },
    { pattern: /Process Name/i, type: "Process Name" },
    // FIX: The IOC_TYPES constant uses "Network" (not "Network Traffic").
    // The old code used "Network Traffic" which would never match the
    // IOC_TYPES lookup, so color and icon were never resolved for this type.
    { pattern: /Network/i, type: "Network" },
    { pattern: /Command Line/i, type: "Command Line" },
    { pattern: /File/i, type: "File" },
    { pattern: /Note/i, type: "Note" },
    { pattern: /DLL/i, type: "DLL" },
    { pattern: /C2/i, type: "C2" }
];

/**
 * Detect the IOC type from node text content.
 *
 * Iterates through IOC_TYPE_PATTERNS in order, returning the first match.
 * Because patterns are tested in sequence, specificity ordering prevents
 * false positives (e.g. "File Hash" node won't match generic "File").
 */
function detectIOCType(text: string): string {
    for (const { pattern, type } of IOC_TYPE_PATTERNS) {
        if (pattern.test(text)) {
            return type;
        }
    }
    return '';
}

/**
 * Extract the primary value from IOC card text.
 *
 * The FIRST FIELD of each card is always considered the "value" for timeline display,
 * regardless of what the field is named (IP, Domain, Hash, etc.).
 *
 * Format with ----- separators:
 *   </div></div>
 *   FirstFieldName:
 *
 *   value_text_here
 *   -----
 *
 *   SecondFieldName:
 *   ...
 *
 * This extracts the text between the first field label and the first "-----" separator.
 *
 * DEBUG: Console logs show extraction steps for troubleshooting.
 */
function extractValue(text: string): string {
    console.debug('[IOCParser] extractValue - input length:', text.length);

    // First try code blocks (legacy format for backward compatibility)
    const codeBlockMatch = text.match(/```([\s\S]*?)```/);
    if (codeBlockMatch && codeBlockMatch[1] && codeBlockMatch[1].trim()) {
        const value = codeBlockMatch[1].trim();
        console.debug('[IOCParser] extractValue - found code block:', value);
        return value;
    }

    // Split by HTML header closing tag to get content after header
    const parts = text.split('</div></div>');
    if (parts.length < 2) {
        console.debug('[IOCParser] extractValue - no HTML header found');
        return '';
    }

    let afterHeader = parts[1].trim();
    console.debug('[IOCParser] extractValue - content after header length:', afterHeader.length);

    // Find first field label (text ending with colon)
    const fieldMatch = afterHeader.match(/[^:\n]+:\s*/);
    if (!fieldMatch) {
        console.debug('[IOCParser] extractValue - no field label found');
        return '';
    }

    console.debug('[IOCParser] extractValue - first field:', fieldMatch[0].trim());

    // Get content after the field label
    const afterFieldLabel = afterHeader.substring(fieldMatch.index! + fieldMatch[0].length);

    // Find the first "-----" separator OR the first newline followed by another field
    const separatorMatch = afterFieldLabel.match(/\n?-----/);
    const nextFieldMatch = afterFieldLabel.match(/\n([^:\n]+:\s*)/);

    let value: string;
    let delimiterIndex: number | undefined;

    // Determine which delimiter comes first
    if (separatorMatch && separatorMatch.index !== undefined) {
        delimiterIndex = separatorMatch.index;
    }

    if (nextFieldMatch && nextFieldMatch.index !== undefined) {
        if (delimiterIndex === undefined || nextFieldMatch.index < delimiterIndex) {
            delimiterIndex = nextFieldMatch.index;
        }
    }

    if (delimiterIndex === undefined) {
        // No separator or next field found - extract everything until Time of Event
        const timeIndex = afterFieldLabel.indexOf('Time of Event:');
        value = timeIndex === -1 ? afterFieldLabel : afterFieldLabel.substring(0, timeIndex);
    } else {
        // Extract content before first delimiter
        value = afterFieldLabel.substring(0, delimiterIndex);
    }

    const trimmedValue = value.trim();
    console.debug('[IOCParser] extractValue - result:', trimmedValue || '(empty)');
    return trimmedValue;
}

/**
 * Extract the "Time of Event" timestamp from node text.
 *
 * RenderIOCCards.ts generates timestamps in "YYYY-MM-DD HH:MM:SS" format
 * (via toISOString with T replaced by space). The patterns try progressively
 * less specific formats:
 *   1. **Time of Event:** followed by datetime
 *   2. **Time of Event:** followed by date only
 *   3. Bare "Time" label followed by datetime
 *   4. Any standalone datetime pattern in the text
 */
function extractTime(text: string): string {
    const timePatterns = [
        /\*\*Time of Event:\*\*\s*(\d{4}-\d{2}-\d{2}\s\d{2}:\d{2}:\d{2})/i,
        /\*\*Time of Event:\*\*\s*(\d{4}-\d{2}-\d{2})/i,
        /Time of Event[:\s]*(\d{4}-\d{2}-\d{2}[T\s]\d{2}:\d{2}:\d{2})/i,
        /Time of Event[:\s]*(\d{4}-\d{2}-\d{2})/i,
        /Time[:\s]*(\d{4}-\d{2}-\d{2}[T\s]\d{2}:\d{2}:\d{2})/i,
        /(\d{4}-\d{2}-\d{2}[T\s]\d{2}:\d{2}:\d{2})/i
    ];

    for (const pattern of timePatterns) {
        const match = text.match(pattern);
        if (match && match[1]) {
            return match[1].trim();
        }
    }
    return '';
}

/**
 * Extract the Splunk query from node text.
 *
 * RenderIOCCards.ts produces: **Splunk Query:** <query text>
 * The regex matches everything after the label up to the next bold marker
 * or end of string (non-greedy via [\s\S]*?).
 */
function extractSplunkQuery(text: string): string {
    const match = text.match(/\*\*Splunk Query:\*\*[:\s]*([\s\S]*?)(?=\*\*|$)/i);
    if (match && match[1] && match[1].trim()) {
        return match[1].trim();
    }
    return '';
}

/**
 * Extract the MITRE ATT&CK tactic from node text.
 *
 * Handles both formats:
 *   - Plain text: Mitre Tactic: <tactic>
 *   - Bold markdown: **Mitre Tactic:** <tactic>
 *
 * IMPORTANT: Use [ \t]* instead of \s* to avoid matching newlines.
 * This prevents the regex from skipping empty lines and capturing the next field.
 *
 * @returns Normalized tactic value in UPPERCASE for consistent matching
 */
function extractTactic(text: string): string {
    console.debug('[IOCParser] Extracting tactic...');

    // Try plain text format first (current template format)
    // Use [ \t]* to match spaces/tabs but NOT newlines
    // Use [^\n]* (not +) to allow capturing empty values
    let match = text.match(/Mitre Tactic:[ \t]*([^\n]*)/i);
    if (match && match[1] && match[1].trim()) {
        const tactic = match[1].trim().toUpperCase();
        console.debug('[IOCParser] ✓ Found tactic (plain):', tactic);
        return tactic;
    }

    // Fall back to bold markdown format (backwards compatibility)
    match = text.match(/\*\*Mitre Tactic:\*\*[ \t]*([^\n]*)/i)
        || text.match(/\*\*Mitre Tactic:\*\*[:\s]*([\s\S]*?)(?=\*\*|$)/i);
    if (match && match[1] && match[1].trim()) {
        const tactic = match[1].trim().toUpperCase();
        console.debug('[IOCParser] ✓ Found tactic (bold):', tactic);
        return tactic;
    }

    console.debug('[IOCParser] ⚠ No tactic found');
    return '';
}

/**
 * Extract the MITRE ATT&CK technique from node text.
 *
 * Handles both formats:
 *   - Plain text: Mitre Technique: <technique>
 *   - Bold markdown: **Mitre Technique:** <technique>
 *
 * IMPORTANT: Use [ \t]* instead of \s* to avoid matching newlines.
 * This prevents the regex from skipping empty lines and capturing the next field.
 *
 * @returns Normalized technique value in UPPERCASE for consistent matching
 */
function extractTechnique(text: string): string {
    console.debug('[IOCParser] Extracting technique...');

    // Try plain text format first (current template format)
    // Use [ \t]* to match spaces/tabs but NOT newlines
    // Use [^\n]* (not +) to allow capturing empty values
    let match = text.match(/Mitre Technique:[ \t]*([^\n]*)/i);
    if (match && match[1] && match[1].trim()) {
        const technique = match[1].trim().toUpperCase();
        console.debug('[IOCParser] ✓ Found technique (plain):', technique);
        return technique;
    }

    // Fall back to bold markdown format (backwards compatibility)
    match = text.match(/\*\*Mitre Technique:\*\*[ \t]*([^\n]*)/i)
        || text.match(/\*\*Mitre Technique:\*\*[:\s]*([\s\S]*?)(?=\*\*|$)/i);
    if (match && match[1] && match[1].trim()) {
        const technique = match[1].trim().toUpperCase();
        console.debug('[IOCParser] ✓ Found technique (bold):', technique);
        return technique;
    }

    console.debug('[IOCParser] ⚠ No technique found');
    return '';
}

/**
 * Extract the Card ID field from IOC card markdown.
 * Format: HTML comment (new) or legacy field (backward compatibility)
 * New format: <!-- IOC_CARD_ID:#YYYYMMDD-HHMM -->
 * Legacy format: "Card ID: #YYYYMMDD-HHMM"
 */
function extractCardId(text: string): string {
    console.debug('[IOCParser] Extracting Card ID...');

    // NEW FORMAT: Try HTML comment first (preferred)
    const commentMatch = text.match(/<!-- IOC_CARD_ID:([^>]+) -->/);
    if (commentMatch && commentMatch[1]) {
        const cardId = commentMatch[1].trim();
        console.debug('[IOCParser] Found Card ID in HTML comment:', cardId);
        return cardId;
    }

    // LEGACY FORMAT: Fall back to markdown field for backward compatibility
    const cardIdMatch = text.match(/Card ID:\s*([^\n]+)/i);
    if (cardIdMatch && cardIdMatch[1]) {
        const cardId = cardIdMatch[1].trim();
        console.debug('[IOCParser] Found Card ID in legacy field format:', cardId);
        return cardId;
    }

    console.debug('[IOCParser] No Card ID found');
    return '';
}

/**
 * Look up the SVG icon and hex color for a given IOC type name.
 *
 * Searches the IOC_TYPES constant (from IOCCardsTypes.ts) by comparing
 * each entry's `name` property against the detected type string.
 * Returns defaults if no match is found (empty icon, fallback color).
 */
function lookupTypeVisuals(iocType: string, fallbackColor: string): { icon: string; color: string } {
    let icon = '';
    let color = fallbackColor;

    if (IOC_TYPES && typeof IOC_TYPES === 'object') {
        for (const key of Object.keys(IOC_TYPES)) {
            if (IOC_TYPES[key].name === iocType) {
                icon = IOC_TYPES[key].svg;
                color = IOC_TYPES[key].color;
                break;
            }
        }
    }

    return { icon, color };
}

/**
 * Parse an Obsidian canvas text node and extract structured IOC data.
 *
 * This is the main entry point used by both TimeTimelineProcessing and
 * LinkTimelineProcessing. It combines all extraction steps:
 *   1. Detect IOC type from the node's text content
 *   2. Extract value, time, splunk query, tactic, and technique
 *   3. Look up the SVG icon and color from IOC_TYPES
 *
 * DEBUG: Console logs show parsing steps for troubleshooting.
 *
 * @param node - An Obsidian canvas node object with `id`, `text`, and
 *               optional `color` properties
 * @returns IOCNodeData with all fields populated, or null if the node
 *          text does not match any known IOC type
 */
export function parseIOCNode(node: any): IOCNodeData | null {
    console.debug('[IOCParser] ==================== PARSING NODE ====================');
    console.debug('[IOCParser] Node ID:', node.id);
    console.debug('[IOCParser] Text length:', node.text?.length || 0);

    if (!node.text) {
        console.debug('[IOCParser] ❌ No text content');
        return null;
    }

    // Step 1: Detect IOC type
    const iocType = detectIOCType(node.text);
    if (!iocType) {
        console.debug('[IOCParser] ❌ No IOC type detected');
        return null;
    }
    console.debug('[IOCParser] ✓ IOC Type:', iocType);

    // Step 2: Extract field values
    const value = extractValue(node.text);
    const time = extractTime(node.text);
    const splunkQuery = extractSplunkQuery(node.text);
    const tactic = extractTactic(node.text);
    const technique = extractTechnique(node.text);
    const cardId = extractCardId(node.text);

    // Step 3: Look up icon and color from the IOC_TYPES constant
    const fallbackColor = node.color || '#333';
    const { icon, color } = lookupTypeVisuals(iocType, fallbackColor);

    const result = {
        id: node.id,
        cardId: cardId,
        type: iocType,
        value,
        time,
        splunkQuery,
        tactic,
        technique,
        icon,
        color
    };

    console.debug('[IOCParser] ✓ EXTRACTION COMPLETE:', {
        type: iocType,
        cardId: cardId || '(no ID)',
        value: value || '(empty)',
        time: time || '(empty)',
        tactic: tactic || '(empty)',
        technique: technique || '(empty)'
    });
    console.debug('[IOCParser] =========================================================');
    return result;
}
