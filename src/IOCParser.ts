/**
 * IOCParser.ts - Shared IOC node parsing logic
 *
 * This module extracts the common parsing code that was duplicated in both
 * TimeTimelineProcessing.ts and LinkTimelineProcessing.ts. It provides a
 * single `parseIOCNode` function that detects IOC type, extracts field
 * values, and looks up icon/color from the IOC_TYPES constant.
 *
 * The parser works on the raw markdown text content stored inside Obsidian
 * canvas text nodes. IOC cards are generated by RenderIOCCards.ts which
 * produces markdown with an HTML header (containing the IOC type name and
 * inline SVG) followed by field values in code blocks and metadata fields
 * formatted as **Label:** value.
 */

import { IOC_TYPES } from './IOCCardsTypes';

/**
 * Structured data extracted from a single IOC canvas node.
 * Returned by `parseIOCNode` when the node text matches a known IOC type.
 */
export interface IOCNodeData {
    /** Canvas node ID */
    id: string;
    /** IOC type name (e.g. "IP Address", "File Hash") */
    type: string;
    /** Primary value extracted from the first code block */
    value: string;
    /** Time of Event timestamp string */
    time: string;
    /** Splunk query string */
    splunkQuery: string;
    /** MITRE ATT&CK tactic */
    tactic: string;
    /** MITRE ATT&CK technique */
    technique: string;
    /** Inline SVG string for the IOC type icon */
    icon: string;
    /** Hex color string for the IOC type */
    color: string;
}

/**
 * IOC type detection patterns.
 *
 * ORDER MATTERS: More specific patterns must come before less specific ones.
 * For example:
 *   - "File Hash" must appear before "File" to avoid "File" matching first
 *   - "Domain Name" must appear before generic patterns
 *   - "IP Address" and "Email Address" must appear before generic words
 *   - "Network" matches the IOC_TYPES constant key name (not "Network Traffic")
 *   - "Command Line" must appear before short generic patterns
 *
 * Each pattern uses case-insensitive matching against the full node text.
 */
const IOC_TYPE_PATTERNS: { pattern: RegExp; type: string }[] = [
    { pattern: /IP Address/i, type: "IP Address" },
    { pattern: /Domain Name/i, type: "Domain Name" },
    { pattern: /File Hash/i, type: "File Hash" },
    { pattern: /URL/i, type: "URL" },
    { pattern: /Email Address/i, type: "Email Address" },
    { pattern: /Hostname/i, type: "Hostname" },
    { pattern: /YARA Rule/i, type: "YARA Rule" },
    { pattern: /Sigma Rule/i, type: "Sigma Rule" },
    { pattern: /Registry Key/i, type: "Registry Key" },
    { pattern: /Process Name/i, type: "Process Name" },
    // FIX: The IOC_TYPES constant uses "Network" (not "Network Traffic").
    // The old code used "Network Traffic" which would never match the
    // IOC_TYPES lookup, so color and icon were never resolved for this type.
    { pattern: /Network/i, type: "Network" },
    { pattern: /Command Line/i, type: "Command Line" },
    { pattern: /File/i, type: "File" },
    { pattern: /Note/i, type: "Note" },
    { pattern: /DLL/i, type: "DLL" },
    { pattern: /C2/i, type: "C2" }
];

/**
 * Detect the IOC type from node text content.
 *
 * Iterates through IOC_TYPE_PATTERNS in order, returning the first match.
 * Because patterns are tested in sequence, specificity ordering prevents
 * false positives (e.g. "File Hash" node won't match generic "File").
 */
function detectIOCType(text: string): string {
    for (const { pattern, type } of IOC_TYPE_PATTERNS) {
        if (pattern.test(text)) {
            return type;
        }
    }
    return '';
}

/**
 * Extract the primary value from the first triple-backtick code block.
 *
 * IOC cards store their main value (IP, hash, URL, etc.) inside a fenced
 * code block. This regex captures content between ``` delimiters, allowing
 * multi-line values via [\s\S]*? (non-greedy).
 */
function extractValue(text: string): string {
    const match = text.match(/```([\s\S]*?)```/);
    if (match && match[1] && match[1].trim()) {
        return match[1].trim();
    }
    return '';
}

/**
 * Extract the "Time of Event" timestamp from node text.
 *
 * RenderIOCCards.ts generates timestamps in "YYYY-MM-DD HH:MM:SS" format
 * (via toISOString with T replaced by space). The patterns try progressively
 * less specific formats:
 *   1. **Time of Event:** followed by datetime
 *   2. **Time of Event:** followed by date only
 *   3. Bare "Time" label followed by datetime
 *   4. Any standalone datetime pattern in the text
 */
function extractTime(text: string): string {
    const timePatterns = [
        /\*\*Time of Event:\*\*\s*(\d{4}-\d{2}-\d{2}\s\d{2}:\d{2}:\d{2})/i,
        /\*\*Time of Event:\*\*\s*(\d{4}-\d{2}-\d{2})/i,
        /Time of Event[:\s]*(\d{4}-\d{2}-\d{2}[T\s]\d{2}:\d{2}:\d{2})/i,
        /Time of Event[:\s]*(\d{4}-\d{2}-\d{2})/i,
        /Time[:\s]*(\d{4}-\d{2}-\d{2}[T\s]\d{2}:\d{2}:\d{2})/i,
        /(\d{4}-\d{2}-\d{2}[T\s]\d{2}:\d{2}:\d{2})/i
    ];

    for (const pattern of timePatterns) {
        const match = text.match(pattern);
        if (match && match[1]) {
            return match[1].trim();
        }
    }
    return '';
}

/**
 * Extract the Splunk query from node text.
 *
 * RenderIOCCards.ts produces: **Splunk Query:** <query text>
 * The regex matches everything after the label up to the next bold marker
 * or end of string (non-greedy via [\s\S]*?).
 */
function extractSplunkQuery(text: string): string {
    const match = text.match(/\*\*Splunk Query:\*\*[:\s]*([\s\S]*?)(?=\*\*|$)/i);
    if (match && match[1] && match[1].trim()) {
        return match[1].trim();
    }
    return '';
}

/**
 * Extract the MITRE ATT&CK tactic from node text.
 *
 * RenderIOCCards.ts produces: **Mitre Tactic:** <tactic>
 */
function extractTactic(text: string): string {
    const match = text.match(/\*\*Mitre Tactic:\*\*\s*([^\n]+)/i)
        || text.match(/\*\*Mitre Tactic:\*\*[:\s]*([\s\S]*?)(?=\*\*|$)/i);
    if (match && match[1]) {
        return match[1].trim();
    }
    return '';
}

/**
 * Extract the MITRE ATT&CK technique from node text.
 *
 * RenderIOCCards.ts produces: **Mitre Technique:** <technique>
 */
function extractTechnique(text: string): string {
    const match = text.match(/\*\*Mitre Technique:\*\*\s*([^\n]+)/i)
        || text.match(/\*\*Mitre Technique:\*\*[:\s]*([\s\S]*?)(?=\*\*|$)/i);
    if (match && match[1]) {
        return match[1].trim();
    }
    return '';
}

/**
 * Look up the SVG icon and hex color for a given IOC type name.
 *
 * Searches the IOC_TYPES constant (from IOCCardsTypes.ts) by comparing
 * each entry's `name` property against the detected type string.
 * Returns defaults if no match is found (empty icon, fallback color).
 */
function lookupTypeVisuals(iocType: string, fallbackColor: string): { icon: string; color: string } {
    let icon = '';
    let color = fallbackColor;

    if (IOC_TYPES && typeof IOC_TYPES === 'object') {
        for (const key of Object.keys(IOC_TYPES)) {
            if (IOC_TYPES[key].name === iocType) {
                icon = IOC_TYPES[key].svg;
                color = IOC_TYPES[key].color;
                break;
            }
        }
    }

    return { icon, color };
}

/**
 * Parse an Obsidian canvas text node and extract structured IOC data.
 *
 * This is the main entry point used by both TimeTimelineProcessing and
 * LinkTimelineProcessing. It combines all extraction steps:
 *   1. Detect IOC type from the node's text content
 *   2. Extract value, time, splunk query, tactic, and technique
 *   3. Look up the SVG icon and color from IOC_TYPES
 *
 * @param node - An Obsidian canvas node object with `id`, `text`, and
 *               optional `color` properties
 * @returns IOCNodeData with all fields populated, or null if the node
 *          text does not match any known IOC type
 */
export function parseIOCNode(node: any): IOCNodeData | null {
    if (!node.text) {
        return null;
    }

    const text = node.text;

    // Step 1: Detect IOC type
    const iocType = detectIOCType(text);
    if (!iocType) {
        return null;
    }

    // Step 2: Extract field values from the markdown content
    const value = extractValue(text);
    const time = extractTime(text);
    const splunkQuery = extractSplunkQuery(text);
    const tactic = extractTactic(text);
    const technique = extractTechnique(text);

    // Step 3: Look up icon and color from the IOC_TYPES constant
    const fallbackColor = node.color || '#333';
    const { icon, color } = lookupTypeVisuals(iocType, fallbackColor);

    return {
        id: node.id,
        type: iocType,
        value,
        time,
        splunkQuery,
        tactic,
        technique,
        icon,
        color
    };
}
