/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => IOCCanvasPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian5 = require("obsidian");

// src/RenderTimelinesModal.ts
var import_obsidian = require("obsidian");

// src/IOCCardsTypes.ts
var IOC_TYPES = {
  // --- Network-related IOC types ---
  ip_address: {
    name: "IP Address",
    icon: "network",
    color: "#FF6B6B",
    fields: ["IP", "country", "asn"],
    svg: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="32" height="32" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
  <circle cx="12" cy="15" r="7"/>
  <path d="M12 8c-3.9 0-7 3.1-7 7"/>
  <path d="M12 8c3.9 0 7 3.1 7 7"/>
  <line x1="5" y1="15" x2="19" y2="15"/>
  <line x1="12" y1="8" x2="12" y2="22"/>
  <path d="M12 8c-1.7-3-1.7-6 0-6s1.7 3 0 6z"/>
  <circle cx="12" cy="4" r="2" fill="currentColor"/>
</svg>`
  },
  domain: {
    name: "Domain Name",
    icon: "globe",
    color: "#4ECDC4",
    fields: ["name", "IP"],
    svg: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="32" height="32" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
    <circle cx="12" cy="12" r="10"/>
    <line x1="2" y1="12" x2="22" y2="12"/>
    <path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"/>
  </svg>`
  },
  file_hash: {
    name: "File Hash",
    icon: "hash",
    color: "#45B7D1",
    fields: ["hash", "hash_type", "filename", "file_size"],
    svg: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="32" height="32" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
    <line x1="4" y1="9" x2="20" y2="9"/>
    <line x1="4" y1="15" x2="20" y2="15"/>
    <line x1="10" y1="3" x2="8" y2="21"/>
    <line x1="16" y1="3" x2="14" y2="21"/>
  </svg>`
  },
  url: {
    name: "URL",
    icon: "link",
    color: "#96CEB4",
    fields: ["url", "domain", "category"],
    svg: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="32" height="32" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
    <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"/>
    <path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"/>
  </svg>`
  },
  email: {
    name: "Email Address",
    icon: "mail",
    color: "#FECA57",
    fields: ["email", "domain"],
    svg: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="32" height="32" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
    <path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"/>
    <polyline points="22,6 12,13 2,6"/>
  </svg>`
  },
  // Hostname is the only IOC type with os_icons, triggering a secondary
  // OS selector sub-view in RenderIOCCardsModal before card creation.
  hostname: {
    name: "Hostname",
    icon: "monitor",
    color: "#9C27B0",
    fields: ["hostname", "os_type", "domain"],
    svg: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="32" height="32" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
    <rect x="2" y="3" width="20" height="14" rx="2" ry="2"/>
    <line x1="8" y1="21" x2="16" y2="21"/>
    <line x1="12" y1="17" x2="12" y2="21"/>
  </svg>`,
    os_icons: {
      windows_workstation: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="32" height="32" fill="currentColor">
    <path d="M0 3.5L10 2v9.5H0V3.5zM11 1.9l13-1.9v11H11V1.9zM0 12.5h10V22l-10-1.5v-8zM11 12h13v10l-13 2v-12z"/>
  </svg>`,
      windows_server: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="32" height="32" fill="currentColor">
    <path d="M0 3.5L10 2v9.5H0V3.5zM11 1.9l13-1.9v11H11V1.9zM0 12.5h10V22l-10-1.5v-8zM11 12h13v10l-13 2v-12z"/>
  </svg>`,
      macos: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="32" height="32" fill="currentColor">
    <path d="M17.05 20.28c-.98.95-2.05.8-3.08.35-1.09-.46-2.09-.48-3.24 0-1.44.62-2.2.44-3.06-.35C2.79 15.25 3.51 7.59 9.05 7.31c1.35.07 2.29.74 3.08.8 1.18-.24 2.31-.93 3.57-.84 1.51.12 2.65.72 3.4 1.8-3.12 1.87-2.38 5.98.48 7.13-.57 1.5-1.31 2.99-2.54 4.09l.01-.01zM12.03 7.25c-.15-2.23 1.66-4.07 3.74-4.25.29 2.58-2.34 4.5-3.74 4.25z"/>
  </svg>`,
      linux: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="32" height="32" fill="currentColor">
    <path d="M12.504 0c-.155 0-.315.008-.48.021-4.226.333-3.105 4.807-3.17 6.298-.076 1.092-.3 1.953-1.05 3.02-.885 1.051-2.127 2.75-2.716 4.521-.278.84-.41 1.684-.287 2.489.845 5.548 5.676 6.016 6.855 6.016.178 0 .287-.016.287-.016s8.029-.192 8.03-8.047c0-4.662-3.916-9.69-7.47-14.302z"/>
  </svg>`
    }
  },
  // --- Detection rule types ---
  yara_rule: {
    name: "YARA Rule",
    icon: "shield",
    color: "#FF9FF3",
    fields: ["rule_name", "rule_content"],
    svg: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="32" height="32" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
    <path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"/>
    <text x="12" y="15" font-size="10" text-anchor="middle" fill="currentColor" font-weight="bold">Y</text>
  </svg>`
  },
  sigma_rule: {
    name: "Sigma Rule",
    icon: "search",
    color: "#A8E6CF",
    fields: ["rule_name", "rule_content"],
    svg: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="32" height="32" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
    <circle cx="12" cy="12" r="10"/>
    <text x="12" y="17" font-size="14" text-anchor="middle" fill="currentColor" font-weight="bold">\u03A3</text>
  </svg>`
  },
  // --- Host-based IOC types ---
  registry_key: {
    name: "Registry Key",
    icon: "settings",
    color: "#FFB74D",
    fields: ["key_path", "key_name", "key_data"],
    svg: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="32" height="32" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
    <rect x="3" y="11" width="18" height="11" rx="2" ry="2"/>
    <path d="M7 11V7a5 5 0 0 1 9.9-1"/>
  </svg>`
  },
  process_name: {
    name: "Process Name",
    icon: "cpu",
    color: "#81C784",
    fields: ["process_name", "command_line", "pid", "parent_process"],
    svg: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="32" height="32" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
  <rect x="3" y="5" width="18" height="14" rx="2" ry="2"/>
  <line x1="3" y1="9" x2="21" y2="9"/>
  <circle cx="6" cy="7" r="0.8" fill="currentColor"/>
  <circle cx="9" cy="7" r="0.8" fill="currentColor"/>
  <line x1="7" y1="13" x2="17" y2="13"/>
  <line x1="7" y1="16" x2="14" y2="16"/>
</svg>`
  },
  network: {
    name: "Network",
    icon: "activity",
    color: "#9575CD",
    fields: ["protocol", "port", "direction"],
    svg: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="32" height="32" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
    <polyline points="22 12 18 12 15 21 9 3 6 12 2 12"/>
  </svg>`
  },
  command_line: {
    name: "Command Line",
    icon: "terminal",
    color: "#2E8B57",
    fields: ["command", "pid", "parent_process"],
    svg: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="32" height="32" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
    <polyline points="4 17 10 11 4 5"/>
    <line x1="12" y1="19" x2="20" y2="19"/>
  </svg>`
  },
  // --- File and artifact types ---
  file: {
    name: "File",
    icon: "file",
    color: "#E91E63",
    fields: ["name", "type", "path", "size", "hash", "pid"],
    svg: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="32" height="32" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
  <path d="M4 4h12l4 4v12a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2z"/>
  <line x1="8" y1="11" x2="16" y2="11"/>
  <line x1="8" y1="15" x2="16" y2="15"/>
</svg>`
  },
  // --- Utility types ---
  note: {
    name: "Note",
    icon: "note",
    color: "#F39C12",
    fields: ["NB"],
    svg: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="32" height="32" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
  <rect x="4" y="4" width="16" height="16" rx="2" ry="2"/>
  <line x1="8" y1="8" x2="16" y2="8"/>
  <line x1="8" y1="12" x2="16" y2="12"/>
  <line x1="8" y1="16" x2="14" y2="16"/>
</svg>`
  },
  dll: {
    name: "DLL",
    icon: "dll",
    color: "#3498DB",
    fields: ["name", "type", "path", "size", "hash"],
    svg: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="32" height="32" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
  <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8l-6-6z"/>
  <polyline points="14 2 14 8 20 8"/>
  <circle cx="12" cy="13" r="2"/>
  <path d="M12 10.5v-1"/>
  <path d="M12 15.5v1"/>
  <path d="M14.5 11.5l0.7-0.7"/>
  <path d="M9.8 16.2l-0.7 0.7"/>
  <path d="M15.5 13h1"/>
  <path d="M8.5 13h-1"/>
  <path d="M14.5 14.5l0.7 0.7"/>
  <path d="M9.8 9.8l-0.7-0.7"/>
</svg>`
  },
  // --- Threat infrastructure ---
  c2: {
    name: "C2",
    icon: "c2",
    color: "#E74C3C",
    fields: ["domain", "IP"],
    svg: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="32" height="32" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
  <circle cx="12" cy="12" r="9"/>
  <path d="M12 3v1.5"/>
  <path d="M12 19.5V21"/>
  <path d="M3 12h1.5"/>
  <path d="M19.5 12H21"/>
  <path d="M5.6 5.6l1.1 1.1"/>
  <path d="M17.3 17.3l1.1 1.1"/>
  <path d="M5.6 18.4l1.1-1.1"/>
  <path d="M17.3 6.7l1.1-1.1"/>
  <polyline points="8 10 11 13 8 16"/>
  <line x1="13" y1="16" x2="16" y2="16"/>
</svg>`
  }
};

// src/IOCParser.ts
var IOC_TYPE_PATTERNS = [
  { pattern: /IP Address/i, type: "IP Address" },
  { pattern: /Domain Name/i, type: "Domain Name" },
  { pattern: /File Hash/i, type: "File Hash" },
  { pattern: /URL/i, type: "URL" },
  { pattern: /Email Address/i, type: "Email Address" },
  { pattern: /Hostname/i, type: "Hostname" },
  { pattern: /YARA Rule/i, type: "YARA Rule" },
  { pattern: /Sigma Rule/i, type: "Sigma Rule" },
  { pattern: /Registry Key/i, type: "Registry Key" },
  { pattern: /Process Name/i, type: "Process Name" },
  // FIX: The IOC_TYPES constant uses "Network" (not "Network Traffic").
  // The old code used "Network Traffic" which would never match the
  // IOC_TYPES lookup, so color and icon were never resolved for this type.
  { pattern: /Network/i, type: "Network" },
  { pattern: /Command Line/i, type: "Command Line" },
  { pattern: /File/i, type: "File" },
  { pattern: /Note/i, type: "Note" },
  { pattern: /DLL/i, type: "DLL" },
  { pattern: /C2/i, type: "C2" }
];
function detectIOCType(text) {
  for (const { pattern, type } of IOC_TYPE_PATTERNS) {
    if (pattern.test(text)) {
      return type;
    }
  }
  return "";
}
function extractValue(text) {
  console.log("\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501");
  console.log("[IOCParser] extractValue - ===== STARTING VALUE EXTRACTION =====");
  console.log("[IOCParser] extractValue - Input text length:", text.length);
  console.log("[IOCParser] extractValue - Full input text:");
  console.log(text);
  console.log("[IOCParser] extractValue - First 400 chars:", text.substring(0, 400));
  console.log("\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501");
  console.log("[IOCParser] extractValue - Checking for legacy code block format...");
  const codeBlockMatch = text.match(/```([\s\S]*?)```/);
  if (codeBlockMatch && codeBlockMatch[1] && codeBlockMatch[1].trim()) {
    const value2 = codeBlockMatch[1].trim();
    console.log("[IOCParser] extractValue - \u2713 Found code block value:", value2);
    console.log("[IOCParser] extractValue - ===== EXTRACTION COMPLETE (code block) =====");
    return value2;
  }
  console.log("[IOCParser] extractValue - \u2717 No code block found, proceeding with field extraction");
  console.log('[IOCParser] extractValue - Splitting by HTML header tag "</div></div>"...');
  const parts = text.split("</div></div>");
  console.log("[IOCParser] extractValue - Split resulted in", parts.length, "parts");
  if (parts.length > 1) {
    console.log("[IOCParser] extractValue - Part 0 (header) length:", parts[0].length);
    console.log("[IOCParser] extractValue - Part 1 (content) length:", parts[1].length);
  }
  if (parts.length < 2) {
    console.log("[IOCParser] extractValue - \u2717 ERROR: No HTML header found!");
    console.log('[IOCParser] extractValue - This means "</div></div>" was not found in the card text');
    console.log("[IOCParser] extractValue - ===== EXTRACTION FAILED (no header) =====");
    return "";
  }
  console.log("[IOCParser] extractValue - \u2713 HTML header found, processing content...");
  let afterHeader = parts[1].trim();
  console.log("[IOCParser] extractValue - ===== CONTENT AFTER HEADER (FULL TEXT) =====");
  console.log('"""');
  console.log(afterHeader);
  console.log('"""');
  console.log("[IOCParser] extractValue - afterHeader length:", afterHeader.length);
  console.log("[IOCParser] extractValue - First 400 chars:", afterHeader.substring(0, 400));
  console.log("\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501");
  console.log("[IOCParser] extractValue - Searching for first field label (pattern: [text]:)...");
  const fieldMatch = afterHeader.match(/[^:\n]+:\s*/);
  if (!fieldMatch) {
    console.log("[IOCParser] extractValue - \u2717 ERROR: No field label found!");
    console.log("[IOCParser] extractValue - afterHeader starts with:", JSON.stringify(afterHeader.substring(0, 100)));
    console.log('[IOCParser] extractValue - Looking for pattern like "fieldname: \\n"');
    console.log("[IOCParser] extractValue - ===== EXTRACTION FAILED (no field label) =====");
    return "";
  }
  const firstFieldName = fieldMatch[0].trim();
  console.log("[IOCParser] extractValue - \u2713 Found FIRST field:", JSON.stringify(firstFieldName));
  console.log("[IOCParser] extractValue - Field match raw text:", JSON.stringify(fieldMatch[0]));
  console.log("[IOCParser] extractValue - Field match index:", fieldMatch.index, "length:", fieldMatch[0].length);
  console.log("[IOCParser] extractValue - This field will be used as the card VALUE");
  console.log("\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501");
  console.log("[IOCParser] extractValue - Extracting content after field label...");
  const afterFieldLabel = afterHeader.substring(fieldMatch.index + fieldMatch[0].length);
  console.log("[IOCParser] extractValue - ===== CONTENT AFTER FIELD LABEL (should contain value) =====");
  console.log('"""');
  console.log(afterFieldLabel);
  console.log('"""');
  console.log("[IOCParser] extractValue - afterFieldLabel length:", afterFieldLabel.length);
  console.log("[IOCParser] extractValue - First 300 chars:", afterFieldLabel.substring(0, 300));
  console.log("\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501");
  console.log("[IOCParser] extractValue - Searching for value delimiter (separator or next field)...");
  const separatorMatch = afterFieldLabel.match(/\n?-----/);
  const nextFieldMatch = afterFieldLabel.match(/\n([^:\n]+:\s*)/);
  let value;
  let delimiterIndex;
  let delimiterType;
  if (separatorMatch && separatorMatch.index !== void 0) {
    delimiterIndex = separatorMatch.index;
    delimiterType = "separator (-----)";
  }
  if (nextFieldMatch && nextFieldMatch.index !== void 0) {
    if (delimiterIndex === void 0 || nextFieldMatch.index < delimiterIndex) {
      delimiterIndex = nextFieldMatch.index;
      delimiterType = "next field";
    }
  }
  if (delimiterIndex === void 0) {
    console.log("[IOCParser] extractValue - WARNING: No delimiter found!");
    console.log("[IOCParser] extractValue - Searching for Time of Event as fallback...");
    const timeIndex = afterFieldLabel.indexOf("Time of Event:");
    if (timeIndex === -1) {
      value = afterFieldLabel;
      console.log("[IOCParser] extractValue - No Time of Event either, using all remaining content");
    } else {
      value = afterFieldLabel.substring(0, timeIndex);
      console.log("[IOCParser] extractValue - Extracted until Time of Event at index", timeIndex);
    }
  } else {
    value = afterFieldLabel.substring(0, delimiterIndex);
    console.log(`[IOCParser] extractValue - SUCCESS: Found ${delimiterType} at index`, delimiterIndex);
    console.log("[IOCParser] extractValue - Raw value (before trim):", JSON.stringify(value));
    console.log("[IOCParser] extractValue - Raw value length:", value.length);
  }
  console.log("[IOCParser] extractValue - Trimming whitespace from extracted value...");
  const trimmedValue = value.trim();
  console.log("[IOCParser] extractValue - ===== FINAL EXTRACTED VALUE =====");
  console.log("[IOCParser] extractValue - Value (trimmed):", JSON.stringify(trimmedValue));
  console.log("[IOCParser] extractValue - Value length:", trimmedValue.length);
  console.log("[IOCParser] extractValue - Value is empty?", trimmedValue.length === 0);
  if (trimmedValue.length === 0) {
    console.log("[IOCParser] extractValue - \u26A0\uFE0F  WARNING: Extracted value is EMPTY!");
    console.log("[IOCParser] extractValue - This means no content was found between field label and separator");
  } else {
    console.log("[IOCParser] extractValue - \u2713 SUCCESS: Value extracted successfully");
  }
  console.log("[IOCParser] extractValue - ===== EXTRACTION COMPLETE =====");
  console.log("\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501");
  return trimmedValue;
}
function extractTime(text) {
  const timePatterns = [
    /\*\*Time of Event:\*\*\s*(\d{4}-\d{2}-\d{2}\s\d{2}:\d{2}:\d{2})/i,
    /\*\*Time of Event:\*\*\s*(\d{4}-\d{2}-\d{2})/i,
    /Time of Event[:\s]*(\d{4}-\d{2}-\d{2}[T\s]\d{2}:\d{2}:\d{2})/i,
    /Time of Event[:\s]*(\d{4}-\d{2}-\d{2})/i,
    /Time[:\s]*(\d{4}-\d{2}-\d{2}[T\s]\d{2}:\d{2}:\d{2})/i,
    /(\d{4}-\d{2}-\d{2}[T\s]\d{2}:\d{2}:\d{2})/i
  ];
  for (const pattern of timePatterns) {
    const match = text.match(pattern);
    if (match && match[1]) {
      return match[1].trim();
    }
  }
  return "";
}
function extractSplunkQuery(text) {
  const match = text.match(/\*\*Splunk Query:\*\*[:\s]*([\s\S]*?)(?=\*\*|$)/i);
  if (match && match[1] && match[1].trim()) {
    return match[1].trim();
  }
  return "";
}
function extractTactic(text) {
  let match = text.match(/Mitre Tactic:\s*([^\n]+)/i);
  if (match && match[1] && match[1].trim()) {
    return match[1].trim();
  }
  match = text.match(/\*\*Mitre Tactic:\*\*\s*([^\n]+)/i) || text.match(/\*\*Mitre Tactic:\*\*[:\s]*([\s\S]*?)(?=\*\*|$)/i);
  if (match && match[1]) {
    return match[1].trim();
  }
  return "";
}
function extractTechnique(text) {
  let match = text.match(/Mitre Technique:\s*([^\n]+)/i);
  if (match && match[1] && match[1].trim()) {
    return match[1].trim();
  }
  match = text.match(/\*\*Mitre Technique:\*\*\s*([^\n]+)/i) || text.match(/\*\*Mitre Technique:\*\*[:\s]*([\s\S]*?)(?=\*\*|$)/i);
  if (match && match[1]) {
    return match[1].trim();
  }
  return "";
}
function lookupTypeVisuals(iocType, fallbackColor) {
  let icon = "";
  let color = fallbackColor;
  if (IOC_TYPES && typeof IOC_TYPES === "object") {
    for (const key of Object.keys(IOC_TYPES)) {
      if (IOC_TYPES[key].name === iocType) {
        icon = IOC_TYPES[key].svg;
        color = IOC_TYPES[key].color;
        break;
      }
    }
  }
  return { icon, color };
}
function parseIOCNode(node) {
  console.log("[IOCParser] parseIOCNode - Processing node ID:", node.id);
  if (!node.text) {
    console.log("[IOCParser] parseIOCNode - Node has no text, skipping");
    return null;
  }
  const text = node.text;
  console.log("[IOCParser] parseIOCNode - Node text length:", text.length);
  const iocType = detectIOCType(text);
  console.log("[IOCParser] parseIOCNode - Detected IOC type:", iocType || "NONE");
  if (!iocType) {
    console.log("[IOCParser] parseIOCNode - No IOC type detected, returning null");
    return null;
  }
  console.log("[IOCParser] parseIOCNode - Extracting fields for type:", iocType);
  console.log("[IOCParser] parseIOCNode - ===== VALUE EXTRACTION START =====");
  const value = extractValue(text);
  console.log("[IOCParser] parseIOCNode - ===== VALUE EXTRACTION END =====");
  console.log("[IOCParser] parseIOCNode - EXTRACTED VALUE:", value || "(empty/null)", "(length:", value ? value.length : 0, ")");
  const time = extractTime(text);
  const splunkQuery = extractSplunkQuery(text);
  const tactic = extractTactic(text);
  const technique = extractTechnique(text);
  console.log("[IOCParser] parseIOCNode - All extracted fields:");
  console.log("  - value:", value || "**EMPTY**");
  console.log("  - time:", time || "(empty)");
  console.log("  - splunkQuery:", splunkQuery || "(empty)");
  console.log("  - tactic:", tactic || "(empty)");
  console.log("  - technique:", technique || "(empty)");
  const fallbackColor = node.color || "#333";
  const { icon, color } = lookupTypeVisuals(iocType, fallbackColor);
  console.log("[IOCParser] parseIOCNode - Looked up visuals - color:", color, "icon length:", icon.length);
  const result = {
    id: node.id,
    type: iocType,
    value,
    time,
    splunkQuery,
    tactic,
    technique,
    icon,
    color
  };
  console.log("[IOCParser] parseIOCNode - ===== FINAL RESULT =====");
  console.log("[IOCParser] parseIOCNode - Returning node with value:", result.value || "**NO VALUE**");
  console.log("[IOCParser] parseIOCNode - Full result:", JSON.stringify(result, null, 2));
  console.log("[IOCParser] parseIOCNode - ===== END PARSING =====");
  return result;
}

// src/TimeTimelineProcessing.ts
var TimeTimelineProcessor = class {
  constructor(app, plugin, IOCCardsTypes) {
    this.app = app;
    this.plugin = plugin;
    this.IOCCardsTypes = IOCCardsTypes;
  }
  /**
   * Extract IOC data from all canvas text nodes for time-based timeline.
   *
   * Iterates over every node in the active canvas. Each node with a `text`
   * property is parsed via the shared IOCParser. Nodes that match a known
   * IOC type are included in the returned array.
   *
   * The caller (RenderTimelinesModal) sorts the result by time for display.
   *
   * DEBUG: Console logs show processing steps for troubleshooting.
   *
   * @returns Array of parsed IOC node data objects, unsorted
   */
  extractFixedIOCData() {
    console.log("\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550");
    console.log("[TimeProcessor] ===== STARTING TIME TIMELINE EXTRACTION =====");
    const activeLeaf = this.app.workspace.activeLeaf;
    if (!activeLeaf || !activeLeaf.view || activeLeaf.view.getViewType() !== "canvas") {
      console.log("[TimeProcessor] \u2717 No active canvas view found");
      console.log("[TimeProcessor] ===== EXTRACTION FAILED =====");
      return [];
    }
    const canvasView = activeLeaf.view;
    const canvas = canvasView.canvas;
    if (!canvas || !canvas.nodes) {
      console.log("[TimeProcessor] \u2717 No canvas or canvas.nodes found");
      console.log("[TimeProcessor] ===== EXTRACTION FAILED =====");
      return [];
    }
    const totalNodes = canvas.nodes.size || canvas.nodes.length || 0;
    console.log("[TimeProcessor] \u2713 Canvas found with", totalNodes, "total nodes");
    console.log("[TimeProcessor] Processing nodes...");
    const iocData = [];
    let processedCount = 0;
    let iocCount = 0;
    let emptyValueCount = 0;
    canvas.nodes.forEach((node) => {
      processedCount++;
      if (node.text) {
        console.log(`[TimeProcessor] \u2500\u2500\u2500\u2500\u2500 Node ${processedCount}/${totalNodes} \u2500\u2500\u2500\u2500\u2500`);
        console.log("[TimeProcessor] Node ID:", node.id);
        console.log("[TimeProcessor] Parsing node...");
        const parsedData = parseIOCNode(node);
        if (parsedData) {
          iocCount++;
          console.log("[TimeProcessor] \u2713 IOC detected:", parsedData.type);
          console.log("[TimeProcessor]   Value:", parsedData.value ? `"${parsedData.value}"` : "(EMPTY)");
          console.log("[TimeProcessor]   Time:", parsedData.time || "(no time)");
          if (!parsedData.value || !parsedData.value.trim()) {
            emptyValueCount++;
            console.log("[TimeProcessor]   \u26A0\uFE0F  WARNING: This IOC has an EMPTY value!");
          }
          iocData.push(parsedData);
        } else {
          console.log("[TimeProcessor] \u2717 Not an IOC node (no match)");
        }
      }
    });
    console.log("[TimeProcessor] \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500");
    console.log("[TimeProcessor] ===== EXTRACTION SUMMARY =====");
    console.log("[TimeProcessor] Total nodes processed:", processedCount);
    console.log("[TimeProcessor] IOC cards found:", iocCount);
    console.log("[TimeProcessor] IOCs with values:", iocCount - emptyValueCount);
    console.log("[TimeProcessor] IOCs with EMPTY values:", emptyValueCount);
    console.log("[TimeProcessor] Returning", iocData.length, "IOC data objects");
    console.log("[TimeProcessor] ===== EXTRACTION COMPLETE =====");
    console.log("\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550");
    return iocData;
  }
};

// src/RenderTimelinesModal.ts
var RenderTimelinesModal = class extends import_obsidian.Modal {
  constructor(app, plugin) {
    super(app);
    this.plugin = plugin;
    this.timeProcessor = new TimeTimelineProcessor(app, plugin, plugin.iocTypes);
  }
  onOpen() {
    const { contentEl } = this;
    this.modalEl.classList.add("timeline-modal-fullscreen");
    const headerContainer = contentEl.createDiv("timeline-modal-header");
    headerContainer.createEl("h2", { text: "\u{1F550} Time-Based IOC Timeline" });
    const contentArea = contentEl.createDiv("timeline-tab-content");
    this.renderEnhancedTimeTimeline(contentArea);
  }
  /**
   * Renders the chronological Time Timeline. Extracts IOC data from canvas
   * nodes via the time processor, sorts by event timestamp, and renders each
   * IOC as a colored card with a gradient connector to the next card.
   *
   * DEBUG: Console logs show timeline data for troubleshooting.
   */
  renderEnhancedTimeTimeline(container) {
    console.log("[TimeTimeline] renderEnhancedTimeTimeline - Starting render");
    const iocData = this.timeProcessor.extractFixedIOCData();
    console.log("[TimeTimeline] Extracted IOC data - count:", iocData.length);
    console.log("[TimeTimeline] IOC data sample:", iocData.slice(0, 3));
    if (iocData.length === 0) {
      console.log("[TimeTimeline] No IOC cards found, showing empty message");
      container.createEl("p", {
        text: "No IOC cards found in the current canvas. Create some IOC cards first to see the timeline.",
        cls: "timeline-empty-message"
      });
      return;
    }
    iocData.sort((a, b) => new Date(a.time).getTime() - new Date(b.time).getTime());
    console.log("[TimeTimeline] Sorted IOC data by time");
    const timelineContainer = container.createDiv("timeline-container");
    iocData.forEach((ioc, index) => {
      const timelineItem = timelineContainer.createDiv("timeline-item");
      timelineItem.style.setProperty("--ioc-color", ioc.color);
      timelineItem.style.setProperty("--ioc-color-30", `${ioc.color}30`);
      timelineItem.style.background = `linear-gradient(135deg, ${ioc.color}15 0%, ${ioc.color}05 100%)`;
      timelineItem.style.boxShadow = `0 4px 12px ${ioc.color}25`;
      timelineItem.style.borderColor = ioc.color;
      if (index < iocData.length - 1) {
        const connector = timelineItem.createDiv("timeline-connector");
        connector.style.background = `linear-gradient(180deg, ${ioc.color} 0%, ${iocData[index + 1].color} 100%)`;
      }
      const iconContainer = timelineItem.createDiv("timeline-icon");
      iconContainer.innerHTML = ioc.icon;
      iconContainer.style.background = `${ioc.color}20`;
      iconContainer.style.borderColor = ioc.color;
      const detailsContainer = timelineItem.createDiv("timeline-details");
      const titleEl = detailsContainer.createEl("h3", { text: ioc.type });
      titleEl.style.textShadow = `0 1px 3px ${ioc.color}40`;
      console.log("\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550");
      console.log("[TimeTimeline] ===== RENDERING IOC CARD =====");
      console.log("[TimeTimeline] IOC Type:", ioc.type);
      console.log("[TimeTimeline] IOC Value:", JSON.stringify(ioc.value));
      console.log("[TimeTimeline] Value is truthy?", !!ioc.value);
      console.log("[TimeTimeline] Value after trim:", ioc.value ? JSON.stringify(ioc.value.trim()) : "N/A");
      console.log("[TimeTimeline] Will display value?", !!(ioc.value && ioc.value.trim()));
      console.log("[TimeTimeline] IOC Time:", ioc.time);
      const timeEl = detailsContainer.createDiv("timeline-time");
      if (ioc.value && ioc.value.trim()) {
        timeEl.innerHTML = `\u{1F550} Time: ${ioc.time} - Value: ${ioc.value}`;
        console.log("[TimeTimeline] \u2713 DISPLAYING combined time+value:", timeEl.innerHTML);
      } else {
        timeEl.innerHTML = `\u{1F550} Time: ${ioc.time}`;
        console.log("[TimeTimeline] \u2717 NO VALUE - showing time only");
        console.log("[TimeTimeline] Reason: value is", ioc.value === void 0 ? "undefined" : ioc.value === null ? "null" : ioc.value === "" ? "empty string" : "falsy after trim");
      }
      console.log("\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550");
      if (ioc.splunkQuery && ioc.splunkQuery.trim()) {
        const splunkEl = detailsContainer.createDiv("timeline-splunk");
        splunkEl.innerHTML = `\u{1F50D} Splunk Query: ${ioc.splunkQuery}`;
      }
      if (ioc.tactic) {
        const tacticEl = detailsContainer.createDiv("timeline-tactic");
        tacticEl.innerHTML = `\u2694\uFE0F Tactic: ${ioc.tactic}`;
      }
      if (ioc.technique) {
        const techniqueEl = detailsContainer.createDiv("timeline-technique");
        techniqueEl.innerHTML = `\u{1F3AF} Technique: ${ioc.technique}`;
      }
      timelineItem.addEventListener("mouseover", () => {
        timelineItem.style.boxShadow = `0 8px 20px ${ioc.color}35`;
      });
      timelineItem.addEventListener("mouseout", () => {
        timelineItem.style.boxShadow = `0 4px 12px ${ioc.color}25`;
      });
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/RenderMitreModal.ts
var import_obsidian2 = require("obsidian");

// src/MitreData.ts
var MITRE_TACTICS = {
  "reconnaissance": {
    id: "reconnaissance",
    displayName: "Reconnaissance",
    shortName: "reconnaissance",
    tacticId: "TA0043",
    abbreviations: ["RE", "RECON"]
  },
  "resourcedevelopment": {
    id: "resourcedevelopment",
    displayName: "Resource Development",
    shortName: "resource-development",
    tacticId: "TA0042",
    abbreviations: ["RD", "RESDEV"]
  },
  "initialaccess": {
    id: "initialaccess",
    displayName: "Initial Access",
    shortName: "initial-access",
    tacticId: "TA0001",
    abbreviations: ["IA"]
  },
  "execution": {
    id: "execution",
    displayName: "Execution",
    shortName: "execution",
    tacticId: "TA0002",
    abbreviations: ["EX", "EXEC"]
  },
  "persistence": {
    id: "persistence",
    displayName: "Persistence",
    shortName: "persistence",
    tacticId: "TA0003",
    abbreviations: ["PE", "PERS"]
  },
  "privilegeescalation": {
    id: "privilegeescalation",
    displayName: "Privilege Escalation",
    shortName: "privilege-escalation",
    tacticId: "TA0004",
    abbreviations: ["PR", "PRIV"]
  },
  "defenseevasion": {
    id: "defenseevasion",
    displayName: "Defense Evasion",
    shortName: "defense-evasion",
    tacticId: "TA0005",
    abbreviations: ["DE", "DEF"]
  },
  "credentialaccess": {
    id: "credentialaccess",
    displayName: "Credential Access",
    shortName: "credential-access",
    tacticId: "TA0006",
    abbreviations: ["CA", "CRED"]
  },
  "discovery": {
    id: "discovery",
    displayName: "Discovery",
    shortName: "discovery",
    tacticId: "TA0007",
    abbreviations: ["DI", "DISC"]
  },
  "lateralmovement": {
    id: "lateralmovement",
    displayName: "Lateral Movement",
    shortName: "lateral-movement",
    tacticId: "TA0008",
    abbreviations: ["LA", "LAT"]
  },
  "collection": {
    id: "collection",
    displayName: "Collection",
    shortName: "collection",
    tacticId: "TA0009",
    abbreviations: ["CO", "COLL"]
  },
  "commandandcontrol": {
    id: "commandandcontrol",
    displayName: "Command and Control",
    shortName: "command-and-control",
    tacticId: "TA0011",
    abbreviations: ["CC", "C2"]
  },
  "exfiltration": {
    id: "exfiltration",
    displayName: "Exfiltration",
    shortName: "exfiltration",
    tacticId: "TA0010",
    abbreviations: ["EF", "EXFIL"]
  },
  "impact": {
    id: "impact",
    displayName: "Impact",
    shortName: "impact",
    tacticId: "TA0040",
    abbreviations: ["IM", "IMP"]
  }
};
var MITRE_TECHNIQUES = {
  "T1566": {
    id: "T1566",
    name: "Phishing",
    tactics: ["initialaccess"],
    subtechniques: ["T1566.001", "T1566.002", "T1566.003", "T1566.004"],
    description: "Adversaries may send phishing messages to gain access to victim systems."
  },
  "T1566.001": {
    id: "T1566.001",
    name: "Spearphishing Attachment",
    tactics: ["initialaccess"],
    description: "Adversaries may send spearphishing emails with a malicious attachment."
  },
  "T1566.002": {
    id: "T1566.002",
    name: "Spearphishing Link",
    tactics: ["initialaccess"],
    description: "Adversaries may send spearphishing emails with a malicious link."
  },
  "T1566.003": {
    id: "T1566.003",
    name: "Spearphishing via Service",
    tactics: ["initialaccess"],
    description: "Adversaries may send spearphishing messages via third-party services."
  },
  "T1566.004": {
    id: "T1566.004",
    name: "Spearphishing Voice",
    tactics: ["initialaccess"],
    description: "Adversaries may use voice communications to ultimately gain access."
  },
  "T1059": {
    id: "T1059",
    name: "Command and Scripting Interpreter",
    tactics: ["execution"],
    subtechniques: ["T1059.001", "T1059.003", "T1059.005", "T1059.007"],
    description: "Adversaries may abuse command and script interpreters to execute commands or scripts."
  },
  "T1059.001": {
    id: "T1059.001",
    name: "PowerShell",
    tactics: ["execution"],
    description: "Adversaries may abuse PowerShell commands and scripts for execution."
  },
  "T1059.003": {
    id: "T1059.003",
    name: "Windows Command Shell",
    tactics: ["execution"],
    description: "Adversaries may abuse cmd.exe to execute commands and payloads."
  },
  "T1059.005": {
    id: "T1059.005",
    name: "Visual Basic",
    tactics: ["execution"],
    description: "Adversaries may abuse Visual Basic (VB) for execution."
  },
  "T1059.007": {
    id: "T1059.007",
    name: "JavaScript",
    tactics: ["execution"],
    description: "Adversaries may abuse JavaScript for execution of malicious scripts."
  },
  "T1078": {
    id: "T1078",
    name: "Valid Accounts",
    tactics: ["persistence", "privilegeescalation", "defenseevasion", "initialaccess"],
    subtechniques: ["T1078.001", "T1078.002", "T1078.003", "T1078.004"],
    description: "Adversaries may obtain and abuse credentials of existing accounts."
  },
  "T1078.001": {
    id: "T1078.001",
    name: "Default Accounts",
    tactics: ["persistence", "privilegeescalation", "defenseevasion", "initialaccess"],
    description: "Adversaries may obtain and abuse credentials of a default account."
  },
  "T1078.002": {
    id: "T1078.002",
    name: "Domain Accounts",
    tactics: ["persistence", "privilegeescalation", "defenseevasion", "initialaccess"],
    description: "Adversaries may obtain and abuse credentials of domain accounts."
  },
  "T1078.003": {
    id: "T1078.003",
    name: "Local Accounts",
    tactics: ["persistence", "privilegeescalation", "defenseevasion", "initialaccess"],
    description: "Adversaries may obtain and abuse credentials of local accounts."
  },
  "T1078.004": {
    id: "T1078.004",
    name: "Cloud Accounts",
    tactics: ["persistence", "privilegeescalation", "defenseevasion", "initialaccess"],
    description: "Adversaries may obtain and abuse credentials of cloud accounts."
  },
  "T1547": {
    id: "T1547",
    name: "Boot or Logon Autostart Execution",
    tactics: ["persistence", "privilegeescalation"],
    subtechniques: ["T1547.001", "T1547.004", "T1547.009"],
    description: "Adversaries may configure system settings to automatically execute at boot or logon."
  },
  "T1547.001": {
    id: "T1547.001",
    name: "Registry Run Keys / Startup Folder",
    tactics: ["persistence", "privilegeescalation"],
    description: "Adversaries may achieve persistence by adding a program to a startup folder or registry run keys."
  },
  "T1547.004": {
    id: "T1547.004",
    name: "Winlogon Helper DLL",
    tactics: ["persistence", "privilegeescalation"],
    description: "Adversaries may abuse Winlogon helper DLLs to establish persistence and elevate privileges."
  },
  "T1053": {
    id: "T1053",
    name: "Scheduled Task/Job",
    tactics: ["execution", "persistence", "privilegeescalation"],
    subtechniques: ["T1053.002", "T1053.005"],
    description: "Adversaries may abuse task scheduling functionality to execute code."
  },
  "T1053.002": {
    id: "T1053.002",
    name: "At",
    tactics: ["execution", "persistence", "privilegeescalation"],
    description: "Adversaries may abuse the at utility to perform task scheduling for initial execution."
  },
  "T1053.005": {
    id: "T1053.005",
    name: "Scheduled Task",
    tactics: ["execution", "persistence", "privilegeescalation"],
    description: "Adversaries may abuse Windows Task Scheduler to perform task scheduling."
  },
  "T1055": {
    id: "T1055",
    name: "Process Injection",
    tactics: ["defenseevasion", "privilegeescalation"],
    subtechniques: ["T1055.001", "T1055.002", "T1055.012"],
    description: "Adversaries may inject code into processes to evade defenses and elevate privileges."
  },
  "T1055.001": {
    id: "T1055.001",
    name: "Dynamic-link Library Injection",
    tactics: ["defenseevasion", "privilegeescalation"],
    description: "Adversaries may inject DLLs into processes to execute malicious payloads."
  },
  "T1055.002": {
    id: "T1055.002",
    name: "Portable Executable Injection",
    tactics: ["defenseevasion", "privilegeescalation"],
    description: "Adversaries may inject PE files into processes to execute malicious code."
  },
  "T1055.012": {
    id: "T1055.012",
    name: "Process Hollowing",
    tactics: ["defenseevasion", "privilegeescalation"],
    description: "Adversaries may inject code into suspended and hollowed processes."
  },
  "T1027": {
    id: "T1027",
    name: "Obfuscated Files or Information",
    tactics: ["defenseevasion"],
    subtechniques: ["T1027.002", "T1027.010"],
    description: "Adversaries may obfuscate files or information to evade detection."
  },
  "T1027.002": {
    id: "T1027.002",
    name: "Software Packing",
    tactics: ["defenseevasion"],
    description: "Adversaries may pack malicious code to evade static analysis."
  },
  "T1027.010": {
    id: "T1027.010",
    name: "Command Obfuscation",
    tactics: ["defenseevasion"],
    description: "Adversaries may obfuscate commands to make detection more difficult."
  },
  "T1003": {
    id: "T1003",
    name: "OS Credential Dumping",
    tactics: ["credentialaccess"],
    subtechniques: ["T1003.001", "T1003.002", "T1003.003"],
    description: "Adversaries may attempt to dump credentials to obtain account login information."
  },
  "T1003.001": {
    id: "T1003.001",
    name: "LSASS Memory",
    tactics: ["credentialaccess"],
    description: "Adversaries may attempt to access credential material stored in LSASS memory."
  },
  "T1003.002": {
    id: "T1003.002",
    name: "Security Account Manager",
    tactics: ["credentialaccess"],
    description: "Adversaries may attempt to extract credential material from the SAM database."
  },
  "T1003.003": {
    id: "T1003.003",
    name: "NTDS",
    tactics: ["credentialaccess"],
    description: "Adversaries may attempt to access NTDS.dit to retrieve password hashes."
  },
  "T1082": {
    id: "T1082",
    name: "System Information Discovery",
    tactics: ["discovery"],
    description: "An adversary may attempt to get detailed information about the operating system and hardware."
  },
  "T1083": {
    id: "T1083",
    name: "File and Directory Discovery",
    tactics: ["discovery"],
    description: "Adversaries may enumerate files and directories to find information."
  },
  "T1057": {
    id: "T1057",
    name: "Process Discovery",
    tactics: ["discovery"],
    description: "Adversaries may attempt to get information about running processes on a system."
  },
  "T1087": {
    id: "T1087",
    name: "Account Discovery",
    tactics: ["discovery"],
    subtechniques: ["T1087.001", "T1087.002"],
    description: "Adversaries may attempt to get a listing of accounts on a system or domain."
  },
  "T1087.001": {
    id: "T1087.001",
    name: "Local Account",
    tactics: ["discovery"],
    description: "Adversaries may attempt to get a listing of local system accounts."
  },
  "T1087.002": {
    id: "T1087.002",
    name: "Domain Account",
    tactics: ["discovery"],
    description: "Adversaries may attempt to get a listing of domain accounts."
  },
  "T1021": {
    id: "T1021",
    name: "Remote Services",
    tactics: ["lateralmovement"],
    subtechniques: ["T1021.001", "T1021.002", "T1021.006"],
    description: "Adversaries may use valid accounts to log into remote services."
  },
  "T1021.001": {
    id: "T1021.001",
    name: "Remote Desktop Protocol",
    tactics: ["lateralmovement"],
    description: "Adversaries may use RDP to log into a system."
  },
  "T1021.002": {
    id: "T1021.002",
    name: "SMB/Windows Admin Shares",
    tactics: ["lateralmovement"],
    description: "Adversaries may use SMB shares to laterally move to a remote system."
  },
  "T1021.006": {
    id: "T1021.006",
    name: "Windows Remote Management",
    tactics: ["lateralmovement"],
    description: "Adversaries may use WinRM to execute commands on remote systems."
  },
  "T1048": {
    id: "T1048",
    name: "Exfiltration Over Alternative Protocol",
    tactics: ["exfiltration"],
    subtechniques: ["T1048.003"],
    description: "Adversaries may steal data by exfiltrating it over a different protocol than the command channel."
  },
  "T1048.003": {
    id: "T1048.003",
    name: "Exfiltration Over Unencrypted Non-C2 Protocol",
    tactics: ["exfiltration"],
    description: "Adversaries may steal data by exfiltrating it over an unencrypted protocol."
  },
  "T1486": {
    id: "T1486",
    name: "Data Encrypted for Impact",
    tactics: ["impact"],
    description: "Adversaries may encrypt data on target systems to interrupt availability."
  },
  "T1489": {
    id: "T1489",
    name: "Service Stop",
    tactics: ["impact"],
    description: "Adversaries may stop or disable services on a system to render components unavailable."
  },
  "T1071": {
    id: "T1071",
    name: "Application Layer Protocol",
    tactics: ["commandandcontrol"],
    subtechniques: ["T1071.001", "T1071.004"],
    description: "Adversaries may communicate using OSI application layer protocols."
  },
  "T1071.001": {
    id: "T1071.001",
    name: "Web Protocols",
    tactics: ["commandandcontrol"],
    description: "Adversaries may communicate using HTTP/HTTPS protocols."
  },
  "T1071.004": {
    id: "T1071.004",
    name: "DNS",
    tactics: ["commandandcontrol"],
    description: "Adversaries may communicate using DNS application layer protocol."
  },
  "T1105": {
    id: "T1105",
    name: "Ingress Tool Transfer",
    tactics: ["commandandcontrol"],
    description: "Adversaries may transfer tools or files from an external system."
  }
};
function getTechniqueInfo(techniqueId) {
  return MITRE_TECHNIQUES[techniqueId] || null;
}

// src/MitreLoader.ts
var cachedDataset = null;
async function loadMitreDataset(app) {
  if (cachedDataset) {
    console.debug("[MitreLoader] Returning cached dataset");
    return cachedDataset;
  }
  try {
    const adapter = app.vault.adapter;
    const jsonPath = ".obsidian/plugins/cyber_canvas/MITRE/enterprise-attack.json";
    console.debug("[MitreLoader] Attempting to load from:", jsonPath);
    if (await adapter.exists(jsonPath)) {
      const content = await adapter.read(jsonPath);
      cachedDataset = JSON.parse(content);
      console.log("[MitreLoader] \u2713 Loaded full dataset from JSON. Version:", cachedDataset.version, "Techniques:", Object.keys(cachedDataset.techniques).length);
      return cachedDataset;
    } else {
      console.warn("[MitreLoader] JSON file not found at:", jsonPath);
    }
  } catch (err) {
    console.warn("[MitreLoader] Failed to load JSON:", err);
  }
  console.log("[MitreLoader] Using embedded fallback data");
  cachedDataset = convertEmbeddedToDataset(MITRE_TACTICS, MITRE_TECHNIQUES);
  console.log("[MitreLoader] \u2713 Embedded data loaded. Techniques:", Object.keys(cachedDataset.techniques).length);
  return cachedDataset;
}
function convertEmbeddedToDataset(oldTactics, oldTechniques) {
  console.debug("[MitreLoader] Converting embedded data to dataset format");
  const tactics = {};
  const techniques = {};
  Object.values(oldTactics).forEach((tactic) => {
    tactics[tactic.tacticId] = {
      id: tactic.tacticId,
      name: tactic.displayName,
      short_name: tactic.shortName,
      description: `The adversary is trying to ${tactic.displayName.toLowerCase()}.`,
      abbreviations: tactic.abbreviations || []
    };
  });
  Object.values(oldTechniques).forEach((technique) => {
    const tacticIds = technique.tactics.map((normalizedId) => {
      const tactic = oldTactics[normalizedId];
      return tactic ? tactic.tacticId : normalizedId;
    });
    techniques[technique.id] = {
      id: technique.id,
      name: technique.name,
      description: technique.description || `Technique: ${technique.name}`,
      tactics: tacticIds,
      url: `https://attack.mitre.org/techniques/${technique.id.replace(".", "/")}`
    };
  });
  return {
    version: "embedded",
    last_updated: new Date().toISOString().split("T")[0],
    tactics,
    techniques
  };
}
function normalizeTacticName(name, dataset) {
  const normalized = name.toLowerCase().replace(/[\s\-_]+/g, "");
  console.debug("[MitreLoader] Normalizing tactic:", name, "\u2192", normalized);
  for (const [tacticId, tactic] of Object.entries(dataset.tactics)) {
    if (tactic.short_name.replace(/\-/g, "") === normalized) {
      console.debug("[MitreLoader] \u2713 Matched by short_name:", tactic.name, "(" + tacticId + ")");
      return tacticId;
    }
  }
  for (const [tacticId, tactic] of Object.entries(dataset.tactics)) {
    if (tactic.name.toLowerCase().replace(/[\s\-_]+/g, "") === normalized) {
      console.debug("[MitreLoader] \u2713 Matched by full name:", tactic.name, "(" + tacticId + ")");
      return tacticId;
    }
  }
  const upper = name.toUpperCase().trim();
  for (const [tacticId, tactic] of Object.entries(dataset.tactics)) {
    if (tactic.abbreviations.includes(upper)) {
      console.debug("[MitreLoader] \u2713 Matched by abbreviation:", upper, "\u2192", tactic.name, "(" + tacticId + ")");
      return tacticId;
    }
  }
  console.debug("[MitreLoader] \u2717 No match found for:", name);
  return null;
}
function validateTechniqueTactic(techniqueId, tacticInput, dataset) {
  const tacticId = normalizeTacticName(tacticInput, dataset);
  if (!tacticId) {
    return {
      severity: "unknown_tactic",
      message: `Unknown tactic: "${tacticInput}"`
    };
  }
  const technique = dataset.techniques[techniqueId];
  if (!technique) {
    return {
      severity: "unknown_technique",
      message: `Unknown technique: "${techniqueId}"`
    };
  }
  if (!technique.tactics.includes(tacticId)) {
    const validTactics = technique.tactics.map((tid) => {
      var _a;
      return ((_a = dataset.tactics[tid]) == null ? void 0 : _a.name) || tid;
    }).join(", ");
    return {
      severity: "mismatch",
      message: `${techniqueId} (${technique.name}) does not belong to ${dataset.tactics[tacticId].name}. Valid tactics: ${validTactics}`,
      tacticId
    };
  }
  return {
    severity: "valid",
    tacticId
  };
}

// src/RenderMitreModal.ts
var RenderMitreModal = class extends import_obsidian2.Modal {
  constructor(app, plugin) {
    super(app);
    this.mitreDataset = null;
    this.subtechniquesMap = /* @__PURE__ */ new Map();
    this.plugin = plugin;
    this.timeProcessor = new TimeTimelineProcessor(app, plugin, IOC_TYPES);
    this.loadDataset();
  }
  /**
   * Clean MITRE description text by removing markdown links and square brackets.
   *
   * @param description - Raw description from MITRE dataset
   * @returns Cleaned description text
   */
  cleanDescription(description) {
    if (!description)
      return "";
    let cleaned = description;
    cleaned = cleaned.replace(/\[([^\]]+)\]\([^)]+\)/g, "");
    cleaned = cleaned.replace(/\[[^\]]*\]/g, "");
    cleaned = cleaned.replace(/\s+/g, " ").trim();
    return cleaned;
  }
  /**
   * Truncate description to maximum character length with ellipsis.
   *
   * @param description - Cleaned description text
   * @param maxChars - Maximum characters (default: 180)
   * @returns Truncated description with "..." if needed
   */
  truncateDescription(description, maxChars = 180) {
    if (!description || description.length <= maxChars) {
      return description;
    }
    const truncated = description.substring(0, maxChars);
    const lastSpace = truncated.lastIndexOf(" ");
    if (lastSpace > 0) {
      return truncated.substring(0, lastSpace) + "...";
    }
    return truncated + "...";
  }
  /**
   * Load MITRE dataset asynchronously
   */
  async loadDataset() {
    try {
      this.mitreDataset = await loadMitreDataset(this.app);
      console.debug("[MitreModal] Dataset loaded:", this.mitreDataset.version, "- Techniques:", Object.keys(this.mitreDataset.techniques).length);
    } catch (err) {
      console.error("[MitreModal] Failed to load dataset:", err);
    }
  }
  onOpen() {
    console.debug("[MitreModal] ===== MODAL OPENED =====");
    const { contentEl } = this;
    this.modalEl.classList.add("mitre-modal-fullscreen");
    this.makeResizable();
    const headerContainer = contentEl.createDiv("mitre-modal-header");
    const titleRow = headerContainer.createDiv("mitre-title-row");
    titleRow.createEl("h2", { text: "\u{1F3AF} MITRE ATT&CK Technique Mapper" });
    const exportBtn = titleRow.createEl("button", {
      text: "Export to Navigator",
      cls: "mitre-export-button"
    });
    exportBtn.addEventListener("click", () => this.exportToNavigator());
    const statsContainer = contentEl.createDiv("mitre-stats");
    const contentArea = contentEl.createDiv("mitre-content-area");
    this.renderMitreMapping(contentArea, statsContainer);
  }
  async renderMitreMapping(container, statsContainer) {
    console.debug("[MitreModal] ===== STARTING DATA EXTRACTION =====");
    const iocData = this.timeProcessor.extractFixedIOCData();
    console.debug("[MitreModal] Extracted IOC count:", iocData.length);
    if (iocData.length === 0) {
      container.createEl("p", {
        text: "No IOC cards found in the current canvas.",
        cls: "mitre-empty-message"
      });
      return;
    }
    const tactics = await this.aggregateTacticsTechniques(iocData);
    console.debug("[MitreModal] ===== AGGREGATION COMPLETE =====");
    console.debug("[MitreModal] Tactics:", tactics.length);
    if (tactics.length === 0) {
      container.createEl("p", {
        text: 'No MITRE tactics or techniques found in IOC cards. Add "Mitre Tactic" and "Mitre Technique" fields to your cards.',
        cls: "mitre-empty-message"
      });
      return;
    }
    const totalTechniques = tactics.reduce((sum, t) => sum + t.techniques.length, 0);
    const foundTechniques = tactics.reduce((sum, t) => sum + t.techniques.filter((tech) => tech.isFound).length, 0);
    const coveragePercent = totalTechniques > 0 ? Math.round(foundTechniques / totalTechniques * 100) : 0;
    statsContainer.createEl("div", {
      text: `\u{1F4CA} Coverage: ${foundTechniques}/${totalTechniques} techniques (${coveragePercent}%)`,
      cls: "mitre-stat-item"
    });
    const activeTactics = tactics.filter((t) => t.techniques.some((tech) => tech.isFound)).length;
    statsContainer.createEl("div", {
      text: `\u2694\uFE0F Tactics: ${activeTactics}/${tactics.length} active`,
      cls: "mitre-stat-item"
    });
    statsContainer.createEl("div", {
      text: `\u{1F4C7} IOC Cards: ${iocData.length} total`,
      cls: "mitre-stat-item"
    });
    tactics.forEach((tactic) => {
      this.renderTacticSection(container, tactic);
    });
  }
  async aggregateTacticsTechniques(iocData) {
    if (!this.mitreDataset) {
      await this.loadDataset();
      if (!this.mitreDataset) {
        console.error("[MitreModal] Failed to load dataset");
        return [];
      }
    }
    console.log("[MitreModal] Starting full matrix aggregation with", iocData.length, "IOC cards");
    console.log("[MitreModal] Dataset has", Object.keys(this.mitreDataset.techniques).length, "techniques");
    const foundTechniques = /* @__PURE__ */ new Map();
    iocData.forEach((ioc) => {
      if (!ioc.tactic || !ioc.technique) {
        return;
      }
      const tactic = ioc.tactic.trim();
      const technique = ioc.technique.trim();
      if (!tactic || !technique)
        return;
      const techniqueId = this.extractTechniqueId(technique);
      const techniqueName = this.extractTechniqueName(technique);
      const validation = validateTechniqueTactic(techniqueId, tactic, this.mitreDataset);
      console.debug("[MitreModal] Found technique:", {
        techniqueId,
        tactic,
        severity: validation.severity
      });
      if (foundTechniques.has(techniqueId)) {
        const existing = foundTechniques.get(techniqueId);
        existing.count++;
        existing.iocCards.push(ioc.id);
        if (validation.severity === "unknown_technique" || validation.severity === "unknown_tactic" || validation.severity === "mismatch" && existing.severity === "valid") {
          existing.severity = validation.severity;
          existing.validationMessage = validation.message;
        }
      } else {
        foundTechniques.set(techniqueId, {
          count: 1,
          iocCards: [ioc.id],
          severity: validation.severity,
          validationMessage: validation.message,
          userProvidedTactic: tactic
        });
      }
    });
    console.log("[MitreModal] Found", foundTechniques.size, "unique techniques in IOC cards");
    const tacticMap = /* @__PURE__ */ new Map();
    Object.values(this.mitreDataset.tactics).forEach((tacticData) => {
      tacticMap.set(tacticData.id, {
        name: tacticData.id,
        displayName: `${tacticData.name} (${tacticData.id})`,
        techniques: []
      });
    });
    this.subtechniquesMap.clear();
    Object.values(this.mitreDataset.techniques).forEach((techData) => {
      const foundData = foundTechniques.get(techData.id);
      const isFound = !!foundData;
      const techniqueObj = {
        id: techData.id,
        name: techData.name,
        tactic: "",
        // Will be set per-tactic below
        tacticId: "",
        // Will be set per-tactic below
        count: (foundData == null ? void 0 : foundData.count) || 0,
        iocCards: (foundData == null ? void 0 : foundData.iocCards) || [],
        severity: (foundData == null ? void 0 : foundData.severity) || "not_found",
        validationMessage: foundData == null ? void 0 : foundData.validationMessage,
        description: techData.description,
        isFound
      };
      if (techData.parent) {
        if (!this.subtechniquesMap.has(techData.parent)) {
          this.subtechniquesMap.set(techData.parent, []);
        }
        if (techData.tactics.length > 0) {
          techniqueObj.tactic = (foundData == null ? void 0 : foundData.userProvidedTactic) || techData.tactics[0];
          techniqueObj.tacticId = techData.tactics[0];
        }
        this.subtechniquesMap.get(techData.parent).push(techniqueObj);
        return;
      }
      techData.tactics.forEach((tacticId) => {
        if (!tacticMap.has(tacticId)) {
          console.warn("[MitreModal] Unknown tactic ID in dataset:", tacticId);
          return;
        }
        const tactic = tacticMap.get(tacticId);
        tactic.techniques.push({
          ...techniqueObj,
          tactic: (foundData == null ? void 0 : foundData.userProvidedTactic) || tacticId,
          tacticId
        });
      });
    });
    const tactics = Array.from(tacticMap.values());
    const tacticOrder = [
      "TA0043",
      // Reconnaissance
      "TA0042",
      // Resource Development
      "TA0001",
      // Initial Access
      "TA0002",
      // Execution
      "TA0003",
      // Persistence
      "TA0004",
      // Privilege Escalation
      "TA0005",
      // Defense Evasion
      "TA0006",
      // Credential Access
      "TA0007",
      // Discovery
      "TA0008",
      // Lateral Movement
      "TA0009",
      // Collection
      "TA0011",
      // Command and Control
      "TA0010",
      // Exfiltration
      "TA0040"
      // Impact
    ];
    tactics.sort((a, b) => {
      const indexA = tacticOrder.indexOf(a.name);
      const indexB = tacticOrder.indexOf(b.name);
      if (indexA === -1)
        return 1;
      if (indexB === -1)
        return -1;
      return indexA - indexB;
    });
    tactics.forEach((tactic) => {
      tactic.techniques.sort((a, b) => {
        if (a.isFound && !b.isFound)
          return -1;
        if (!a.isFound && b.isFound)
          return 1;
        return a.id.localeCompare(b.id);
      });
    });
    console.log("[MitreModal] Full matrix built:", {
      totalTactics: tactics.length,
      totalTechniques: tactics.reduce((sum, t) => sum + t.techniques.length, 0),
      foundTechniques: foundTechniques.size
    });
    return tactics;
  }
  /**
   * Extract technique ID from various formats.
   *
   * Supported formats:
   * - "T1566" -> "T1566"
   * - "T1566.001" -> "T1566.001"
   * - "T1566 - Phishing" -> "T1566"
   * - "Phishing (T1566)" -> "T1566"
   * - "T1566.001 - Spearphishing Attachment" -> "T1566.001"
   * - "Phishing" (name only) -> "Phishing" (fallback, will fail validation)
   */
  extractTechniqueId(technique) {
    const idMatch = technique.match(/T\d{4}(?:\.\d{3})?/);
    if (idMatch) {
      console.debug("[MitreModal] Extracted technique ID:", idMatch[0], "from:", technique);
      return idMatch[0];
    }
    console.debug("[MitreModal] No technique ID found in:", technique, "- using raw string");
    return technique.trim();
  }
  /**
   * Extract technique name from various formats.
   *
   * Supported formats:
   * - "T1566 - Phishing" -> "Phishing"
   * - "Phishing (T1566)" -> "Phishing"
   * - "T1566.001 - Spearphishing Attachment" -> "Spearphishing Attachment"
   * - "T1566" (ID only) -> lookup name from MitreData
   * - "Phishing" (name only) -> "Phishing"
   */
  extractTechniqueName(technique) {
    const dashMatch = technique.match(/T\d{4}(?:\.\d{3})?\s*-\s*(.+)/);
    if (dashMatch) {
      const name = dashMatch[1].trim();
      console.debug("[MitreModal] Extracted name from dash format:", name);
      return name;
    }
    const parenMatch = technique.match(/(.+?)\s*\(T\d{4}(?:\.\d{3})?\)/);
    if (parenMatch) {
      const name = parenMatch[1].trim();
      console.debug("[MitreModal] Extracted name from paren format:", name);
      return name;
    }
    const idOnlyMatch = technique.match(/^T\d{4}(?:\.\d{3})?$/);
    if (idOnlyMatch) {
      const info = getTechniqueInfo(idOnlyMatch[0]);
      if (info) {
        console.debug("[MitreModal] Looked up name for ID:", idOnlyMatch[0], "->", info.name);
        return info.name;
      }
    }
    console.debug("[MitreModal] Using raw technique string as name:", technique);
    return technique.trim();
  }
  renderTacticSection(container, tactic) {
    const tacticColumn = container.createDiv("mitre-tactic-column");
    const foundCount = tactic.techniques.filter((t) => t.isFound).length;
    const totalCount = tactic.techniques.length;
    const tacticHeader = tacticColumn.createDiv("mitre-tactic-header");
    tacticHeader.createEl("h3", { text: `\u2694\uFE0F ${tactic.displayName || tactic.name}` });
    tacticHeader.createEl("span", {
      text: `${foundCount}/${totalCount} techniques covered`,
      cls: "mitre-technique-count"
    });
    const techniqueList = tacticColumn.createDiv("mitre-technique-list");
    tactic.techniques.forEach((technique) => {
      const techItem = techniqueList.createDiv("mitre-technique-item");
      const subtechniques = this.subtechniquesMap.get(technique.id) || [];
      const hasSubtechniques = subtechniques.length > 0;
      if (!technique.isFound) {
        techItem.addClass("mitre-technique-unfound");
      } else {
        if (technique.severity === "unknown_technique" || technique.severity === "unknown_tactic") {
          techItem.addClass("mitre-technique-error");
        } else if (technique.severity === "mismatch") {
          techItem.addClass("mitre-technique-warning");
        }
      }
      const techInfo = techItem.createDiv("mitre-technique-info");
      if (hasSubtechniques) {
        const expandIcon = techInfo.createEl("span", {
          cls: "mitre-expand-icon",
          text: "\u25B6"
        });
        techItem.addClass("has-subtechniques");
        techItem.addClass("collapsed");
        techItem.addEventListener("click", (e) => {
          var _a;
          e.stopPropagation();
          const isCollapsed = techItem.hasClass("collapsed");
          const descEl = techItem.querySelector(".mitre-technique-description");
          if (isCollapsed) {
            techItem.removeClass("collapsed");
            techItem.addClass("expanded");
            expandIcon.setText("\u25BC");
            this.renderSubtechniques(techItem, subtechniques);
            if (descEl) {
              const fullDesc = descEl.getAttribute("data-full-description");
              if (fullDesc) {
                descEl.textContent = fullDesc;
              }
            }
          } else {
            techItem.removeClass("expanded");
            techItem.addClass("collapsed");
            expandIcon.setText("\u25B6");
            (_a = techItem.querySelector(".mitre-subtechniques-container")) == null ? void 0 : _a.remove();
            if (descEl) {
              const fullDesc = descEl.getAttribute("data-full-description");
              if (fullDesc) {
                descEl.textContent = this.truncateDescription(fullDesc);
              }
            }
          }
        });
      }
      if (technique.isFound && technique.severity !== "valid" && technique.severity !== "not_found") {
        const icon = technique.severity === "unknown_technique" || technique.severity === "unknown_tactic" ? "\u{1F534}" : "\u26A0\uFE0F";
        const warningEl = techInfo.createEl("span", {
          cls: "mitre-validation-icon",
          attr: {
            "aria-label": technique.validationMessage || "Warning",
            "title": technique.validationMessage || "Warning"
          }
        });
        warningEl.innerHTML = icon;
      }
      techInfo.createEl("span", {
        text: technique.id,
        cls: "mitre-technique-id"
      });
      techInfo.createEl("span", {
        text: technique.name,
        cls: "mitre-technique-name"
      });
      if (technique.description) {
        const descEl = techItem.createDiv("mitre-technique-description");
        const cleanedDesc = this.cleanDescription(technique.description);
        descEl.setAttribute("data-full-description", cleanedDesc);
        const isExpanded = techItem.hasClass("expanded");
        if (isExpanded || !hasSubtechniques) {
          descEl.textContent = cleanedDesc;
        } else {
          descEl.textContent = this.truncateDescription(cleanedDesc);
        }
      }
      if (technique.isFound) {
        const techCount = techItem.createDiv("mitre-technique-count-badge");
        techCount.textContent = `${technique.count} card${technique.count > 1 ? "s" : ""}`;
      }
    });
  }
  renderSubtechniques(parentEl, subtechniques) {
    const container = parentEl.createDiv({ cls: "mitre-subtechniques-container" });
    subtechniques.forEach((subtech) => {
      const subItem = container.createDiv("mitre-technique-item mitre-subtechnique");
      if (!subtech.isFound) {
        subItem.addClass("mitre-technique-unfound");
      } else {
        if (subtech.severity === "unknown_technique" || subtech.severity === "unknown_tactic") {
          subItem.addClass("mitre-technique-error");
        } else if (subtech.severity === "mismatch") {
          subItem.addClass("mitre-technique-warning");
        }
      }
      const subInfo = subItem.createDiv("mitre-technique-info");
      if (subtech.isFound && subtech.severity !== "valid" && subtech.severity !== "not_found") {
        const icon = subtech.severity === "unknown_technique" || subtech.severity === "unknown_tactic" ? "\u{1F534}" : "\u26A0\uFE0F";
        const warningEl = subInfo.createEl("span", {
          cls: "mitre-validation-icon",
          attr: {
            "aria-label": subtech.validationMessage || "Warning",
            "title": subtech.validationMessage || "Warning"
          }
        });
        warningEl.innerHTML = icon;
      }
      subInfo.createEl("span", {
        text: subtech.id,
        cls: "mitre-technique-id"
      });
      subInfo.createEl("span", {
        text: subtech.name,
        cls: "mitre-technique-name"
      });
      if (subtech.description) {
        const descEl = subItem.createDiv("mitre-technique-description");
        const cleanedDesc = this.cleanDescription(subtech.description);
        descEl.textContent = cleanedDesc;
      }
      if (subtech.isFound) {
        const subCount = subItem.createDiv("mitre-technique-count-badge");
        subCount.textContent = `${subtech.count} card${subtech.count > 1 ? "s" : ""}`;
      }
    });
  }
  async exportToNavigator() {
    console.debug("[MitreModal] ===== EXPORTING =====");
    const iocData = this.timeProcessor.extractFixedIOCData();
    const tactics = await this.aggregateTacticsTechniques(iocData);
    const layer = {
      name: "Cyber Canvas IOC Analysis",
      versions: {
        attack: "14",
        navigator: "4.9.4",
        layer: "4.5"
      },
      domain: "enterprise-attack",
      description: `Generated from ${iocData.length} IOC cards in Obsidian Canvas`,
      filters: {
        platforms: ["windows", "linux", "macos"]
      },
      sorting: 0,
      layout: {
        layout: "side",
        aggregateFunction: "average",
        showID: true,
        showName: true,
        showAggregateScores: false,
        countUnscored: false
      },
      hideDisabled: false,
      techniques: [],
      gradient: {
        colors: ["#ff6666", "#ffe766", "#8ec843"],
        minValue: 0,
        maxValue: 100
      },
      legendItems: [],
      metadata: [],
      links: [],
      showTacticRowBackground: true,
      tacticRowBackground: "#dddddd",
      selectTechniquesAcrossTactics: true,
      selectSubtechniquesWithParent: false
    };
    tactics.forEach((tactic) => {
      tactic.techniques.forEach((technique) => {
        var _a;
        if (!technique.isFound) {
          return;
        }
        const tacticData = (_a = this.mitreDataset) == null ? void 0 : _a.tactics[technique.tacticId];
        const tacticShortName = (tacticData == null ? void 0 : tacticData.short_name) || tactic.name.toLowerCase().replace(/\s+/g, "-");
        let color;
        if (technique.severity === "valid") {
          color = "#66bb6a";
        } else if (technique.severity === "unknown_technique" || technique.severity === "unknown_tactic") {
          color = "#f44336";
        } else if (technique.severity === "mismatch") {
          color = "#ffa500";
        } else {
          color = "#66bb6a";
        }
        let comment = `Used in ${technique.count} IOC card${technique.count > 1 ? "s" : ""}`;
        if (technique.severity !== "valid" && technique.validationMessage) {
          const icon = technique.severity === "unknown_technique" || technique.severity === "unknown_tactic" ? "\u{1F534}" : "\u26A0\uFE0F";
          comment += `
${icon} ${technique.validationMessage}`;
        }
        layer.techniques.push({
          techniqueID: technique.id,
          tactic: tacticShortName,
          color,
          comment,
          enabled: true,
          metadata: [
            {
              name: "severity",
              value: technique.severity
            },
            {
              name: "ioc_cards",
              value: technique.iocCards.join(", ")
            }
          ],
          links: [],
          showSubtechniques: false,
          score: technique.count * 10
          // Scale count for visual weight
        });
      });
    });
    const jsonString = JSON.stringify(layer, null, 2);
    const blob = new Blob([jsonString], { type: "application/json" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = `mitre-navigator-${Date.now()}.json`;
    a.click();
    URL.revokeObjectURL(url);
  }
  onClose() {
    console.debug("[MitreModal] ===== MODAL CLOSED =====");
    const { contentEl } = this;
    contentEl.empty();
  }
  /**
   * Add drag handles and resize functionality to the modal.
   * Creates 8 resize handles (4 corners + 4 edges) and attaches drag listeners.
   */
  makeResizable() {
    const modal = this.modalEl;
    const MIN_WIDTH = 600;
    const MIN_HEIGHT = 400;
    const MAX_WIDTH = window.innerWidth * 0.95;
    const MAX_HEIGHT = window.innerHeight * 0.95;
    const handles = [
      ["resize-handle-n", "ns-resize", false],
      ["resize-handle-s", "ns-resize", false],
      ["resize-handle-e", "ew-resize", false],
      ["resize-handle-w", "ew-resize", false],
      ["resize-handle-ne", "nesw-resize", true],
      ["resize-handle-nw", "nwse-resize", true],
      ["resize-handle-se", "nwse-resize", true],
      ["resize-handle-sw", "nesw-resize", true]
    ];
    handles.forEach(([className, cursor, isCorner]) => {
      const handle = modal.createDiv(`mitre-resize-handle ${className}`);
      handle.style.cursor = cursor;
      let startX = 0, startY = 0, startWidth = 0, startHeight = 0, startLeft = 0, startTop = 0;
      const onMouseDown = (e) => {
        e.preventDefault();
        e.stopPropagation();
        startX = e.clientX;
        startY = e.clientY;
        const rect = modal.getBoundingClientRect();
        startWidth = rect.width;
        startHeight = rect.height;
        startLeft = rect.left;
        startTop = rect.top;
        document.addEventListener("mousemove", onMouseMove);
        document.addEventListener("mouseup", onMouseUp);
        modal.addClass("mitre-modal-resizing");
      };
      const onMouseMove = (e) => {
        const deltaX = e.clientX - startX;
        const deltaY = e.clientY - startY;
        let newWidth = startWidth;
        let newHeight = startHeight;
        let newLeft = startLeft;
        let newTop = startTop;
        if (className.includes("-e")) {
          newWidth = Math.max(MIN_WIDTH, Math.min(MAX_WIDTH, startWidth + deltaX));
        }
        if (className.includes("-w")) {
          newWidth = Math.max(MIN_WIDTH, Math.min(MAX_WIDTH, startWidth - deltaX));
          newLeft = startLeft + (startWidth - newWidth);
        }
        if (className.includes("-s")) {
          newHeight = Math.max(MIN_HEIGHT, Math.min(MAX_HEIGHT, startHeight + deltaY));
        }
        if (className.includes("-n")) {
          newHeight = Math.max(MIN_HEIGHT, Math.min(MAX_HEIGHT, startHeight - deltaY));
          newTop = startTop + (startHeight - newHeight);
        }
        modal.style.setProperty("width", `${newWidth}px`, "important");
        modal.style.setProperty("height", `${newHeight}px`, "important");
        modal.style.setProperty("max-width", `${newWidth}px`, "important");
        modal.style.setProperty("max-height", `${newHeight}px`, "important");
        if (className.includes("-w") || className.includes("-n")) {
          modal.style.left = `${newLeft}px`;
          modal.style.top = `${newTop}px`;
        }
      };
      const onMouseUp = () => {
        document.removeEventListener("mousemove", onMouseMove);
        document.removeEventListener("mouseup", onMouseUp);
        modal.removeClass("mitre-modal-resizing");
      };
      handle.addEventListener("mousedown", onMouseDown);
    });
  }
};

// src/RenderIOCCardsModal.ts
var import_obsidian3 = require("obsidian");
var RenderIOCCardsModal = class extends import_obsidian3.Modal {
  constructor(app, iocTypes, onSelect) {
    super(app);
    this.iocTypes = iocTypes;
    this.onSelect = onSelect;
  }
  /** Builds the primary IOC type grid view. */
  onOpen() {
    const { contentEl } = this;
    this.modalEl.classList.add("ioc-type-selector-modal");
    this.modalEl.style.maxWidth = "900px";
    this.modalEl.style.width = "90vw";
    contentEl.createEl("h2", { text: "Select IOC Type" });
    const container = contentEl.createDiv("ioc-type-container");
    const typeCount = Object.keys(this.iocTypes).length;
    const cols = Math.min(Math.ceil(Math.sqrt(typeCount)), 5);
    container.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;
    Object.keys(this.iocTypes).forEach((iocTypeId) => {
      const iocType = this.iocTypes[iocTypeId];
      const button = container.createEl("button", { cls: "ioc-type-button" });
      button.setAttribute("data-ioc-type", iocTypeId);
      button.style.borderLeft = `4px solid ${iocType.color}`;
      const iconContainer = button.createDiv("ioc-button-icon");
      iconContainer.innerHTML = iocType.svg;
      const textContainer = button.createDiv("ioc-button-text");
      textContainer.textContent = iocType.name;
      button.addEventListener("click", () => {
        if (iocTypeId === "hostname") {
          this.showOSSelector(iocTypeId);
        } else {
          this.onSelect(iocTypeId);
          this.close();
        }
      });
    });
  }
  /**
   * Replaces the type grid with an OS selector sub-view.
   * Only reachable when iocTypeId === 'hostname' and the type has os_icons.
   */
  showOSSelector(iocTypeId) {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "Select Operating System" });
    contentEl.createEl("p", { text: "Choose the operating system for this hostname:" });
    const container = contentEl.createDiv("os-selector-container");
    const iocType = this.iocTypes[iocTypeId];
    if (iocType.os_icons) {
      Object.keys(iocType.os_icons).forEach((osType) => {
        const osButton = container.createEl("button", { cls: "os-type-button" });
        osButton.setAttribute("data-os-type", osType);
        const iconContainer = osButton.createDiv("os-button-icon");
        iconContainer.innerHTML = iocType.os_icons[osType];
        const textContainer = osButton.createDiv("os-button-text");
        textContainer.textContent = osType.charAt(0).toUpperCase() + osType.slice(1);
        osButton.addEventListener("click", () => {
          this.onSelect(iocTypeId, osType);
          this.close();
        });
      });
    }
    const backButton = contentEl.createEl("button", {
      text: "\u2190 Back to IOC Types",
      cls: "back-button"
    });
    backButton.addEventListener("click", () => {
      contentEl.empty();
      this.onOpen();
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/RenderIOCCards.ts
var RenderIOCCards = class {
  /**
   * Builds the full markdown+HTML string for a new IOC card.
   * @param iocType  - The IOCField definition from the type registry
   * @param iocTypeId - The snake_case key (needed to detect "hostname" special case)
   * @param osType   - If iocTypeId is "hostname", which OS variant was selected
   */
  static createCardContent(iocType, iocTypeId, osType = null) {
    const now = new Date();
    const timestamp = now.toISOString().replace("T", " ").substring(0, 19);
    let iconSvg = iocType.svg;
    if (iocTypeId === "hostname" && osType && iocType.os_icons) {
      iconSvg = iocType.os_icons[osType] || iocType.svg;
    }
    let content = `<div class="ioc-card-container"><div class="ioc-card-header"
        style="display: flex; align-items: center; gap: 16px; margin-bottom: 30px; padding: 20px;
        background: linear-gradient(135deg, ${iocType.color}22, transparent);
        border-radius: 8px; border-bottom: 3px solid ${iocType.color};">
        <div class="ioc-icon" style="flex-shrink: 0;">${iconSvg}</div><h2 style="margin: 0;
        color: ${iocType.color}; font-size: 24px; font-weight: 700;">${iocType.name}</h2></div>
        <div class="ioc-card-content" style="padding: 0 20px;"></div></div>
`;
    iocType.fields.forEach((field) => {
      content += `${field}: 



`;
    });
    content += `Time of Event: ${timestamp}

`;
    content += `Splunk Query: 

`;
    content += `Mitre Tactic: 

`;
    content += `Mitre Technique: 

`;
    return content;
  }
};

// src/PluginSettings.ts
var import_obsidian4 = require("obsidian");
var DEFAULT_SETTINGS = {
  cardSize: "medium",
  showTimelineButton: true
};
var PluginSettings = class extends import_obsidian4.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "IOC Canvas Plugin Settings" });
    new import_obsidian4.Setting(containerEl).setName("Default card size").setDesc("Set the default size for IOC cards").addDropdown(
      (dropdown) => dropdown.addOption("small", "Small").addOption("medium", "Medium").addOption("large", "Large").setValue(this.plugin.settings.cardSize).onChange(async (value) => {
        this.plugin.settings.cardSize = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian4.Setting(containerEl).setName("Show timeline button").setDesc("Display timeline button in canvas toolbar").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.showTimelineButton).onChange(async (value) => {
        this.plugin.settings.showTimelineButton = value;
        await this.plugin.saveSettings();
      })
    );
  }
};

// src/main.ts
var IOCCanvasPlugin = class extends import_obsidian5.Plugin {
  constructor() {
    super(...arguments);
    /** Typed settings object persisted to data.json. */
    this.settings = DEFAULT_SETTINGS;
    /** Whether the canvas IOC cards are currently in compact/reduced view. */
    this.isReducedView = false;
  }
  // ---------------------------------------------------------------
  // Plugin lifecycle
  // ---------------------------------------------------------------
  /**
   * Called by Obsidian when the plugin is activated.
   *
   * Order of operations:
   *   1. Load persisted settings from data.json.
   *   2. Register ribbon icons (sidebar shortcuts).
   *   3. Register commands (accessible via Ctrl/Cmd+P).
   *   4. Register the single settings tab from PluginSettings.ts.
   *   5. Register the canvas context-menu entry.
   *   6. Listen for active-leaf changes to inject floating buttons.
   *   7. Perform an initial button injection for the currently open leaf.
   */
  async onload() {
    console.log("Loading IOC Canvas Plugin");
    await this.loadSettings();
    this.addRibbonIcon("clock", "Show Attack Timelines", () => {
      new RenderTimelinesModal(this.app, this).open();
    });
    this.addCommand({
      id: "show-timelines",
      name: "Show Attack Timelines",
      callback: () => {
        new RenderTimelinesModal(this.app, this).open();
      }
    });
    this.addCommand({
      id: "show-ioc-cards",
      name: "Show All IOC Cards",
      callback: () => {
        this.openIOCCardSelector();
      }
    });
    this.addSettingTab(new PluginSettings(this.app, this));
    this.registerEvent(
      this.app.workspace.on("file-menu", (menu, file) => {
        if (file instanceof import_obsidian5.TFile && file.extension === "canvas") {
          menu.addItem((item) => {
            item.setTitle("Show Attack Timelines").setIcon("clock").onClick(() => {
              new RenderTimelinesModal(this.app, this).open();
            });
          });
        }
      })
    );
    this.registerEvent(
      this.app.workspace.on("active-leaf-change", () => {
        this.addCanvasButtons();
      })
    );
    this.addCanvasButtons();
  }
  /**
   * Called by Obsidian when the plugin is deactivated or Obsidian closes.
   * Cleans up all DOM elements injected by the plugin so they do not
   * persist after disable/uninstall.
   */
  onunload() {
    console.log("Unloading IOC Canvas Plugin");
    document.querySelectorAll(".ioc-toolbar").forEach((el) => el.remove());
    document.querySelectorAll(".ioc-reduced").forEach((el) => el.classList.remove("ioc-reduced"));
  }
  // ---------------------------------------------------------------
  // Settings persistence
  // ---------------------------------------------------------------
  /** Load settings from data.json, falling back to defaults for any missing keys. */
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  /** Persist the current settings object to data.json. */
  async saveSettings() {
    await this.saveData(this.settings);
  }
  // ---------------------------------------------------------------
  // Canvas floating button injection
  // ---------------------------------------------------------------
  /**
   * Injects control buttons into Obsidian's native canvas control bar.
   *
   * Buttons added:
   *   - Timeline button: opens the attack-timeline modal.
   *   - IOC Cards button: opens the IOC card selector.
   *
   * Uses the .ioc-toolbar class as a duplicate-injection guard.
   *
   * The entire method is wrapped in a try/catch so a failure in button
   * creation never takes down the plugin.
   */
  addCanvasButtons() {
    try {
      const activeView = this.app.workspace.getActiveViewOfType(import_obsidian5.ItemView);
      if (!activeView || activeView.getViewType() !== "canvas") {
        return;
      }
      const canvasView = activeView.containerEl;
      if (!canvasView) {
        return;
      }
      const canvasControls = canvasView.querySelector(".canvas-controls");
      if (!canvasControls) {
        return;
      }
      if (canvasControls.querySelector(".ioc-toolbar")) {
        return;
      }
      const iocToolbar = document.createElement("div");
      iocToolbar.className = "ioc-toolbar";
      const timelineItem = document.createElement("div");
      timelineItem.className = "canvas-control-item";
      timelineItem.setAttribute("aria-label", "Show Attack Timelines");
      timelineItem.setAttribute("title", "Show Attack Timelines");
      timelineItem.addEventListener("click", () => {
        new RenderTimelinesModal(this.app, this).open();
      });
      const timelineIcon = document.createElement("div");
      timelineIcon.className = "clickable-icon";
      timelineIcon.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>';
      timelineItem.appendChild(timelineIcon);
      const cardsItem = document.createElement("div");
      cardsItem.className = "canvas-control-item";
      cardsItem.setAttribute("aria-label", "Add IOC Card");
      cardsItem.setAttribute("title", "Add IOC Card");
      cardsItem.addEventListener("click", () => {
        this.openIOCCardSelector();
      });
      const cardsIcon = document.createElement("div");
      cardsIcon.className = "clickable-icon";
      cardsIcon.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="2" y="3" width="20" height="14" rx="2" ry="2"/><line x1="8" y1="21" x2="16" y2="21"/><line x1="12" y1="17" x2="12" y2="21"/></svg>';
      cardsItem.appendChild(cardsIcon);
      const reduceItem = document.createElement("div");
      reduceItem.className = "canvas-control-item";
      reduceItem.setAttribute("aria-label", "Toggle Reduce View");
      reduceItem.setAttribute("title", "Toggle Reduce View");
      reduceItem.addEventListener("click", () => {
        this.toggleReduceView();
        const icon = reduceItem.querySelector(".clickable-icon");
        if (icon) {
          icon.classList.toggle("is-active", this.isReducedView);
        }
      });
      const reduceIcon = document.createElement("div");
      reduceIcon.className = "clickable-icon";
      reduceIcon.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="4 14 10 14 10 20"/><polyline points="20 10 14 10 14 4"/><line x1="14" y1="10" x2="21" y2="3"/><line x1="3" y1="21" x2="10" y2="14"/></svg>';
      reduceItem.appendChild(reduceIcon);
      const mitreItem = document.createElement("div");
      mitreItem.className = "canvas-control-item";
      mitreItem.setAttribute("aria-label", "MITRE ATT&CK Mapper");
      mitreItem.setAttribute("title", "MITRE ATT&CK Mapper");
      mitreItem.addEventListener("click", () => {
        new RenderMitreModal(this.app, this).open();
      });
      const mitreIcon = document.createElement("div");
      mitreIcon.className = "clickable-icon";
      mitreIcon.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><circle cx="12" cy="12" r="6"/><circle cx="12" cy="12" r="2"/></svg>';
      mitreItem.appendChild(mitreIcon);
      iocToolbar.appendChild(timelineItem);
      iocToolbar.appendChild(cardsItem);
      iocToolbar.appendChild(reduceItem);
      iocToolbar.appendChild(mitreItem);
      canvasControls.appendChild(iocToolbar);
    } catch (err) {
      console.error("IOC Canvas: failed to inject canvas buttons", err);
    }
  }
  // ---------------------------------------------------------------
  // Reduce view toggle
  // ---------------------------------------------------------------
  /**
   * Toggles the reduced/compact view for IOC cards on the active canvas.
   * When reduced, CSS hides everything except the code block value, and
   * nodes are resized to a compact single-line height.
   */
  toggleReduceView() {
    const activeView = this.app.workspace.getActiveViewOfType(import_obsidian5.ItemView);
    if (!activeView || activeView.getViewType() !== "canvas")
      return;
    const canvas = activeView.canvas;
    if (!canvas)
      return;
    this.isReducedView = !this.isReducedView;
    const wrapperEl = canvas.wrapperEl;
    if (wrapperEl) {
      if (this.isReducedView) {
        wrapperEl.classList.add("ioc-reduced");
      } else {
        wrapperEl.classList.remove("ioc-reduced");
      }
    }
    if (canvas.nodes) {
      canvas.nodes.forEach((node) => {
        if (!node.text)
          return;
        if (this.isReducedView) {
          if (!node._iocOriginalHeight) {
            node._iocOriginalHeight = node.height;
          }
          if (node.resize) {
            node.resize({ width: node.width, height: 60 });
          } else {
            node.height = 60;
          }
        } else {
          const originalH = node._iocOriginalHeight || 400;
          if (node.resize) {
            node.resize({ width: node.width, height: originalH });
          } else {
            node.height = originalH;
          }
        }
      });
    }
    canvas.requestFrame();
    canvas.requestSave();
  }
  // ---------------------------------------------------------------
  // IOC card creation helpers
  // ---------------------------------------------------------------
  /**
   * Opens the IOC card selector modal. The callback creates the card on
   * the active canvas.
   */
  openIOCCardSelector() {
    new RenderIOCCardsModal(
      this.app,
      IOC_TYPES,
      (iocTypeId, osType) => {
        this.createIOCCard(iocTypeId, osType);
      }
    ).open();
  }
  /**
   * Creates an IOC card on the active canvas.
   * @param iocTypeId - The snake_case IOC type key from IOC_TYPES
   * @param osType    - Optional OS variant for hostname cards
   */
  createIOCCard(iocTypeId, osType) {
    const activeView = this.app.workspace.getActiveViewOfType(import_obsidian5.ItemView);
    if (!activeView || activeView.getViewType() !== "canvas") {
      new import_obsidian5.Notice("Please open a canvas first");
      return;
    }
    const canvas = activeView.canvas;
    if (!canvas) {
      new import_obsidian5.Notice("Please open a canvas first");
      return;
    }
    const iocType = IOC_TYPES[iocTypeId];
    if (!iocType) {
      new import_obsidian5.Notice("Unknown IOC type: " + iocTypeId);
      return;
    }
    const content = RenderIOCCards.createCardContent(iocType, iocTypeId, osType || null);
    canvas.createTextNode({
      pos: { x: Math.random() * 400, y: Math.random() * 400 },
      size: { width: 400, height: 400 },
      text: content
    });
    canvas.requestSave();
    new import_obsidian5.Notice(`Created ${iocType.name} card`);
  }
};
