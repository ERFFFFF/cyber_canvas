/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => IOCCanvasPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian5 = require("obsidian");

// src/RenderTimelinesModal.ts
var import_obsidian = require("obsidian");

// src/IOCCardsTypes.ts
var IOC_TYPES = {
  // --- Network-related IOC types ---
  ip_address: {
    name: "IP Address",
    icon: "network",
    color: "#FF6B6B",
    fields: ["IP", "country", "asn"],
    svg: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="32" height="32" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
  <circle cx="12" cy="15" r="7"/>
  <path d="M12 8c-3.9 0-7 3.1-7 7"/>
  <path d="M12 8c3.9 0 7 3.1 7 7"/>
  <line x1="5" y1="15" x2="19" y2="15"/>
  <line x1="12" y1="8" x2="12" y2="22"/>
  <path d="M12 8c-1.7-3-1.7-6 0-6s1.7 3 0 6z"/>
  <circle cx="12" cy="4" r="2" fill="currentColor"/>
</svg>`
  },
  domain: {
    name: "Domain Name",
    icon: "globe",
    color: "#4ECDC4",
    fields: ["name", "IP"],
    svg: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="32" height="32" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
    <circle cx="12" cy="12" r="10"/>
    <line x1="2" y1="12" x2="22" y2="12"/>
    <path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"/>
  </svg>`
  },
  file_hash: {
    name: "File Hash",
    icon: "hash",
    color: "#45B7D1",
    fields: ["hash", "hash_type", "filename", "file_size"],
    svg: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="32" height="32" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
    <line x1="4" y1="9" x2="20" y2="9"/>
    <line x1="4" y1="15" x2="20" y2="15"/>
    <line x1="10" y1="3" x2="8" y2="21"/>
    <line x1="16" y1="3" x2="14" y2="21"/>
  </svg>`
  },
  url: {
    name: "URL",
    icon: "link",
    color: "#96CEB4",
    fields: ["url", "domain", "category"],
    svg: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="32" height="32" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
    <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"/>
    <path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"/>
  </svg>`
  },
  email: {
    name: "Email Address",
    icon: "mail",
    color: "#FECA57",
    fields: ["email", "domain"],
    svg: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="32" height="32" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
    <path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"/>
    <polyline points="22,6 12,13 2,6"/>
  </svg>`
  },
  // Hostname is the only IOC type with os_icons, triggering a secondary
  // OS selector sub-view in RenderIOCCardsModal before card creation.
  hostname: {
    name: "Hostname",
    icon: "monitor",
    color: "#9C27B0",
    fields: ["hostname", "os_type", "domain"],
    svg: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="32" height="32" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
    <rect x="2" y="3" width="20" height="14" rx="2" ry="2"/>
    <line x1="8" y1="21" x2="16" y2="21"/>
    <line x1="12" y1="17" x2="12" y2="21"/>
  </svg>`,
    os_icons: {
      windows_workstation: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="32" height="32" fill="currentColor">
    <path d="M0 3.5L10 2v9.5H0V3.5zM11 1.9l13-1.9v11H11V1.9zM0 12.5h10V22l-10-1.5v-8zM11 12h13v10l-13 2v-12z"/>
  </svg>`,
      windows_server: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="32" height="32" fill="currentColor">
    <path d="M0 3.5L10 2v9.5H0V3.5zM11 1.9l13-1.9v11H11V1.9zM0 12.5h10V22l-10-1.5v-8zM11 12h13v10l-13 2v-12z"/>
  </svg>`,
      macos: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="32" height="32" fill="currentColor">
    <path d="M17.05 20.28c-.98.95-2.05.8-3.08.35-1.09-.46-2.09-.48-3.24 0-1.44.62-2.2.44-3.06-.35C2.79 15.25 3.51 7.59 9.05 7.31c1.35.07 2.29.74 3.08.8 1.18-.24 2.31-.93 3.57-.84 1.51.12 2.65.72 3.4 1.8-3.12 1.87-2.38 5.98.48 7.13-.57 1.5-1.31 2.99-2.54 4.09l.01-.01zM12.03 7.25c-.15-2.23 1.66-4.07 3.74-4.25.29 2.58-2.34 4.5-3.74 4.25z"/>
  </svg>`,
      linux: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="32" height="32" fill="currentColor">
    <path d="M12.504 0c-.155 0-.315.008-.48.021-4.226.333-3.105 4.807-3.17 6.298-.076 1.092-.3 1.953-1.05 3.02-.885 1.051-2.127 2.75-2.716 4.521-.278.84-.41 1.684-.287 2.489.845 5.548 5.676 6.016 6.855 6.016.178 0 .287-.016.287-.016s8.029-.192 8.03-8.047c0-4.662-3.916-9.69-7.47-14.302z"/>
  </svg>`
    }
  },
  // --- Detection rule types ---
  yara_rule: {
    name: "YARA Rule",
    icon: "shield",
    color: "#FF9FF3",
    fields: ["rule_name", "rule_content"],
    svg: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="32" height="32" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
    <path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"/>
    <text x="12" y="15" font-size="10" text-anchor="middle" fill="currentColor" font-weight="bold">Y</text>
  </svg>`
  },
  sigma_rule: {
    name: "Sigma Rule",
    icon: "search",
    color: "#A8E6CF",
    fields: ["rule_name", "rule_content"],
    svg: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="32" height="32" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
    <circle cx="12" cy="12" r="10"/>
    <text x="12" y="17" font-size="14" text-anchor="middle" fill="currentColor" font-weight="bold">\u03A3</text>
  </svg>`
  },
  // --- Host-based IOC types ---
  registry_key: {
    name: "Registry Key",
    icon: "settings",
    color: "#FFB74D",
    fields: ["key_path", "key_name", "key_data"],
    svg: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="32" height="32" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
    <rect x="3" y="11" width="18" height="11" rx="2" ry="2"/>
    <path d="M7 11V7a5 5 0 0 1 9.9-1"/>
  </svg>`
  },
  process_name: {
    name: "Process Name",
    icon: "cpu",
    color: "#81C784",
    fields: ["process_name", "command_line", "pid", "parent_process"],
    svg: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="32" height="32" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
  <rect x="3" y="5" width="18" height="14" rx="2" ry="2"/>
  <line x1="3" y1="9" x2="21" y2="9"/>
  <circle cx="6" cy="7" r="0.8" fill="currentColor"/>
  <circle cx="9" cy="7" r="0.8" fill="currentColor"/>
  <line x1="7" y1="13" x2="17" y2="13"/>
  <line x1="7" y1="16" x2="14" y2="16"/>
</svg>`
  },
  network: {
    name: "Network",
    icon: "activity",
    color: "#9575CD",
    fields: ["protocol", "port", "direction"],
    svg: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="32" height="32" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
    <polyline points="22 12 18 12 15 21 9 3 6 12 2 12"/>
  </svg>`
  },
  command_line: {
    name: "Command Line",
    icon: "terminal",
    color: "#2E8B57",
    fields: ["command", "pid", "parent_process"],
    svg: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="32" height="32" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
    <polyline points="4 17 10 11 4 5"/>
    <line x1="12" y1="19" x2="20" y2="19"/>
  </svg>`
  },
  // --- File and artifact types ---
  file: {
    name: "File",
    icon: "file",
    color: "#E91E63",
    fields: ["name", "type", "path", "size", "hash", "pid"],
    svg: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="32" height="32" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
  <path d="M4 4h12l4 4v12a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2z"/>
  <line x1="8" y1="11" x2="16" y2="11"/>
  <line x1="8" y1="15" x2="16" y2="15"/>
</svg>`
  },
  // --- Utility types ---
  note: {
    name: "Note",
    icon: "note",
    color: "#F39C12",
    fields: ["NB"],
    svg: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="32" height="32" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
  <rect x="4" y="4" width="16" height="16" rx="2" ry="2"/>
  <line x1="8" y1="8" x2="16" y2="8"/>
  <line x1="8" y1="12" x2="16" y2="12"/>
  <line x1="8" y1="16" x2="14" y2="16"/>
</svg>`
  },
  dll: {
    name: "DLL",
    icon: "dll",
    color: "#3498DB",
    fields: ["name", "type", "path", "size", "hash"],
    svg: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="32" height="32" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
  <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8l-6-6z"/>
  <polyline points="14 2 14 8 20 8"/>
  <circle cx="12" cy="13" r="2"/>
  <path d="M12 10.5v-1"/>
  <path d="M12 15.5v1"/>
  <path d="M14.5 11.5l0.7-0.7"/>
  <path d="M9.8 16.2l-0.7 0.7"/>
  <path d="M15.5 13h1"/>
  <path d="M8.5 13h-1"/>
  <path d="M14.5 14.5l0.7 0.7"/>
  <path d="M9.8 9.8l-0.7-0.7"/>
</svg>`
  },
  // --- Threat infrastructure ---
  c2: {
    name: "C2",
    icon: "c2",
    color: "#E74C3C",
    fields: ["domain", "IP"],
    svg: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="32" height="32" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
  <circle cx="12" cy="12" r="9"/>
  <path d="M12 3v1.5"/>
  <path d="M12 19.5V21"/>
  <path d="M3 12h1.5"/>
  <path d="M19.5 12H21"/>
  <path d="M5.6 5.6l1.1 1.1"/>
  <path d="M17.3 17.3l1.1 1.1"/>
  <path d="M5.6 18.4l1.1-1.1"/>
  <path d="M17.3 6.7l1.1-1.1"/>
  <polyline points="8 10 11 13 8 16"/>
  <line x1="13" y1="16" x2="16" y2="16"/>
</svg>`
  }
};

// src/IOCParser.ts
var IOC_TYPE_PATTERNS = [
  { pattern: /IP Address/i, type: "IP Address" },
  { pattern: /Domain Name/i, type: "Domain Name" },
  { pattern: /File Hash/i, type: "File Hash" },
  { pattern: /URL/i, type: "URL" },
  { pattern: /Email Address/i, type: "Email Address" },
  { pattern: /Hostname/i, type: "Hostname" },
  { pattern: /YARA Rule/i, type: "YARA Rule" },
  { pattern: /Sigma Rule/i, type: "Sigma Rule" },
  { pattern: /Registry Key/i, type: "Registry Key" },
  { pattern: /Process Name/i, type: "Process Name" },
  // FIX: The IOC_TYPES constant uses "Network" (not "Network Traffic").
  // The old code used "Network Traffic" which would never match the
  // IOC_TYPES lookup, so color and icon were never resolved for this type.
  { pattern: /Network/i, type: "Network" },
  { pattern: /Command Line/i, type: "Command Line" },
  { pattern: /File/i, type: "File" },
  { pattern: /Note/i, type: "Note" },
  { pattern: /DLL/i, type: "DLL" },
  { pattern: /C2/i, type: "C2" }
];
function detectIOCType(text) {
  for (const { pattern, type } of IOC_TYPE_PATTERNS) {
    if (pattern.test(text)) {
      return type;
    }
  }
  return "";
}
function extractValue(text) {
  console.debug("[IOCParser] extractValue - input length:", text.length);
  const codeBlockMatch = text.match(/```([\s\S]*?)```/);
  if (codeBlockMatch && codeBlockMatch[1] && codeBlockMatch[1].trim()) {
    const value2 = codeBlockMatch[1].trim();
    console.debug("[IOCParser] extractValue - found code block:", value2);
    return value2;
  }
  const parts = text.split("</div></div>");
  if (parts.length < 2) {
    console.debug("[IOCParser] extractValue - no HTML header found");
    return "";
  }
  let afterHeader = parts[1].trim();
  console.debug("[IOCParser] extractValue - content after header length:", afterHeader.length);
  const fieldMatch = afterHeader.match(/[^:\n]+:\s*/);
  if (!fieldMatch) {
    console.debug("[IOCParser] extractValue - no field label found");
    return "";
  }
  console.debug("[IOCParser] extractValue - first field:", fieldMatch[0].trim());
  const afterFieldLabel = afterHeader.substring(fieldMatch.index + fieldMatch[0].length);
  const separatorMatch = afterFieldLabel.match(/\n?-----/);
  const nextFieldMatch = afterFieldLabel.match(/\n([^:\n]+:\s*)/);
  let value;
  let delimiterIndex;
  if (separatorMatch && separatorMatch.index !== void 0) {
    delimiterIndex = separatorMatch.index;
  }
  if (nextFieldMatch && nextFieldMatch.index !== void 0) {
    if (delimiterIndex === void 0 || nextFieldMatch.index < delimiterIndex) {
      delimiterIndex = nextFieldMatch.index;
    }
  }
  if (delimiterIndex === void 0) {
    const timeIndex = afterFieldLabel.indexOf("Time of Event:");
    value = timeIndex === -1 ? afterFieldLabel : afterFieldLabel.substring(0, timeIndex);
  } else {
    value = afterFieldLabel.substring(0, delimiterIndex);
  }
  const trimmedValue = value.trim();
  console.debug("[IOCParser] extractValue - result:", trimmedValue || "(empty)");
  return trimmedValue;
}
function extractTime(text) {
  const timePatterns = [
    /\*\*Time of Event:\*\*\s*(\d{4}-\d{2}-\d{2}\s\d{2}:\d{2}:\d{2})/i,
    /\*\*Time of Event:\*\*\s*(\d{4}-\d{2}-\d{2})/i,
    /Time of Event[:\s]*(\d{4}-\d{2}-\d{2}[T\s]\d{2}:\d{2}:\d{2})/i,
    /Time of Event[:\s]*(\d{4}-\d{2}-\d{2})/i,
    /Time[:\s]*(\d{4}-\d{2}-\d{2}[T\s]\d{2}:\d{2}:\d{2})/i,
    /(\d{4}-\d{2}-\d{2}[T\s]\d{2}:\d{2}:\d{2})/i
  ];
  for (const pattern of timePatterns) {
    const match = text.match(pattern);
    if (match && match[1]) {
      return match[1].trim();
    }
  }
  return "";
}
function extractSplunkQuery(text) {
  const match = text.match(/\*\*Splunk Query:\*\*[:\s]*([\s\S]*?)(?=\*\*|$)/i);
  if (match && match[1] && match[1].trim()) {
    return match[1].trim();
  }
  return "";
}
function extractTactic(text) {
  console.debug("[IOCParser] Extracting tactic...");
  let match = text.match(/Mitre Tactic:[ \t]*([^\n]*)/i);
  if (match && match[1] && match[1].trim()) {
    const tactic = match[1].trim().toUpperCase();
    console.debug("[IOCParser] \u2713 Found tactic (plain):", tactic);
    return tactic;
  }
  match = text.match(/\*\*Mitre Tactic:\*\*[ \t]*([^\n]*)/i) || text.match(/\*\*Mitre Tactic:\*\*[:\s]*([\s\S]*?)(?=\*\*|$)/i);
  if (match && match[1] && match[1].trim()) {
    const tactic = match[1].trim().toUpperCase();
    console.debug("[IOCParser] \u2713 Found tactic (bold):", tactic);
    return tactic;
  }
  console.debug("[IOCParser] \u26A0 No tactic found");
  return "";
}
function extractTechnique(text) {
  console.debug("[IOCParser] Extracting technique...");
  let match = text.match(/Mitre Technique:[ \t]*([^\n]*)/i);
  if (match && match[1] && match[1].trim()) {
    const technique = match[1].trim().toUpperCase();
    console.debug("[IOCParser] \u2713 Found technique (plain):", technique);
    return technique;
  }
  match = text.match(/\*\*Mitre Technique:\*\*[ \t]*([^\n]*)/i) || text.match(/\*\*Mitre Technique:\*\*[:\s]*([\s\S]*?)(?=\*\*|$)/i);
  if (match && match[1] && match[1].trim()) {
    const technique = match[1].trim().toUpperCase();
    console.debug("[IOCParser] \u2713 Found technique (bold):", technique);
    return technique;
  }
  console.debug("[IOCParser] \u26A0 No technique found");
  return "";
}
function extractCardId(text) {
  console.debug("[IOCParser] Extracting Card ID...");
  const commentMatch = text.match(/<!-- IOC_CARD_ID:([^>]+) -->/);
  if (commentMatch && commentMatch[1]) {
    const cardId = commentMatch[1].trim();
    console.debug("[IOCParser] Found Card ID in HTML comment:", cardId);
    return cardId;
  }
  const cardIdMatch = text.match(/Card ID:\s*([^\n]+)/i);
  if (cardIdMatch && cardIdMatch[1]) {
    const cardId = cardIdMatch[1].trim();
    console.debug("[IOCParser] Found Card ID in legacy field format:", cardId);
    return cardId;
  }
  console.debug("[IOCParser] No Card ID found");
  return "";
}
function lookupTypeVisuals(iocType, fallbackColor) {
  let icon = "";
  let color = fallbackColor;
  if (IOC_TYPES && typeof IOC_TYPES === "object") {
    for (const key of Object.keys(IOC_TYPES)) {
      if (IOC_TYPES[key].name === iocType) {
        icon = IOC_TYPES[key].svg;
        color = IOC_TYPES[key].color;
        break;
      }
    }
  }
  return { icon, color };
}
function parseIOCNode(node) {
  var _a;
  console.debug("[IOCParser] ==================== PARSING NODE ====================");
  console.debug("[IOCParser] Node ID:", node.id);
  console.debug("[IOCParser] Text length:", ((_a = node.text) == null ? void 0 : _a.length) || 0);
  if (!node.text) {
    console.debug("[IOCParser] \u274C No text content");
    return null;
  }
  const iocType = detectIOCType(node.text);
  if (!iocType) {
    console.debug("[IOCParser] \u274C No IOC type detected");
    return null;
  }
  console.debug("[IOCParser] \u2713 IOC Type:", iocType);
  const value = extractValue(node.text);
  const time = extractTime(node.text);
  const splunkQuery = extractSplunkQuery(node.text);
  const tactic = extractTactic(node.text);
  const technique = extractTechnique(node.text);
  const cardId = extractCardId(node.text);
  const fallbackColor = node.color || "#333";
  const { icon, color } = lookupTypeVisuals(iocType, fallbackColor);
  const result = {
    id: node.id,
    cardId,
    type: iocType,
    value,
    time,
    splunkQuery,
    tactic,
    technique,
    icon,
    color
  };
  console.debug("[IOCParser] \u2713 EXTRACTION COMPLETE:", {
    type: iocType,
    cardId: cardId || "(no ID)",
    value: value || "(empty)",
    time: time || "(empty)",
    tactic: tactic || "(empty)",
    technique: technique || "(empty)"
  });
  console.debug("[IOCParser] =========================================================");
  return result;
}

// src/TimeTimelineProcessing.ts
var TimeTimelineProcessor = class {
  constructor(app, plugin, IOCCardsTypes) {
    this.app = app;
    this.plugin = plugin;
    this.IOCCardsTypes = IOCCardsTypes;
  }
  /**
   * Extract IOC data from all canvas text nodes for time-based timeline.
   *
   * Iterates over every node in the active canvas. Each node with a `text`
   * property is parsed via the shared IOCParser. Nodes that match a known
   * IOC type are included in the returned array.
   *
   * The caller (RenderTimelinesModal) sorts the result by time for display.
   *
   * DEBUG: Console logs show processing steps for troubleshooting.
   *
   * @returns Array of parsed IOC node data objects, unsorted
   */
  extractFixedIOCData() {
    console.debug("[TimeProcessor] Starting extraction");
    const activeLeaf = this.app.workspace.activeLeaf;
    if (!activeLeaf || !activeLeaf.view || activeLeaf.view.getViewType() !== "canvas") {
      console.debug("[TimeProcessor] No active canvas view");
      return [];
    }
    const canvasView = activeLeaf.view;
    const canvas = canvasView.canvas;
    if (!canvas || !canvas.nodes) {
      console.debug("[TimeProcessor] No canvas or nodes");
      return [];
    }
    const totalNodes = canvas.nodes.size || canvas.nodes.length || 0;
    console.debug("[TimeProcessor] Processing", totalNodes, "nodes");
    const iocData = [];
    let emptyValueCount = 0;
    canvas.nodes.forEach((node) => {
      if (node.text) {
        const parsedData = parseIOCNode(node);
        if (parsedData) {
          if (!parsedData.value || !parsedData.value.trim()) {
            emptyValueCount++;
          }
          iocData.push(parsedData);
        }
      }
    });
    console.debug("[TimeProcessor] Extraction complete - found:", iocData.length, "IOCs,", emptyValueCount, "empty values");
    return iocData;
  }
};

// src/RenderTimelinesModal.ts
var RenderTimelinesModal = class extends import_obsidian.Modal {
  constructor(app, plugin) {
    super(app);
    this.plugin = plugin;
    this.timeProcessor = new TimeTimelineProcessor(app, plugin, plugin.iocTypes);
  }
  onOpen() {
    const { contentEl } = this;
    this.modalEl.classList.add("timeline-modal-fullscreen");
    const headerContainer = contentEl.createDiv("timeline-modal-header");
    headerContainer.createEl("h2", { text: "\u{1F550} Time-Based IOC Timeline" });
    const contentArea = contentEl.createDiv("timeline-tab-content");
    this.renderEnhancedTimeTimeline(contentArea);
  }
  /**
   * Renders the chronological Time Timeline. Extracts IOC data from canvas
   * nodes via the time processor, sorts by event timestamp, and renders each
   * IOC as a colored card with a gradient connector to the next card.
   *
   * DEBUG: Console logs show timeline data for troubleshooting.
   */
  renderEnhancedTimeTimeline(container) {
    console.debug("[TimeTimeline] Starting render");
    const iocData = this.timeProcessor.extractFixedIOCData();
    console.debug("[TimeTimeline] Extracted", iocData.length, "IOC cards");
    if (iocData.length === 0) {
      container.createEl("p", {
        text: "No IOC cards found in the current canvas. Create some IOC cards first to see the timeline.",
        cls: "timeline-empty-message"
      });
      return;
    }
    iocData.sort((a, b) => new Date(a.time).getTime() - new Date(b.time).getTime());
    const timelineContainer = container.createDiv("timeline-container");
    iocData.forEach((ioc, index) => {
      const timelineItem = timelineContainer.createDiv("timeline-item");
      timelineItem.style.setProperty("--ioc-color", ioc.color);
      timelineItem.style.setProperty("--ioc-color-30", `${ioc.color}30`);
      timelineItem.style.background = `linear-gradient(135deg, ${ioc.color}15 0%, ${ioc.color}05 100%)`;
      timelineItem.style.boxShadow = `0 4px 12px ${ioc.color}25`;
      timelineItem.style.borderColor = ioc.color;
      if (index < iocData.length - 1) {
        const connector = timelineItem.createDiv("timeline-connector");
        connector.style.background = `linear-gradient(180deg, ${ioc.color} 0%, ${iocData[index + 1].color} 100%)`;
      }
      const iconContainer = timelineItem.createDiv("timeline-icon");
      iconContainer.innerHTML = ioc.icon;
      iconContainer.style.background = `${ioc.color}20`;
      iconContainer.style.borderColor = ioc.color;
      const detailsContainer = timelineItem.createDiv("timeline-details");
      const titleEl = detailsContainer.createEl("h3", { text: ioc.type });
      titleEl.style.textShadow = `0 1px 3px ${ioc.color}40`;
      const timeEl = detailsContainer.createDiv("timeline-time");
      timeEl.innerHTML = `\u{1F550} Time: ${ioc.time}`;
      if (ioc.value && ioc.value.trim()) {
        const valueEl = detailsContainer.createDiv("timeline-value");
        valueEl.innerHTML = `\u{1F4CC} Value: ${ioc.value}`;
      }
      if (ioc.splunkQuery && ioc.splunkQuery.trim()) {
        const splunkEl = detailsContainer.createDiv("timeline-splunk");
        splunkEl.innerHTML = `\u{1F50D} Splunk Query: ${ioc.splunkQuery}`;
      }
      if (ioc.tactic) {
        const tacticEl = detailsContainer.createDiv("timeline-tactic");
        tacticEl.innerHTML = `\u2694\uFE0F Tactic: ${ioc.tactic}`;
      }
      if (ioc.technique) {
        const techniqueEl = detailsContainer.createDiv("timeline-technique");
        techniqueEl.innerHTML = `\u{1F3AF} Technique: ${ioc.technique}`;
      }
      timelineItem.addEventListener("mouseover", () => {
        timelineItem.style.boxShadow = `0 8px 20px ${ioc.color}35`;
      });
      timelineItem.addEventListener("mouseout", () => {
        timelineItem.style.boxShadow = `0 4px 12px ${ioc.color}25`;
      });
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/RenderMitreModal.ts
var import_obsidian2 = require("obsidian");

// src/MitreLoader.ts
var cachedDataset = null;
var TACTIC_ABBREVIATIONS = {
  "Reconnaissance": ["RECON", "RECCE", "RE"],
  "Resource Development": ["RESOURCE", "RES", "RD"],
  "Initial Access": ["IA", "INIT"],
  "Execution": ["EXEC", "EXE", "EX"],
  "Persistence": ["PERSIST", "PERS", "PS"],
  "Privilege Escalation": ["PRIV", "PE", "PRIVESC", "PRIV ESC"],
  "Defense Evasion": ["DEFENSE", "DEF", "DE"],
  "Credential Access": ["CRED", "CA", "CRED ACCESS"],
  "Discovery": ["DISC", "DIS", "DI"],
  "Lateral Movement": ["LATERAL", "LM", "LAT MOVE"],
  "Collection": ["COLLECT", "COL", "CO"],
  "Command and Control": ["C2", "CNC", "CC"],
  "Exfiltration": ["EXFIL", "EXFILTRATE"],
  "Impact": ["IMP", "IM"]
};
async function loadMitreDataset(app) {
  if (cachedDataset) {
    console.debug("[MitreLoader] Returning cached dataset");
    return cachedDataset;
  }
  try {
    const adapter = app.vault.adapter;
    const jsonPath = ".obsidian/plugins/cyber_canvas/MITRE/enterprise-attack.json";
    console.debug("[MitreLoader] Attempting to load from:", jsonPath);
    if (await adapter.exists(jsonPath)) {
      const content = await adapter.read(jsonPath);
      const stixBundle = JSON.parse(content);
      if (stixBundle.type === "bundle" && Array.isArray(stixBundle.objects)) {
        console.debug("[MitreLoader] Parsing STIX 2.1 bundle format...");
        cachedDataset = parseStixBundle(stixBundle);
        console.log("[MitreLoader] \u2713 Loaded full dataset from STIX bundle. Tactics:", Object.keys(cachedDataset.tactics).length, "Techniques:", Object.keys(cachedDataset.techniques).length);
        return cachedDataset;
      } else if (stixBundle.version && stixBundle.tactics && stixBundle.techniques) {
        cachedDataset = stixBundle;
        console.log("[MitreLoader] \u2713 Loaded pre-processed dataset. Version:", cachedDataset.version, "Techniques:", Object.keys(cachedDataset.techniques).length);
        return cachedDataset;
      } else {
        console.warn("[MitreLoader] Unknown JSON format");
      }
    } else {
      console.error("[MitreLoader] JSON file not found at:", jsonPath);
      throw new Error(
        "MITRE ATT&CK dataset not found. Please ensure enterprise-attack.json exists in the MITRE folder. Download from: https://github.com/mitre-attack/attack-stix-data"
      );
    }
  } catch (err) {
    console.error("[MitreLoader] Failed to load MITRE dataset:", err);
    throw new Error(
      "MITRE ATT&CK dataset not found. Please ensure enterprise-attack.json exists in the MITRE folder. Download from: https://github.com/mitre-attack/attack-stix-data"
    );
  }
  throw new Error("MITRE ATT&CK dataset could not be loaded");
}
function parseStixBundle(stixBundle) {
  var _a, _b, _c, _d, _e, _f, _g, _h;
  console.debug("[MitreLoader] Parsing STIX bundle with", (_a = stixBundle.objects) == null ? void 0 : _a.length, "objects");
  const tactics = {};
  const techniques = {};
  let version = "unknown";
  let last_updated = new Date().toISOString().split("T")[0];
  for (const obj of stixBundle.objects) {
    if (obj.type === "x-mitre-collection") {
      version = obj.x_mitre_version || "unknown";
      last_updated = ((_b = obj.modified) == null ? void 0 : _b.split("T")[0]) || last_updated;
      console.debug("[MitreLoader] Found collection metadata - version:", version, "updated:", last_updated);
    }
  }
  for (const obj of stixBundle.objects) {
    if (obj.type === "x-mitre-tactic" && !obj.x_mitre_deprecated) {
      const tacticId = (_d = (_c = obj.external_references) == null ? void 0 : _c.find((ref) => ref.source_name === "mitre-attack")) == null ? void 0 : _d.external_id;
      if (!tacticId)
        continue;
      const shortName = obj.x_mitre_shortname || tacticId.toLowerCase();
      tactics[tacticId] = {
        id: tacticId,
        name: obj.name,
        short_name: shortName,
        description: obj.description || "",
        abbreviations: generateAbbreviations(obj.name)
      };
    }
  }
  console.debug("[MitreLoader] Parsed", Object.keys(tactics).length, "tactics");
  const shortNameToTacticId = /* @__PURE__ */ new Map();
  for (const [tacticId, tactic] of Object.entries(tactics)) {
    shortNameToTacticId.set(tactic.short_name, tacticId);
  }
  for (const obj of stixBundle.objects) {
    if (obj.type === "attack-pattern" && !obj.x_mitre_deprecated) {
      const techniqueId = (_f = (_e = obj.external_references) == null ? void 0 : _e.find((ref) => ref.source_name === "mitre-attack")) == null ? void 0 : _f.external_id;
      if (!techniqueId)
        continue;
      const tacticIds = [];
      if (obj.kill_chain_phases) {
        for (const phase of obj.kill_chain_phases) {
          if (phase.kill_chain_name === "mitre-attack") {
            const tacticId = shortNameToTacticId.get(phase.phase_name);
            if (tacticId) {
              tacticIds.push(tacticId);
            }
          }
        }
      }
      let parent;
      if (obj.x_mitre_is_subtechnique && techniqueId.includes(".")) {
        parent = techniqueId.split(".")[0];
      }
      techniques[techniqueId] = {
        id: techniqueId,
        name: obj.name,
        description: obj.description || "",
        tactics: tacticIds,
        parent,
        url: ((_h = (_g = obj.external_references) == null ? void 0 : _g.find((ref) => ref.source_name === "mitre-attack")) == null ? void 0 : _h.url) || `https://attack.mitre.org/techniques/${techniqueId.replace(".", "/")}`
      };
    }
  }
  console.debug("[MitreLoader] Parsed", Object.keys(techniques).length, "techniques");
  return {
    version,
    last_updated,
    tactics,
    techniques
  };
}
function generateAbbreviations(tacticName) {
  const abbrevs = [];
  const words = tacticName.split(/[\s\-]+/);
  if (words.length > 0) {
    abbrevs.push(words.map((w) => w[0]).join("").toUpperCase());
  }
  if (TACTIC_ABBREVIATIONS[tacticName]) {
    abbrevs.push(...TACTIC_ABBREVIATIONS[tacticName]);
  }
  return abbrevs;
}
function normalizeTacticName(name, dataset) {
  const normalized = name.toLowerCase().replace(/[\s\-_]+/g, "");
  console.debug("[MitreLoader] Normalizing tactic:", name, "\u2192", normalized);
  for (const [tacticId, tactic] of Object.entries(dataset.tactics)) {
    if (tactic.short_name.replace(/\-/g, "") === normalized) {
      console.debug("[MitreLoader] \u2713 Matched by short_name:", tactic.name, "(" + tacticId + ")");
      return tacticId;
    }
  }
  for (const [tacticId, tactic] of Object.entries(dataset.tactics)) {
    if (tactic.name.toLowerCase().replace(/[\s\-_]+/g, "") === normalized) {
      console.debug("[MitreLoader] \u2713 Matched by full name:", tactic.name, "(" + tacticId + ")");
      return tacticId;
    }
  }
  const upper = name.toUpperCase().trim();
  for (const [tacticId, tactic] of Object.entries(dataset.tactics)) {
    if (tactic.abbreviations.includes(upper)) {
      console.debug("[MitreLoader] \u2713 Matched by abbreviation:", upper, "\u2192", tactic.name, "(" + tacticId + ")");
      return tacticId;
    }
  }
  console.debug("[MitreLoader] \u2717 No match found for:", name);
  return null;
}
function validateTechniqueTactic(techniqueId, tacticInput, dataset) {
  const tacticId = normalizeTacticName(tacticInput, dataset);
  if (!tacticId) {
    return {
      severity: "unknown_tactic",
      message: `Unknown tactic: "${tacticInput}"`
    };
  }
  const technique = dataset.techniques[techniqueId];
  if (!technique) {
    return {
      severity: "unknown_technique",
      message: `Unknown technique: "${techniqueId}"`
    };
  }
  if (!technique.tactics.includes(tacticId)) {
    const validTactics = technique.tactics.map((tid) => {
      var _a;
      return ((_a = dataset.tactics[tid]) == null ? void 0 : _a.name) || tid;
    }).join(", ");
    return {
      severity: "mismatch",
      message: `${techniqueId} (${technique.name}) does not belong to ${dataset.tactics[tacticId].name}. Valid tactics: ${validTactics}`,
      tacticId
    };
  }
  return {
    severity: "valid",
    tacticId
  };
}

// src/RenderMitreModal.ts
var RenderMitreModal = class extends import_obsidian2.Modal {
  constructor(app, plugin, activeTechniqueId) {
    super(app);
    this.mitreDataset = null;
    this.subtechniquesMap = /* @__PURE__ */ new Map();
    this.currentSearchState = null;
    this.currentTactics = null;
    this.searchBar = null;
    this.searchClearButton = null;
    this.searchMatchCount = null;
    this.validationErrors = [];
    this.activeTechniqueId = null;
    // Active technique from selected card
    this.iocDataMap = /* @__PURE__ */ new Map();
    // Store IOC data for hover tooltips
    // Truncation limits
    this.TECHNIQUE_TRUNCATE_LIMIT = 180;
    this.SUBTECHNIQUE_TRUNCATE_LIMIT = 100;
    this.plugin = plugin;
    this.timeProcessor = new TimeTimelineProcessor(app, plugin, IOC_TYPES);
    this.activeTechniqueId = activeTechniqueId || null;
    this.loadDataset();
  }
  /**
   * Whether the severity represents a critical error (red indicator).
   */
  isCriticalSeverity(severity) {
    return severity === "unknown_technique" || severity === "unknown_tactic" || severity === "empty_tactic";
  }
  /**
   * Get the appropriate icon for a validation severity level.
   */
  getSeverityIcon(severity) {
    return this.isCriticalSeverity(severity) ? "\u{1F534}" : "\u26A0\uFE0F";
  }
  /**
   * Apply the appropriate CSS validation class based on severity.
   */
  applySeverityClass(element, severity) {
    if (severity === "valid") {
      element.addClass("mitre-technique-valid");
    } else if (this.isCriticalSeverity(severity)) {
      element.addClass("mitre-technique-error");
    } else if (severity === "mismatch") {
      element.addClass("mitre-technique-warning");
    }
  }
  /**
   * Create a count badge with hover tooltip showing card details.
   *
   * When hovering over the count badge, displays a tooltip with information
   * about the IOC cards that reference this technique, including:
   * - Card type (with icon color)
   * - Card value/identifier
   * - Tactic and technique specified in the card
   *
   * @param parentEl - Parent element to attach the badge to
   * @param technique - Technique object with count and iocCards array
   */
  createCountBadgeWithTooltip(parentEl, technique) {
    const badge = parentEl.createDiv("mitre-technique-count-badge");
    badge.textContent = `${technique.count} card${technique.count > 1 ? "s" : ""}`;
    const tooltip = badge.createDiv("mitre-count-tooltip");
    tooltip.style.display = "none";
    technique.iocCards.forEach((cardId, index) => {
      const iocData = this.iocDataMap.get(cardId);
      if (!iocData)
        return;
      const cardItem = tooltip.createDiv("mitre-tooltip-card");
      const iocType = Object.values(IOC_TYPES).find((t) => t.name === iocData.type);
      const typeColor = (iocType == null ? void 0 : iocType.color) || "#888";
      const typeEl = cardItem.createDiv("mitre-tooltip-type");
      typeEl.style.color = typeColor;
      typeEl.style.fontWeight = "bold";
      typeEl.textContent = iocData.type;
      if (iocData.value) {
        const valueEl = cardItem.createDiv("mitre-tooltip-value");
        valueEl.textContent = iocData.value;
      }
      if (iocData.mitreTactic || iocData.mitreTechnique) {
        const mitreEl = cardItem.createDiv("mitre-tooltip-fields");
        if (iocData.mitreTactic) {
          mitreEl.createSpan({ text: `Tactic: ${iocData.mitreTactic}` });
        }
        if (iocData.mitreTechnique) {
          if (iocData.mitreTactic)
            mitreEl.createSpan({ text: " | " });
          mitreEl.createSpan({ text: `Technique: ${iocData.mitreTechnique}` });
        }
      }
      if (index < technique.iocCards.length - 1) {
        cardItem.style.borderBottom = "1px solid var(--background-modifier-border)";
        cardItem.style.paddingBottom = "8px";
        cardItem.style.marginBottom = "8px";
      }
    });
    badge.addEventListener("mouseenter", () => {
      tooltip.style.display = "block";
    });
    badge.addEventListener("mouseleave", () => {
      tooltip.style.display = "none";
    });
    console.debug("[MitreModal]   \u2192 Count badge with tooltip:", technique.count, "card(s)");
  }
  /**
   * Check if a technique should be highlighted as the active selection.
   * Handles both direct matches and parent-child relationships.
   *
   * When a subtechnique is selected (e.g., T1566.001), both the subtechnique
   * AND its parent (T1566) should be highlighted in purple.
   *
   * @param techniqueId - The technique ID to check (e.g., "T1566" or "T1566.001")
   * @returns true if this technique should be highlighted in purple
   */
  isActiveTechnique(techniqueId) {
    if (!this.activeTechniqueId)
      return false;
    if (techniqueId === this.activeTechniqueId)
      return true;
    if (this.activeTechniqueId.includes(".")) {
      const parentId = this.activeTechniqueId.split(".")[0];
      if (techniqueId === parentId)
        return true;
    }
    return false;
  }
  /**
   * Clean MITRE description text by removing markdown links and square brackets.
   *
   * @param description - Raw description from MITRE dataset
   * @returns Cleaned description text
   */
  cleanDescription(description) {
    if (!description)
      return "";
    let cleaned = description;
    cleaned = cleaned.replace(/\[([^\]]+)\]\([^)]+\)/g, "");
    cleaned = cleaned.replace(/\[[^\]]*\]/g, "");
    cleaned = cleaned.replace(/\s+/g, " ").trim();
    return cleaned;
  }
  /**
   * Truncate description to maximum character length with ellipsis.
   *
   * @param description - Cleaned description text
   * @param maxChars - Maximum characters (default: 180)
   * @returns Truncated description with "..." if needed
   */
  truncateDescription(description, maxChars = 180) {
    if (!description || description.length <= maxChars) {
      return description;
    }
    const truncated = description.substring(0, maxChars);
    const lastSpace = truncated.lastIndexOf(" ");
    if (lastSpace > 0) {
      return truncated.substring(0, lastSpace) + "...";
    }
    return truncated + "...";
  }
  /**
   * Toggle expansion (expand/collapse) for techniques or subtechniques.
   * Handles description swap and optional subtechniques rendering.
   *
   * @param element - The technique/subtechnique DOM element
   * @param subtechniques - Subtechniques to render (only for parent techniques)
   */
  toggleExpansion(element, subtechniques) {
    var _a, _b, _c;
    const isCollapsed = element.hasClass("collapsed");
    const expandIcon = element.querySelector(".mitre-expand-icon");
    const descEl = element.querySelector(".mitre-technique-description");
    if (isCollapsed) {
      element.removeClass("collapsed");
      element.addClass("expanded");
      element.setAttribute("data-is-expanded", "true");
      if (expandIcon)
        expandIcon.setText("\u25BC");
      if (subtechniques && subtechniques.length > 0) {
        this.renderSubtechniques(element, subtechniques, this.currentSearchState);
      }
      if (descEl) {
        const fullDesc = element.getAttribute("data-full-description");
        if (fullDesc) {
          descEl.textContent = fullDesc;
          if ((_a = this.currentSearchState) == null ? void 0 : _a.isActive) {
            this.highlightMatches(descEl, fullDesc, this.currentSearchState);
          }
        }
      }
    } else {
      element.removeClass("expanded");
      element.addClass("collapsed");
      element.setAttribute("data-is-expanded", "false");
      if (expandIcon)
        expandIcon.setText("\u25B6");
      (_b = element.querySelector(".mitre-subtechniques-container")) == null ? void 0 : _b.remove();
      if (descEl) {
        const fullDesc = element.getAttribute("data-full-description");
        const truncatedDesc = element.getAttribute("data-truncated-description");
        const displayText = truncatedDesc || (fullDesc ? this.truncateDescription(fullDesc) : null);
        if (displayText) {
          descEl.textContent = displayText;
          if ((_c = this.currentSearchState) == null ? void 0 : _c.isActive) {
            this.highlightMatches(descEl, displayText, this.currentSearchState);
          }
        }
      }
    }
  }
  /**
   * Load MITRE dataset asynchronously
   */
  async loadDataset() {
    try {
      this.mitreDataset = await loadMitreDataset(this.app);
      console.debug("[MitreModal] Dataset loaded:", this.mitreDataset.version, "- Techniques:", Object.keys(this.mitreDataset.techniques).length);
    } catch (err) {
      console.error("[MitreModal] Failed to load dataset:", err);
      this.mitreDataset = null;
    }
  }
  onOpen() {
    console.debug("[MitreModal] ===== MODAL OPENED =====");
    const { contentEl } = this;
    this.modalEl.classList.add("mitre-modal-fullscreen");
    this.makeResizable();
    const headerContainer = contentEl.createDiv("mitre-modal-header");
    const titleRow = headerContainer.createDiv("mitre-title-row");
    titleRow.createEl("h2", { text: "\u{1F3AF} MITRE ATT&CK Technique Mapper" });
    const exportBtn = titleRow.createEl("button", {
      text: "Export to Navigator",
      cls: "mitre-export-button"
    });
    exportBtn.addEventListener("click", () => this.exportToNavigator());
    this.renderSearchBar(headerContainer);
    const statsContainer = contentEl.createDiv("mitre-stats");
    const contentArea = contentEl.createDiv("mitre-content-area");
    this.renderMitreMapping(contentArea, statsContainer);
  }
  /**
   * Render search bar in modal header.
   *
   * @param headerContainer - Header container element
   */
  renderSearchBar(headerContainer) {
    const searchContainer = headerContainer.createDiv("mitre-search-container");
    const searchInput = searchContainer.createEl("input", {
      type: "text",
      placeholder: 'Search techniques (use "quotes" for exact phrases)...',
      cls: "mitre-search-input"
    });
    const clearButton = searchContainer.createEl("button", {
      text: "\u2715",
      cls: "mitre-search-clear",
      attr: { "aria-label": "Clear search" }
    });
    clearButton.style.display = "none";
    const matchCount = searchContainer.createDiv("mitre-search-match-count");
    matchCount.style.display = "none";
    this.searchBar = searchInput;
    this.searchClearButton = clearButton;
    this.searchMatchCount = matchCount;
    let debounceTimer = null;
    searchInput.addEventListener("input", () => {
      if (debounceTimer !== null) {
        clearTimeout(debounceTimer);
      }
      debounceTimer = window.setTimeout(() => {
        this.handleSearchInput(searchInput.value);
      }, 300);
    });
    clearButton.addEventListener("click", () => {
      searchInput.value = "";
      this.handleSearchInput("");
    });
    searchInput.addEventListener("keydown", (e) => {
      if (e.key === "Escape") {
        searchInput.value = "";
        this.handleSearchInput("");
      }
    });
  }
  /**
   * Handle search input changes and re-render content.
   *
   * @param query - Search query string
   */
  handleSearchInput(query) {
    const searchState = this.parseSearchQuery(query);
    this.currentSearchState = searchState;
    console.debug("[MitreModal] Search query:", query, "- Parsed:", searchState);
    if (this.searchClearButton) {
      this.searchClearButton.style.display = searchState.isActive ? "block" : "none";
    }
    const container = this.modalEl.querySelector(".mitre-content-area");
    if (container && this.currentTactics) {
      container.empty();
      let matchCount = 0;
      this.currentTactics.forEach((tactic) => {
        const matchingTechniques = tactic.techniques.filter((tech) => {
          if (!searchState.isActive)
            return true;
          const match = this.matchesSearch(tech, searchState);
          if (match.matched)
            matchCount++;
          return match.matched;
        });
        if (matchingTechniques.length > 0) {
          const filteredTactic = { ...tactic, techniques: matchingTechniques };
          this.renderTacticSection(container, filteredTactic, searchState);
        }
      });
      if (this.searchMatchCount) {
        if (searchState.isActive) {
          this.searchMatchCount.textContent = `${matchCount} technique${matchCount !== 1 ? "s" : ""} found`;
          this.searchMatchCount.style.display = "block";
        } else {
          this.searchMatchCount.style.display = "none";
        }
      }
      if (matchCount === 0 && searchState.isActive) {
        container.createDiv({
          cls: "mitre-no-results",
          text: "No techniques match your search"
        });
      }
    }
  }
  async renderMitreMapping(container, statsContainer) {
    console.debug("[MitreModal] ===== STARTING DATA EXTRACTION =====");
    const iocData = this.timeProcessor.extractFixedIOCData();
    console.debug("[MitreModal] Extracted IOC count:", iocData.length);
    if (iocData.length === 0) {
      container.createEl("p", {
        text: "No IOC cards found in the current canvas.",
        cls: "mitre-empty-message"
      });
      return;
    }
    const tactics = await this.aggregateTacticsTechniques(iocData);
    console.debug("[MitreModal] ===== AGGREGATION COMPLETE =====");
    console.debug("[MitreModal] Tactics:", tactics.length);
    if (!this.mitreDataset) {
      container.createEl("div", {
        cls: "mitre-error-message",
        text: "\u274C MITRE ATT&CK dataset could not be loaded."
      });
      container.createEl("p", {
        text: "Please ensure enterprise-attack.json exists in the MITRE folder."
      });
      container.createEl("a", {
        text: "Download dataset from MITRE",
        attr: { href: "https://github.com/mitre-attack/attack-stix-data", target: "_blank" }
      });
      return;
    }
    if (tactics.length === 0) {
      container.createEl("p", {
        text: 'No MITRE tactics or techniques found in IOC cards. Add "Mitre Tactic" and "Mitre Technique" fields to your cards.',
        cls: "mitre-empty-message"
      });
      return;
    }
    const totalTechniques = tactics.reduce((sum, t) => sum + t.techniques.length, 0);
    const foundTechniques = tactics.reduce((sum, t) => sum + t.techniques.filter((tech) => tech.isFound).length, 0);
    const coveragePercent = totalTechniques > 0 ? Math.round(foundTechniques / totalTechniques * 100) : 0;
    statsContainer.createEl("div", {
      text: `\u{1F4CA} Coverage: ${foundTechniques}/${totalTechniques} techniques (${coveragePercent}%)`,
      cls: "mitre-stat-item"
    });
    const activeTactics = tactics.filter((t) => t.techniques.some((tech) => tech.isFound)).length;
    statsContainer.createEl("div", {
      text: `\u2694\uFE0F Tactics: ${activeTactics}/${tactics.length} active`,
      cls: "mitre-stat-item"
    });
    statsContainer.createEl("div", {
      text: `\u{1F4C7} IOC Cards: ${iocData.length} total`,
      cls: "mitre-stat-item"
    });
    this.currentTactics = tactics;
    this.renderValidationErrors(container);
    console.debug("[MitreModal] \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557");
    console.debug("[MitreModal] \u2551          RENDERING MITRE MATRIX                            \u2551");
    console.debug("[MitreModal] \u255A\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255D");
    tactics.forEach((tactic) => {
      this.renderTacticSection(container, tactic, this.currentSearchState);
    });
    console.debug("[MitreModal] \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557");
    console.debug("[MitreModal] \u2551          MATRIX RENDERING COMPLETE                         \u2551");
    console.debug("[MitreModal] \u255A\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255D");
    console.debug("[MitreModal] Summary:");
    console.debug("[MitreModal]   - Total tactics:", tactics.length);
    console.debug("[MitreModal]   - Total techniques:", totalTechniques);
    console.debug("[MitreModal]   - Found techniques:", foundTechniques);
    console.debug("[MitreModal]   - Coverage:", coveragePercent + "%");
  }
  /**
   * Render validation errors section with card references.
   * Groups errors by type (Tactic Errors, Technique Errors, Validation Mismatches).
   *
   * @param container - Container element for error section
   */
  renderValidationErrors(container) {
    if (this.validationErrors.length === 0) {
      return;
    }
    console.debug("[MitreModal] Rendering", this.validationErrors.length, "validation errors");
    const emptyTacticErrors = this.validationErrors.filter((e) => e.severity === "empty_tactic");
    const tacticErrors = this.validationErrors.filter((e) => e.severity === "unknown_tactic");
    const techniqueErrors = this.validationErrors.filter((e) => e.severity === "unknown_technique");
    const mismatchErrors = this.validationErrors.filter((e) => e.severity === "mismatch");
    const errorSection = container.createDiv("mitre-validation-errors");
    const header = errorSection.createDiv("mitre-errors-header");
    header.createEl("h3", {
      text: `\u26A0\uFE0F Validation Issues (${this.validationErrors.length})`
    });
    const toggleBtn = header.createEl("button", {
      text: "Hide",
      cls: "mitre-errors-toggle"
    });
    const errorsList = errorSection.createDiv("mitre-errors-list");
    errorSection.addClass("expanded");
    toggleBtn.addEventListener("click", () => {
      if (errorSection.hasClass("expanded")) {
        errorSection.removeClass("expanded");
        errorSection.addClass("collapsed");
        toggleBtn.setText("Show");
        errorsList.style.display = "none";
      } else {
        errorSection.removeClass("collapsed");
        errorSection.addClass("expanded");
        toggleBtn.setText("Hide");
        errorsList.style.display = "block";
      }
    });
    if (emptyTacticErrors.length > 0) {
      this.renderErrorCategory(errorsList, "Missing Tactic", emptyTacticErrors, "\u{1F534}");
    }
    if (tacticErrors.length > 0) {
      this.renderErrorCategory(errorsList, "Unknown Tactic", tacticErrors, "\u{1F534}");
    }
    if (techniqueErrors.length > 0) {
      this.renderErrorCategory(errorsList, "Technique Errors", techniqueErrors, "\u{1F534}");
    }
    if (mismatchErrors.length > 0) {
      this.renderErrorCategory(errorsList, "Validation Mismatches", mismatchErrors, "\u26A0\uFE0F");
    }
  }
  /**
   * Render a category of validation errors with header and items.
   *
   * @param container - Parent container element
   * @param categoryTitle - Display title for this error category
   * @param errors - Array of errors in this category
   * @param icon - Icon to use for this category
   */
  renderErrorCategory(container, categoryTitle, errors, icon) {
    const categorySection = container.createDiv("mitre-error-category");
    const categoryHeader = categorySection.createDiv("mitre-error-category-header");
    categoryHeader.createEl("h4", {
      text: `${icon} ${categoryTitle} (${errors.length})`
    });
    errors.forEach((error) => {
      const errorItem = categorySection.createDiv("mitre-error-item");
      if (this.isCriticalSeverity(error.severity)) {
        errorItem.addClass("mitre-error-critical");
      } else if (error.severity === "mismatch") {
        errorItem.addClass("mitre-error-warning");
      }
      const errorHeader = errorItem.createDiv("mitre-error-header");
      errorHeader.createEl("span", {
        text: error.techniqueId,
        cls: "mitre-error-technique-id"
      });
      errorHeader.createEl("span", {
        text: error.techniqueName,
        cls: "mitre-error-technique-name"
      });
      errorItem.createDiv({
        text: error.message,
        cls: "mitre-error-message"
      });
      const cardsSection = errorItem.createDiv("mitre-error-cards");
      cardsSection.createEl("span", {
        text: "Affected cards: ",
        cls: "mitre-error-cards-label"
      });
      error.iocCards.forEach((card, index) => {
        const cardBadge = cardsSection.createEl("span", {
          cls: "mitre-error-card-badge",
          attr: { "title": `Node ID: ${card.nodeId}` }
        });
        cardBadge.createEl("span", {
          text: card.iocType,
          cls: "mitre-error-card-type"
        });
        cardBadge.createEl("span", {
          text: ` ${card.cardId}`,
          cls: "mitre-error-card-id"
        });
        if (index < error.iocCards.length - 1) {
          cardsSection.createEl("span", { text: ", " });
        }
      });
    });
  }
  /**
   * Determines if newSeverity should override existingSeverity when aggregating.
   *
   * When multiple IOC cards reference the same technique with different validation
   * results, we need to decide which severity to display in the matrix. This uses
   * a priority ranking system where more critical errors override less critical ones.
   *
   * **Ranking (highest to lowest priority):**
   * 1. `unknown_technique` (5) - Technique ID not in dataset (CRITICAL - red)
   * 2. `unknown_tactic` (4) - Tactic name not recognized (CRITICAL - red)
   * 3. `empty_tactic` (3) - Technique filled but tactic empty (CRITICAL - red)
   * 4. `mismatch` (2) - Both valid but don't belong together (WARNING - orange)
   * 5. `valid` (1) - Correct pairing (SUCCESS - green)
   *
   * **Example:** If 3 cards reference T1566, one with valid pairing, one with mismatch,
   * and one with unknown_tactic, the final severity shown is `unknown_tactic` (highest rank).
   *
   * @param newSeverity - Severity from newly processed card
   * @param existingSeverity - Current aggregated severity for this technique
   * @returns true if newSeverity should replace existingSeverity
   */
  shouldOverrideSeverity(newSeverity, existingSeverity) {
    const severityRank = {
      "unknown_technique": 5,
      // Red - technique doesn't exist
      "unknown_tactic": 4,
      // Red - tactic name/abbrev not found
      "empty_tactic": 3,
      // Red - missing required field
      "mismatch": 2,
      // Orange - wrong tactic for technique
      "valid": 1
      // Green - correct pairing
    };
    return severityRank[newSeverity] > severityRank[existingSeverity];
  }
  /**
   * Mark parent technique as found when a subtechnique is referenced.
   *
   * When an analyst specifies a subtechnique like T1053.005 in an IOC card,
   * both the subtechnique AND its parent technique (T1053) should be highlighted
   * in the MITRE matrix. This helper ensures the parent is also tracked in the
   * foundTechniques map.
   *
   * The parent inherits the count from its subtechniques but does NOT include
   * the IOC card IDs directly (since the card referenced the subtechnique, not
   * the parent). This allows the parent to show a count badge while keeping
   * accurate card tracking at the subtechnique level.
   *
   * @param techniqueId - The technique ID that was found (may be subtechnique)
   * @param foundTechniques - The map tracking all found techniques
   * @param tactic - The user-provided tactic string
   */
  markParentAsFound(techniqueId, foundTechniques, tactic) {
    if (!techniqueId.includes("."))
      return;
    const parentId = techniqueId.split(".")[0];
    if (foundTechniques.has(parentId)) {
      const existing = foundTechniques.get(parentId);
      existing.count++;
    } else {
      foundTechniques.set(parentId, {
        count: 1,
        iocCards: [],
        // Empty - cards reference subtechniques, not parent
        severity: "valid",
        validationMessage: void 0,
        userProvidedTactic: tactic
      });
    }
    console.debug("[MitreModal] Marked parent technique as found:", {
      subtechnique: techniqueId,
      parent: parentId,
      tactic
    });
  }
  /**
   * Aggregate MITRE tactics and techniques from IOC cards into full matrix structure.
   *
   * This is the core aggregation algorithm that builds the complete MITRE ATT&CK matrix
   * showing ALL 14 tactics and ALL ~800+ techniques, with found techniques highlighted
   * and validated. Uses a 5-step process for building the matrix and collecting errors.
   *
   * **Algorithm Overview:**
   * 1. Build map of found techniques from IOC cards (with validation per card)
   * 2. Build full tactic structure from dataset (all 14 tactics)
   * 3. Populate ALL techniques from dataset (found and unfound)
   * 4. Convert to array and sort by kill chain order
   * 5. Collect validation errors for display
   *
   * @param iocData - Array of parsed IOC nodes from canvas
   * @returns Array of MitreTactic objects with nested techniques
   */
  async aggregateTacticsTechniques(iocData) {
    if (!this.mitreDataset) {
      await this.loadDataset();
    }
    if (!this.mitreDataset) {
      console.error("[MitreModal] Failed to load dataset");
      return [];
    }
    console.log("[MitreModal] Starting full matrix aggregation with", iocData.length, "IOC cards");
    console.log("[MitreModal] Dataset has", Object.keys(this.mitreDataset.techniques).length, "techniques");
    this.iocDataMap.clear();
    iocData.forEach((ioc) => {
      this.iocDataMap.set(ioc.id, ioc);
    });
    const foundTechniques = /* @__PURE__ */ new Map();
    const cardValidations = /* @__PURE__ */ new Map();
    iocData.forEach((ioc) => {
      const rawTactic = (ioc.tactic || "").trim();
      const rawTechnique = (ioc.technique || "").trim();
      console.debug("[MitreModal] Processing IOC card:", {
        cardId: ioc.cardId || "(no ID)",
        type: ioc.type,
        nodeId: ioc.id,
        rawTactic: rawTactic || "(empty)",
        rawTechnique: rawTechnique || "(empty)"
      });
      if (!rawTechnique) {
        console.debug("[MitreModal] Skipping IOC card with empty technique:", {
          id: ioc.id,
          cardId: ioc.cardId || "(no ID)",
          type: ioc.type,
          hasTactic: !!rawTactic,
          hasTechnique: false,
          tacticValue: rawTactic || "(empty)",
          techniqueValue: "(empty)"
        });
        return;
      }
      const technique = rawTechnique;
      const techniqueId = this.extractTechniqueId(technique);
      const techniqueName = this.extractTechniqueName(technique);
      if (!rawTactic) {
        console.debug("[MitreModal] Found IOC card with empty tactic:", {
          id: ioc.id,
          cardId: ioc.cardId || "(no ID)",
          type: ioc.type,
          techniqueId,
          technique
        });
        const validation2 = {
          severity: "empty_tactic",
          message: "Tactic field is empty",
          tacticId: void 0
        };
        cardValidations.set(ioc.id, {
          cardId: ioc.cardId || ioc.id,
          techniqueId,
          techniqueName,
          tactic: "(empty)",
          severity: validation2.severity,
          validationMessage: validation2.message,
          iocType: ioc.type,
          nodeId: ioc.id
        });
        if (foundTechniques.has(techniqueId)) {
          const existing = foundTechniques.get(techniqueId);
          existing.count++;
          existing.iocCards.push(ioc.id);
          if (this.shouldOverrideSeverity(validation2.severity, existing.severity)) {
            existing.severity = validation2.severity;
            existing.validationMessage = validation2.message;
          }
        } else {
          foundTechniques.set(techniqueId, {
            count: 1,
            iocCards: [ioc.id],
            severity: validation2.severity,
            validationMessage: validation2.message,
            userProvidedTactic: "(empty)"
          });
        }
        this.markParentAsFound(techniqueId, foundTechniques, "(empty)");
        return;
      }
      const tactic = rawTactic;
      const validation = validateTechniqueTactic(techniqueId, tactic, this.mitreDataset);
      console.debug("[MitreModal] Validated technique:", {
        cardId: ioc.cardId || ioc.id,
        type: ioc.type,
        techniqueId,
        techniqueName,
        tactic,
        severity: validation.severity,
        message: validation.message || "valid"
      });
      cardValidations.set(ioc.id, {
        cardId: ioc.cardId || ioc.id,
        techniqueId,
        techniqueName,
        tactic,
        severity: validation.severity,
        validationMessage: validation.message,
        iocType: ioc.type,
        nodeId: ioc.id
      });
      if (foundTechniques.has(techniqueId)) {
        const existing = foundTechniques.get(techniqueId);
        existing.count++;
        existing.iocCards.push(ioc.id);
        if (this.shouldOverrideSeverity(validation.severity, existing.severity)) {
          existing.severity = validation.severity;
          existing.validationMessage = validation.message;
        }
      } else {
        foundTechniques.set(techniqueId, {
          count: 1,
          iocCards: [ioc.id],
          severity: validation.severity,
          validationMessage: validation.message,
          userProvidedTactic: tactic
        });
      }
      this.markParentAsFound(techniqueId, foundTechniques, tactic);
    });
    console.log("[MitreModal] Found", foundTechniques.size, "unique techniques in IOC cards");
    const tacticMap = /* @__PURE__ */ new Map();
    Object.values(this.mitreDataset.tactics).forEach((tacticData) => {
      tacticMap.set(tacticData.id, {
        name: tacticData.id,
        displayName: `${tacticData.name} (${tacticData.id})`,
        techniques: []
      });
    });
    this.subtechniquesMap.clear();
    Object.values(this.mitreDataset.techniques).forEach((techData) => {
      const foundData = foundTechniques.get(techData.id);
      const isFound = !!foundData;
      const techniqueObj = {
        id: techData.id,
        name: techData.name,
        tactic: "",
        // Will be set per-tactic below
        tacticId: "",
        // Will be set per-tactic below
        count: (foundData == null ? void 0 : foundData.count) || 0,
        iocCards: (foundData == null ? void 0 : foundData.iocCards) || [],
        severity: (foundData == null ? void 0 : foundData.severity) || "not_found",
        validationMessage: foundData == null ? void 0 : foundData.validationMessage,
        description: techData.description,
        isFound
      };
      if (techData.parent) {
        if (!this.subtechniquesMap.has(techData.parent)) {
          this.subtechniquesMap.set(techData.parent, []);
        }
        if (techData.tactics.length > 0) {
          techniqueObj.tactic = (foundData == null ? void 0 : foundData.userProvidedTactic) || techData.tactics[0];
          techniqueObj.tacticId = techData.tactics[0];
        }
        this.subtechniquesMap.get(techData.parent).push(techniqueObj);
        console.debug("[MitreModal] Added subtechnique:", {
          id: techData.id,
          parent: techData.parent,
          isFound,
          totalSubtechniques: this.subtechniquesMap.get(techData.parent).length
        });
        return;
      }
      techData.tactics.forEach((tacticId) => {
        if (!tacticMap.has(tacticId)) {
          console.warn("[MitreModal] Unknown tactic ID in dataset:", tacticId);
          return;
        }
        const tactic = tacticMap.get(tacticId);
        tactic.techniques.push({
          ...techniqueObj,
          tactic: (foundData == null ? void 0 : foundData.userProvidedTactic) || tacticId,
          tacticId
        });
      });
    });
    console.log("[MitreModal] Subtechniques aggregation complete:");
    this.subtechniquesMap.forEach((subs, parentId) => {
      const foundCount = subs.filter((s) => s.isFound).length;
      console.log(`  ${parentId}: ${subs.length} total (${foundCount} found, ${subs.length - foundCount} unfound)`);
    });
    const tactics = Array.from(tacticMap.values());
    const tacticOrder = [
      "TA0043",
      // Reconnaissance
      "TA0042",
      // Resource Development
      "TA0001",
      // Initial Access
      "TA0002",
      // Execution
      "TA0003",
      // Persistence
      "TA0004",
      // Privilege Escalation
      "TA0005",
      // Defense Evasion
      "TA0006",
      // Credential Access
      "TA0007",
      // Discovery
      "TA0008",
      // Lateral Movement
      "TA0009",
      // Collection
      "TA0011",
      // Command and Control
      "TA0010",
      // Exfiltration
      "TA0040"
      // Impact
    ];
    tactics.sort((a, b) => {
      const indexA = tacticOrder.indexOf(a.name);
      const indexB = tacticOrder.indexOf(b.name);
      if (indexA === -1)
        return 1;
      if (indexB === -1)
        return -1;
      return indexA - indexB;
    });
    tactics.forEach((tactic) => {
      tactic.techniques.sort((a, b) => {
        if (a.isFound && !b.isFound)
          return -1;
        if (!a.isFound && b.isFound)
          return 1;
        return a.id.localeCompare(b.id);
      });
    });
    console.log("[MitreModal] Full matrix built:", {
      totalTactics: tactics.length,
      totalTechniques: tactics.reduce((sum, t) => sum + t.techniques.length, 0),
      foundTechniques: foundTechniques.size
    });
    console.log("[MitreModal] Collecting validation errors from card-level validation...");
    this.validationErrors = [];
    const errorsByTechnique = /* @__PURE__ */ new Map();
    cardValidations.forEach((cardValidation, cardId) => {
      if (cardValidation.severity !== "valid") {
        const key = `${cardValidation.techniqueId}-${cardValidation.severity}`;
        if (!errorsByTechnique.has(key)) {
          errorsByTechnique.set(key, {
            techniqueId: cardValidation.techniqueId,
            techniqueName: cardValidation.techniqueName,
            severity: cardValidation.severity,
            message: cardValidation.validationMessage || "Validation error",
            cards: []
          });
        }
        errorsByTechnique.get(key).cards.push({
          cardId: cardValidation.cardId,
          iocType: cardValidation.iocType,
          nodeId: cardValidation.nodeId
        });
      }
    });
    errorsByTechnique.forEach((errorData) => {
      this.validationErrors.push({
        techniqueId: errorData.techniqueId,
        techniqueName: errorData.techniqueName,
        severity: errorData.severity,
        message: errorData.message,
        iocCards: errorData.cards
      });
    });
    console.log("[MitreModal] Found", this.validationErrors.length, "validation error groups from", cardValidations.size, "cards");
    console.log("[MitreModal] Cards with errors:", Array.from(cardValidations.values()).filter((v) => v.severity !== "valid").length);
    return tactics;
  }
  /**
   * Extract technique ID from various formats.
   *
   * Supported formats:
   * - "T1566" -> "T1566"
   * - "T1566.001" -> "T1566.001"
   * - "T1566 - Phishing" -> "T1566"
   * - "Phishing (T1566)" -> "T1566"
   * - "T1566.001 - Spearphishing Attachment" -> "T1566.001"
   * - "Phishing" (name only) -> "Phishing" (fallback, will fail validation)
   *
   * NOTE: Technique field is already uppercased by IOCParser for consistency
   */
  extractTechniqueId(technique) {
    const idMatch = technique.match(/T\d{4}(?:\.\d{3})?/i);
    if (idMatch) {
      const techniqueId = idMatch[0].toUpperCase();
      console.debug("[MitreModal] Extracted technique ID:", techniqueId, "from:", technique);
      return techniqueId;
    }
    console.debug("[MitreModal] No technique ID found in:", technique, "- using raw string");
    return technique.trim();
  }
  /**
   * Extract technique name from various formats.
   *
   * Supported formats:
   * - "T1566 - Phishing" -> "Phishing"
   * - "Phishing (T1566)" -> "Phishing"
   * - "T1566.001 - Spearphishing Attachment" -> "Spearphishing Attachment"
   * - "T1566" (ID only) -> lookup name from MitreData
   * - "Phishing" (name only) -> "Phishing"
   */
  extractTechniqueName(technique) {
    const dashMatch = technique.match(/T\d{4}(?:\.\d{3})?\s*-\s*(.+)/);
    if (dashMatch) {
      const name = dashMatch[1].trim();
      console.debug("[MitreModal] Extracted name from dash format:", name);
      return name;
    }
    const parenMatch = technique.match(/(.+?)\s*\(T\d{4}(?:\.\d{3})?\)/);
    if (parenMatch) {
      const name = parenMatch[1].trim();
      console.debug("[MitreModal] Extracted name from paren format:", name);
      return name;
    }
    const idOnlyMatch = technique.match(/^T\d{4}(?:\.\d{3})?$/);
    if (idOnlyMatch && this.mitreDataset) {
      const techData = this.mitreDataset.techniques[idOnlyMatch[0]];
      if (techData) {
        console.debug("[MitreModal] Looked up name for ID:", idOnlyMatch[0], "->", techData.name);
        return techData.name;
      }
    }
    console.debug("[MitreModal] Using raw technique string as name:", technique);
    return technique.trim();
  }
  renderTacticSection(container, tactic, searchState) {
    console.debug("[MitreModal] ========== RENDERING TACTIC SECTION ==========");
    console.debug("[MitreModal] Tactic:", tactic.displayName || tactic.name);
    console.debug("[MitreModal] Total techniques:", tactic.techniques.length);
    const tacticColumn = container.createDiv("mitre-tactic-column");
    const foundCount = tactic.techniques.filter((t) => t.isFound).length;
    const totalCount = tactic.techniques.length;
    console.debug("[MitreModal] Found techniques:", foundCount, "/", totalCount);
    const tacticHeader = tacticColumn.createDiv("mitre-tactic-header");
    tacticHeader.createEl("h3", { text: `\u2694\uFE0F ${tactic.displayName || tactic.name}` });
    tacticHeader.createEl("span", {
      text: `${foundCount} active / ${totalCount} total techniques`,
      cls: "mitre-technique-count"
    });
    const techniqueList = tacticColumn.createDiv("mitre-technique-list");
    tactic.techniques.forEach((technique, index) => {
      console.debug("[MitreModal] Rendering technique", index + 1, ":", {
        id: technique.id,
        name: technique.name,
        isFound: technique.isFound,
        severity: technique.severity,
        count: technique.count,
        iocCards: technique.iocCards.length
      });
      const techItem = techniqueList.createDiv("mitre-technique-item");
      const subtechniques = this.subtechniquesMap.get(technique.id) || [];
      const hasSubtechniques = subtechniques.length > 0;
      const cleanedDesc = this.cleanDescription(technique.description || "");
      const isLongDescription = cleanedDesc.length > 180;
      const isExpandable = isLongDescription || hasSubtechniques;
      techItem.setAttribute("data-technique-id", technique.id);
      techItem.setAttribute("data-subtechnique-count", subtechniques.length.toString());
      techItem.setAttribute("data-is-expandable", isExpandable.toString());
      techItem.setAttribute("data-full-description", cleanedDesc);
      if (isLongDescription) {
        const truncated = this.truncateDescription(cleanedDesc);
        techItem.setAttribute("data-truncated-description", truncated);
      }
      const isActive = this.isActiveTechnique(technique.id);
      if (isActive) {
        console.debug("[MitreModal]   \u2713 Marking as ACTIVE (purple)");
        techItem.addClass("mitre-technique-active");
      }
      if (!technique.isFound) {
        console.debug("[MitreModal]   \u2192 Styling: UNFOUND (gray)");
        techItem.addClass("mitre-technique-unfound");
      } else {
        console.debug("[MitreModal]   \u2192 Styling: FOUND with severity:", technique.severity);
        this.applySeverityClass(techItem, technique.severity);
        if (technique.severity === "valid") {
          console.debug("[MitreModal]   \u2192 CSS class: mitre-technique-valid (PURPLE)");
        } else if (this.isCriticalSeverity(technique.severity)) {
          console.debug("[MitreModal]   \u2192 CSS class: mitre-technique-error (RED)");
        } else if (technique.severity === "mismatch") {
          console.debug("[MitreModal]   \u2192 CSS class: mitre-technique-warning (ORANGE)");
        }
      }
      const techInfo = techItem.createDiv("mitre-technique-info");
      if (isExpandable) {
        const expandIcon = techInfo.createEl("span", {
          cls: "mitre-expand-icon",
          text: "\u25B6"
        });
        techItem.addClass("has-expandable");
        techItem.addClass("collapsed");
        techItem.addEventListener("click", (e) => {
          e.stopPropagation();
          this.toggleExpansion(techItem, subtechniques);
        });
      }
      if (technique.isFound && technique.severity !== "valid" && technique.severity !== "not_found") {
        const warningEl = techInfo.createEl("span", {
          cls: "mitre-validation-icon",
          attr: {
            "title": technique.validationMessage || "Warning"
          }
        });
        warningEl.innerHTML = this.getSeverityIcon(technique.severity);
      }
      techInfo.createEl("span", {
        text: technique.id,
        cls: "mitre-technique-id"
      });
      const nameText = hasSubtechniques ? `${technique.name} (${subtechniques.length})` : technique.name;
      const nameEl = techInfo.createEl("span", {
        text: nameText,
        cls: "mitre-technique-name"
      });
      if (searchState == null ? void 0 : searchState.isActive) {
        this.highlightMatches(nameEl, technique.name, searchState);
      }
      if (technique.description) {
        const descEl = techItem.createDiv("mitre-technique-description");
        const isExpanded = techItem.hasClass("expanded");
        let displayText;
        if (isExpanded || !isExpandable) {
          displayText = cleanedDesc;
        } else {
          displayText = this.truncateDescription(cleanedDesc);
        }
        descEl.textContent = displayText;
        if (searchState == null ? void 0 : searchState.isActive) {
          this.highlightMatches(descEl, displayText, searchState);
        }
      }
      if (technique.isFound) {
        this.createCountBadgeWithTooltip(techItem, technique);
      }
    });
    console.debug("[MitreModal] ========== TACTIC RENDERING COMPLETE ==========");
  }
  renderSubtechniques(parentEl, subtechniques, searchState) {
    const container = parentEl.createDiv({ cls: "mitre-subtechniques-container" });
    subtechniques.forEach((subtech) => {
      const subItem = container.createDiv("mitre-technique-item mitre-subtechnique");
      const cleanedDesc = this.cleanDescription(subtech.description || "");
      const isLongDescription = cleanedDesc.length > this.SUBTECHNIQUE_TRUNCATE_LIMIT;
      subItem.setAttribute("data-technique-id", subtech.id);
      subItem.setAttribute("data-full-description", cleanedDesc);
      if (isLongDescription) {
        const truncated = this.truncateDescription(cleanedDesc, this.SUBTECHNIQUE_TRUNCATE_LIMIT);
        subItem.setAttribute("data-truncated-description", truncated);
      }
      const isActive = this.isActiveTechnique(subtech.id);
      if (isActive) {
        subItem.addClass("mitre-technique-active");
      }
      if (!subtech.isFound) {
        subItem.addClass("mitre-technique-unfound");
      } else {
        this.applySeverityClass(subItem, subtech.severity);
      }
      const subInfo = subItem.createDiv("mitre-technique-info");
      if (isLongDescription) {
        const expandIcon = subInfo.createEl("span", {
          cls: "mitre-expand-icon",
          text: "\u25B6"
        });
        subItem.addClass("has-expandable");
        subItem.addClass("collapsed");
        subItem.addEventListener("click", (e) => {
          e.stopPropagation();
          this.toggleExpansion(subItem);
        });
      }
      if (subtech.isFound && subtech.severity !== "valid" && subtech.severity !== "not_found") {
        const warningEl = subInfo.createEl("span", {
          cls: "mitre-validation-icon",
          attr: {
            "title": subtech.validationMessage || "Warning"
          }
        });
        warningEl.innerHTML = this.getSeverityIcon(subtech.severity);
      }
      subInfo.createEl("span", {
        text: subtech.id,
        cls: "mitre-technique-id"
      });
      const nameEl = subInfo.createEl("span", {
        text: subtech.name,
        cls: "mitre-technique-name"
      });
      if (searchState == null ? void 0 : searchState.isActive) {
        this.highlightMatches(nameEl, subtech.name, searchState);
      }
      if (subtech.description) {
        const descEl = subItem.createDiv("mitre-technique-description");
        let displayText;
        if (isLongDescription) {
          displayText = this.truncateDescription(cleanedDesc, this.SUBTECHNIQUE_TRUNCATE_LIMIT);
        } else {
          displayText = cleanedDesc;
        }
        descEl.textContent = displayText;
        if (searchState == null ? void 0 : searchState.isActive) {
          this.highlightMatches(descEl, displayText, searchState);
        }
      }
      if (subtech.isFound) {
        this.createCountBadgeWithTooltip(subItem, subtech);
      }
    });
  }
  /**
   * Parse search query into keywords and phrases.
   *
   * Supports two types of search terms:
   * 1. **Keywords**: Space-separated words (e.g., "spear phishing"  ["spear", "phishing"])
   * 2. **Phrases**: Quoted strings (e.g., "spear phishing"  ["spear phishing"])
   *
   * **Phrase Syntax:**
   * - Quoted phrases match exact sequences: "lateral movement" only matches that phrase
   * - Keywords match anywhere: lateral movement matches both separately
   * - Unmatched quotes are automatically removed (e.g., "spear phishing becomes spear phishing)
   *
   * **Algorithm:**
   * 1. Check for unmatched quotes and remove the last one
   * 2. Extract all quoted phrases using regex: /"([^"]+)"/g
   * 3. Remove phrases from query and split remaining text into keywords
   * 4. Normalize all terms to lowercase for case-insensitive matching
   *
   * @param query - Raw search query string
   * @returns SearchState object with parsed keywords and phrases
   */
  parseSearchQuery(query) {
    if (!query || !query.trim()) {
      return {
        query: "",
        keywords: [],
        phrases: [],
        isActive: false
      };
    }
    const trimmedQuery = query.trim();
    const quoteCount = (trimmedQuery.match(/"/g) || []).length;
    let processedQuery = trimmedQuery;
    if (quoteCount % 2 !== 0) {
      const lastQuoteIndex = processedQuery.lastIndexOf('"');
      processedQuery = processedQuery.substring(0, lastQuoteIndex) + processedQuery.substring(lastQuoteIndex + 1);
    }
    const phrases = [];
    const phraseRegex = /"([^"]+)"/g;
    let match;
    while ((match = phraseRegex.exec(processedQuery)) !== null) {
      phrases.push(match[1].toLowerCase());
    }
    const remainingQuery = processedQuery.replace(/"[^"]+"/g, " ");
    const keywords = remainingQuery.split(/\s+/).map((k) => k.trim().toLowerCase()).filter((k) => k.length > 0);
    return {
      query: trimmedQuery,
      keywords,
      phrases,
      isActive: keywords.length > 0 || phrases.length > 0
    };
  }
  /**
   * Check if text matches all keywords and phrases in search state.
   *
   * @param text - Text to check
   * @param searchState - Parsed search state
   * @returns True if text matches all search terms
   */
  textMatchesQuery(text, searchState) {
    if (!searchState.isActive)
      return true;
    const lowerText = text.toLowerCase();
    const allKeywordsMatch = searchState.keywords.every(
      (keyword) => lowerText.includes(keyword)
    );
    const allPhrasesMatch = searchState.phrases.every(
      (phrase) => lowerText.includes(phrase)
    );
    return allKeywordsMatch && allPhrasesMatch;
  }
  /**
   * Check if a technique matches the search query.
   *
   * **Search Hierarchy (checked in order):**
   * 1. **Technique ID** (e.g., "T1566") - highest priority, exact match
   * 2. **Technique Name** (e.g., "Phishing") - common use case
   * 3. **Technique Description** - finds techniques by their behavior description
   * 4. **Subtechniques** - if any subtechnique matches, show the parent too
   *
   * **Parent/Subtechnique Logic:**
   * When a subtechnique matches the search, the parent technique is also
   * included in results so the user can expand it and see the matching
   * subtechnique. For example, searching "spearphishing" will show T1566
   * (Phishing) with T1566.001 (Spearphishing Attachment) as an expandable child.
   *
   * **Match Precedence:**
   * Returns as soon as a match is found (short-circuits), prioritizing
   * more specific matches (ID > name > description > subtechnique).
   *
   * @param technique - Technique to check
   * @param searchState - Parsed search state with keywords/phrases
   * @returns SearchMatch result with match details
   */
  matchesSearch(technique, searchState) {
    if (!searchState.isActive) {
      return { matched: true };
    }
    if (this.textMatchesQuery(technique.id, searchState)) {
      return {
        matched: true,
        matchType: "id",
        matchText: technique.id
      };
    }
    if (this.textMatchesQuery(technique.name, searchState)) {
      return {
        matched: true,
        matchType: "name",
        matchText: technique.name
      };
    }
    if (technique.description && this.textMatchesQuery(technique.description, searchState)) {
      return {
        matched: true,
        matchType: "description",
        matchText: technique.description
      };
    }
    const subtechniques = this.subtechniquesMap.get(technique.id) || [];
    for (const subtech of subtechniques) {
      if (this.textMatchesQuery(subtech.id, searchState) || this.textMatchesQuery(subtech.name, searchState) || subtech.description && this.textMatchesQuery(subtech.description, searchState)) {
        return {
          matched: true,
          matchType: "subtechnique",
          matchText: subtech.name
        };
      }
    }
    return { matched: false };
  }
  /**
   * Escape HTML to prevent XSS injection.
   *
   * @param text - Text to escape
   * @returns HTML-escaped text
   */
  escapeHtml(text) {
    const div = document.createElement("div");
    div.textContent = text;
    return div.innerHTML;
  }
  /**
   * Escape special regex characters.
   *
   * @param text - Text to escape
   * @returns Regex-escaped text
   */
  escapeRegex(text) {
    return text.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  }
  /**
   * Highlight search matches in text element.
   *
   * @param element - DOM element to highlight
   * @param originalText - Original text content
   * @param searchState - Parsed search state
   */
  highlightMatches(element, originalText, searchState) {
    if (!searchState.isActive || !originalText) {
      return;
    }
    let escapedText = this.escapeHtml(originalText);
    searchState.phrases.forEach((phrase) => {
      const escapedPhrase = this.escapeRegex(phrase);
      const regex = new RegExp(`(${escapedPhrase})`, "gi");
      escapedText = escapedText.replace(regex, '<mark class="mitre-search-highlight">$1</mark>');
    });
    searchState.keywords.forEach((keyword) => {
      const escapedKeyword = this.escapeRegex(keyword);
      const regex = new RegExp(`(?!<mark[^>]*>)(${escapedKeyword})(?![^<]*</mark>)`, "gi");
      escapedText = escapedText.replace(regex, '<mark class="mitre-search-highlight">$1</mark>');
    });
    element.innerHTML = escapedText;
  }
  async exportToNavigator() {
    console.debug("[MitreModal] ===== EXPORTING =====");
    const iocData = this.timeProcessor.extractFixedIOCData();
    const tactics = await this.aggregateTacticsTechniques(iocData);
    const layer = {
      name: "Cyber Canvas IOC Analysis",
      versions: {
        attack: "14",
        navigator: "4.9.4",
        layer: "4.5"
      },
      domain: "enterprise-attack",
      description: `Generated from ${iocData.length} IOC cards in Obsidian Canvas`,
      filters: {
        platforms: ["windows", "linux", "macos"]
      },
      sorting: 0,
      layout: {
        layout: "side",
        aggregateFunction: "average",
        showID: true,
        showName: true,
        showAggregateScores: false,
        countUnscored: false
      },
      hideDisabled: false,
      techniques: [],
      gradient: {
        colors: ["#ff6666", "#ffe766", "#8ec843"],
        minValue: 0,
        maxValue: 100
      },
      legendItems: [],
      metadata: [],
      links: [],
      showTacticRowBackground: true,
      tacticRowBackground: "#dddddd",
      selectTechniquesAcrossTactics: true,
      selectSubtechniquesWithParent: false
    };
    tactics.forEach((tactic) => {
      tactic.techniques.forEach((technique) => {
        var _a;
        if (!technique.isFound) {
          return;
        }
        const tacticData = (_a = this.mitreDataset) == null ? void 0 : _a.tactics[technique.tacticId];
        const tacticShortName = (tacticData == null ? void 0 : tacticData.short_name) || tactic.name.toLowerCase().replace(/\s+/g, "-");
        let color;
        if (technique.severity === "valid") {
          color = "#66bb6a";
        } else if (this.isCriticalSeverity(technique.severity)) {
          color = "#f44336";
        } else if (technique.severity === "mismatch") {
          color = "#ffa500";
        } else {
          color = "#66bb6a";
        }
        let comment = `Used in ${technique.count} IOC card${technique.count > 1 ? "s" : ""}`;
        if (technique.severity !== "valid" && technique.validationMessage) {
          comment += `
${this.getSeverityIcon(technique.severity)} ${technique.validationMessage}`;
        }
        layer.techniques.push({
          techniqueID: technique.id,
          tactic: tacticShortName,
          color,
          comment,
          enabled: true,
          metadata: [
            {
              name: "severity",
              value: technique.severity
            },
            {
              name: "ioc_cards",
              value: technique.iocCards.join(", ")
            }
          ],
          links: [],
          showSubtechniques: false,
          score: technique.count * 10
          // Scale count for visual weight
        });
      });
    });
    const jsonString = JSON.stringify(layer, null, 2);
    const blob = new Blob([jsonString], { type: "application/json" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = `mitre-navigator-${Date.now()}.json`;
    a.click();
    URL.revokeObjectURL(url);
  }
  onClose() {
    console.debug("[MitreModal] ===== MODAL CLOSED =====");
    const { contentEl } = this;
    contentEl.empty();
  }
  /**
   * Add drag handles and resize functionality to the modal.
   *
   * Creates 8 resize handles (4 corners + 4 edges) and attaches drag listeners.
   * Each handle calculates new dimensions based on mouse movement direction:
   *
   * **Coordinate Math:**
   * - **East (E):** Drag right increases width by deltaX
   * - **West (W):** Drag left decreases width, shifts modal left
   * - **South (S):** Drag down increases height by deltaY
   * - **North (N):** Drag up decreases height, shifts modal up
   * - **Corners:** Combine two directions (e.g., NE = North + East)
   *
   * **Constraints:**
   * - MIN_WIDTH: 600px (prevents crushing tactic columns)
   * - MIN_HEIGHT: 400px (prevents hiding header/controls)
   * - MAX_WIDTH/MAX_HEIGHT: 95% of viewport (prevents overflow)
   *
   * **Position Updates:**
   * When resizing from North or West edges, the modal position must shift
   * to maintain the opposite edge's position. For example, dragging the West
   * edge left by 50px must also move the modal left by 50px.
   */
  makeResizable() {
    const modal = this.modalEl;
    const MIN_WIDTH = 600;
    const MIN_HEIGHT = 400;
    const MAX_WIDTH = window.innerWidth * 0.95;
    const MAX_HEIGHT = window.innerHeight * 0.95;
    const handles = [
      ["resize-handle-n", "ns-resize", false],
      // Top edge
      ["resize-handle-s", "ns-resize", false],
      // Bottom edge
      ["resize-handle-e", "ew-resize", false],
      // Right edge
      ["resize-handle-w", "ew-resize", false],
      // Left edge
      ["resize-handle-ne", "nesw-resize", true],
      // Top-right corner
      ["resize-handle-nw", "nwse-resize", true],
      // Top-left corner
      ["resize-handle-se", "nwse-resize", true],
      // Bottom-right corner
      ["resize-handle-sw", "nesw-resize", true]
      // Bottom-left corner
    ];
    handles.forEach(([className, cursor, isCorner]) => {
      const handle = modal.createDiv(`mitre-resize-handle ${className}`);
      handle.style.cursor = cursor;
      let startX = 0, startY = 0, startWidth = 0, startHeight = 0, startLeft = 0, startTop = 0;
      const onMouseDown = (e) => {
        e.preventDefault();
        e.stopPropagation();
        startX = e.clientX;
        startY = e.clientY;
        const rect = modal.getBoundingClientRect();
        startWidth = rect.width;
        startHeight = rect.height;
        startLeft = rect.left;
        startTop = rect.top;
        document.addEventListener("mousemove", onMouseMove);
        document.addEventListener("mouseup", onMouseUp);
        modal.addClass("mitre-modal-resizing");
      };
      const onMouseMove = (e) => {
        const deltaX = e.clientX - startX;
        const deltaY = e.clientY - startY;
        let newWidth = startWidth;
        let newHeight = startHeight;
        let newLeft = startLeft;
        let newTop = startTop;
        if (className.includes("-e")) {
          newWidth = Math.max(MIN_WIDTH, Math.min(MAX_WIDTH, startWidth + deltaX));
        }
        if (className.includes("-w")) {
          newWidth = Math.max(MIN_WIDTH, Math.min(MAX_WIDTH, startWidth - deltaX));
          newLeft = startLeft + (startWidth - newWidth);
        }
        if (className.includes("-s")) {
          newHeight = Math.max(MIN_HEIGHT, Math.min(MAX_HEIGHT, startHeight + deltaY));
        }
        if (className.includes("-n")) {
          newHeight = Math.max(MIN_HEIGHT, Math.min(MAX_HEIGHT, startHeight - deltaY));
          newTop = startTop + (startHeight - newHeight);
        }
        modal.style.setProperty("width", `${newWidth}px`, "important");
        modal.style.setProperty("height", `${newHeight}px`, "important");
        modal.style.setProperty("max-width", `${newWidth}px`, "important");
        modal.style.setProperty("max-height", `${newHeight}px`, "important");
        if (className.includes("-w") || className.includes("-n")) {
          modal.style.left = `${newLeft}px`;
          modal.style.top = `${newTop}px`;
        }
      };
      const onMouseUp = () => {
        document.removeEventListener("mousemove", onMouseMove);
        document.removeEventListener("mouseup", onMouseUp);
        modal.removeClass("mitre-modal-resizing");
      };
      handle.addEventListener("mousedown", onMouseDown);
    });
  }
};

// src/RenderIOCCardsModal.ts
var import_obsidian3 = require("obsidian");
var RenderIOCCardsModal = class extends import_obsidian3.Modal {
  constructor(app, iocTypes, onSelect) {
    super(app);
    this.iocTypes = iocTypes;
    this.onSelect = onSelect;
  }
  /** Builds the primary IOC type grid view. */
  onOpen() {
    const { contentEl } = this;
    this.modalEl.classList.add("ioc-type-selector-modal");
    this.modalEl.style.maxWidth = "900px";
    this.modalEl.style.width = "90vw";
    contentEl.createEl("h2", { text: "Select IOC Type" });
    const container = contentEl.createDiv("ioc-type-container");
    const typeCount = Object.keys(this.iocTypes).length;
    const cols = Math.min(Math.ceil(Math.sqrt(typeCount)), 5);
    container.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;
    Object.keys(this.iocTypes).forEach((iocTypeId) => {
      const iocType = this.iocTypes[iocTypeId];
      const button = container.createEl("button", { cls: "ioc-type-button" });
      button.setAttribute("data-ioc-type", iocTypeId);
      button.style.borderLeft = `4px solid ${iocType.color}`;
      const iconContainer = button.createDiv("ioc-button-icon");
      iconContainer.innerHTML = iocType.svg;
      const textContainer = button.createDiv("ioc-button-text");
      textContainer.textContent = iocType.name;
      button.addEventListener("click", () => {
        if (iocTypeId === "hostname") {
          this.showOSSelector(iocTypeId);
        } else {
          this.onSelect(iocTypeId);
          this.close();
        }
      });
    });
  }
  /**
   * Replaces the type grid with an OS selector sub-view.
   * Only reachable when iocTypeId === 'hostname' and the type has os_icons.
   */
  showOSSelector(iocTypeId) {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "Select Operating System" });
    contentEl.createEl("p", { text: "Choose the operating system for this hostname:" });
    const container = contentEl.createDiv("os-selector-container");
    const iocType = this.iocTypes[iocTypeId];
    if (iocType.os_icons) {
      Object.keys(iocType.os_icons).forEach((osType) => {
        const osButton = container.createEl("button", { cls: "os-type-button" });
        osButton.setAttribute("data-os-type", osType);
        const iconContainer = osButton.createDiv("os-button-icon");
        iconContainer.innerHTML = iocType.os_icons[osType];
        const textContainer = osButton.createDiv("os-button-text");
        textContainer.textContent = osType.charAt(0).toUpperCase() + osType.slice(1);
        osButton.addEventListener("click", () => {
          this.onSelect(iocTypeId, osType);
          this.close();
        });
      });
    }
    const backButton = contentEl.createEl("button", {
      text: "\u2190 Back to IOC Types",
      cls: "back-button"
    });
    backButton.addEventListener("click", () => {
      contentEl.empty();
      this.onOpen();
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/RenderIOCCards.ts
var RenderIOCCards = class {
  /**
   * Builds the full markdown+HTML string for a new IOC card.
   * @param iocType  - The IOCField definition from the type registry
   * @param iocTypeId - The snake_case key (needed to detect "hostname" special case)
   * @param osType   - If iocTypeId is "hostname", which OS variant was selected
   * @param cardId   - Timestamp-based unique ID for the card (format: #YYYYMMDD-HHMM)
   */
  static createCardContent(iocType, iocTypeId, osType = null, cardId = "") {
    const now = new Date();
    const timestamp = now.toISOString().replace("T", " ").substring(0, 19);
    let iconSvg = iocType.svg;
    if (iocTypeId === "hostname" && osType && iocType.os_icons) {
      iconSvg = iocType.os_icons[osType] || iocType.svg;
    }
    let content = `<div class="ioc-card-container"><div class="ioc-card-header"
        style="display: flex; align-items: center; gap: 16px; margin-bottom: 30px; padding: 20px;
        background: linear-gradient(135deg, ${iocType.color}22, transparent);
        border-radius: 8px; border-bottom: 3px solid ${iocType.color};">
        <div class="ioc-header-content" style="display: flex; align-items: center; gap: 16px; width: 100%;">
        <div class="ioc-icon" style="flex-shrink: 0;">${iconSvg}</div><h2 style="margin: 0;
        color: ${iocType.color}; font-size: 24px; font-weight: 700;">${iocType.name}</h2>
        <span class="ioc-card-id" style="margin-left: auto; padding: 2px 8px; font-size: 11px; font-weight: 600; background: var(--background-modifier-border); color: var(--text-muted); border-radius: 4px; font-family: var(--font-monospace);">${cardId}</span>
        </div><!-- IOC_CARD_ID:${cardId} --></div></div>
`;
    iocType.fields.forEach((field) => {
      content += `${field}: 


------------
`;
    });
    content += `Time of Event: ${timestamp}

------------
`;
    content += `Splunk Query: 

------------
`;
    content += `Mitre Tactic: 

------------
`;
    content += `Mitre Technique: 

------------
`;
    return content;
  }
};

// src/PluginSettings.ts
var import_obsidian4 = require("obsidian");
var DEFAULT_SETTINGS = {
  cardSize: "medium",
  showTimelineButton: true
};
var PluginSettings = class extends import_obsidian4.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "IOC Canvas Plugin Settings" });
    new import_obsidian4.Setting(containerEl).setName("Default card size").setDesc("Set the default size for IOC cards").addDropdown(
      (dropdown) => dropdown.addOption("small", "Small").addOption("medium", "Medium").addOption("large", "Large").setValue(this.plugin.settings.cardSize).onChange(async (value) => {
        this.plugin.settings.cardSize = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian4.Setting(containerEl).setName("Show timeline button").setDesc("Display timeline button in canvas toolbar").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.showTimelineButton).onChange(async (value) => {
        this.plugin.settings.showTimelineButton = value;
        await this.plugin.saveSettings();
      })
    );
  }
};

// src/DiagnosticTests.ts
var DiagnosticTests = class {
  constructor(dataset) {
    this.dataset = null;
    this.dataset = dataset;
  }
  /**
   * Run all diagnostic tests and log results
   */
  runAllTests() {
    console.log("\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557");
    console.log("\u2551          CYBER CANVAS DIAGNOSTIC TEST SUITE                        \u2551");
    console.log("\u255A\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255D");
    console.log("");
    this.testIOCParsing();
    this.testMITREExtraction();
    this.testTacticAbbreviations();
    this.testTechniqueValidation();
    this.testEdgeCases();
    console.log("");
    console.log("\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557");
    console.log("\u2551          DIAGNOSTIC TESTS COMPLETE                                  \u2551");
    console.log("\u255A\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255D");
  }
  /**
   * Test IOC card parsing and type detection
   */
  testIOCParsing() {
    console.log("\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501");
    console.log("TEST 1: IOC Card Parsing");
    console.log("\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501");
    const testCards = [
      {
        name: "IP Address Card",
        text: `<div class="ioc-card-header">IP Address</div>
IP: 192.168.1.1

------------
Time of Event: 2024-01-01 12:00:00

------------
Mitre Tactic: EX

------------
Mitre Technique: T1053.005

------------`
      },
      {
        name: "Command Line Card",
        text: `<div class="ioc-card-header">Command Line</div>
Command: calc.exe

------------
Time of Event: 2024-01-01 12:00:00

------------
Mitre Tactic: EXEC

------------
Mitre Technique: T1059

------------`
      },
      {
        name: "File Hash Card",
        text: `<div class="ioc-card-header">File Hash</div>
Hash: abc123def456

------------
Time of Event: 2024-01-01 12:00:00

------------
Mitre Tactic: Execution

------------
Mitre Technique: T1204.002

------------`
      }
    ];
    testCards.forEach((testCard, index) => {
      console.log(`
  Test ${index + 1}: ${testCard.name}`);
      const result = parseIOCNode({ id: `test-${index}`, text: testCard.text });
      if (result) {
        console.log(`    \u2713 Type detected: ${result.type}`);
        console.log(`    \u2713 Value: ${result.value || "(empty)"}`);
        console.log(`    \u2713 Tactic: ${result.tactic || "(empty)"}`);
        console.log(`    \u2713 Technique: ${result.technique || "(empty)"}`);
      } else {
        console.log(`    \u274C FAILED: Could not parse card`);
      }
    });
  }
  /**
   * Test MITRE field extraction with various formats
   */
  testMITREExtraction() {
    console.log("\n\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501");
    console.log("TEST 2: MITRE Field Extraction");
    console.log("\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501");
    const testCases = [
      { tactic: "EX", technique: "T1053.005", expected: "Should extract EX and T1053.005" },
      { tactic: "Execution", technique: "T1053", expected: "Should extract full name and parent technique" },
      { tactic: "CA", technique: "T1003.001", expected: "Should extract abbreviation and subtechnique" },
      { tactic: "PRIV", technique: "T1068 - Exploitation for Privilege Escalation", expected: "Should extract with name" },
      { tactic: "", technique: "T1053.005", expected: "Should handle empty tactic" },
      { tactic: "EX", technique: "", expected: "Should handle empty technique" }
    ];
    testCases.forEach((testCase, index) => {
      console.log(`
  Test ${index + 1}: ${testCase.expected}`);
      const text = `Mitre Tactic: ${testCase.tactic}

Mitre Technique: ${testCase.technique}
`;
      const result = parseIOCNode({
        id: `mitre-test-${index}`,
        text: `<div>IP Address</div>
IP: 1.1.1.1
${text}`
      });
      if (result) {
        console.log(`    Tactic: "${result.tactic}" (expected: "${testCase.tactic}")`);
        console.log(`    Technique: "${result.technique}" (expected: "${testCase.technique}")`);
        if (result.tactic === testCase.tactic.toUpperCase() && result.technique === testCase.technique.toUpperCase()) {
          console.log(`    \u2713 PASS`);
        } else {
          console.log(`    \u274C MISMATCH`);
        }
      } else {
        console.log(`    \u274C FAILED: Could not parse`);
      }
    });
  }
  /**
   * Test tactic abbreviation resolution
   */
  testTacticAbbreviations() {
    console.log("\n\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501");
    console.log("TEST 3: Tactic Abbreviation Resolution");
    console.log("\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501");
    if (!this.dataset) {
      console.log("  \u26A0 SKIPPED: Dataset not loaded");
      return;
    }
    const testAbbreviations = [
      { input: "EX", expected: "Execution" },
      { input: "EXEC", expected: "Execution" },
      { input: "CA", expected: "Credential Access" },
      { input: "CRED", expected: "Credential Access" },
      { input: "PE", expected: "Privilege Escalation" },
      { input: "PRIV", expected: "Privilege Escalation" },
      { input: "IA", expected: "Initial Access" },
      { input: "C2", expected: "Command and Control" },
      { input: "EXFIL", expected: "Exfiltration" },
      { input: "DE", expected: "Defense Evasion" },
      { input: "INVALID", expected: null }
    ];
    testAbbreviations.forEach((test, index) => {
      console.log(`
  Test ${index + 1}: "${test.input}" \u2192 "${test.expected || "null"}"`);
      const tacticId = normalizeTacticName(test.input, this.dataset);
      if (tacticId) {
        const tactic = this.dataset.tactics[tacticId];
        console.log(`    Resolved to: ${tactic.name} (${tacticId})`);
        if (tactic.name === test.expected) {
          console.log(`    \u2713 PASS`);
        } else {
          console.log(`    \u274C MISMATCH: Expected ${test.expected}`);
        }
      } else {
        if (test.expected === null) {
          console.log(`    \u2713 PASS: Correctly returned null for invalid input`);
        } else {
          console.log(`    \u274C FAILED: Could not resolve, expected ${test.expected}`);
        }
      }
    });
  }
  /**
   * Test technique validation logic
   */
  testTechniqueValidation() {
    console.log("\n\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501");
    console.log("TEST 4: Technique Validation");
    console.log("\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501");
    if (!this.dataset) {
      console.log("  \u26A0 SKIPPED: Dataset not loaded");
      return;
    }
    const testCases = [
      { technique: "T1053.005", tactic: "EX", expected: "valid" },
      { technique: "T1053.005", tactic: "Execution", expected: "valid" },
      { technique: "T1053.005", tactic: "EXFIL", expected: "mismatch" },
      { technique: "T9999", tactic: "EX", expected: "unknown_technique" },
      { technique: "T1053.005", tactic: "INVALID", expected: "unknown_tactic" },
      { technique: "T1566", tactic: "IA", expected: "valid" },
      { technique: "T1566.001", tactic: "IA", expected: "valid" }
    ];
    testCases.forEach((test, index) => {
      console.log(`
  Test ${index + 1}: ${test.technique} + ${test.tactic} \u2192 ${test.expected}`);
      const result = validateTechniqueTactic(test.technique, test.tactic, this.dataset);
      console.log(`    Severity: ${result.severity}`);
      if (result.message) {
        console.log(`    Message: ${result.message}`);
      }
      if (result.severity === test.expected) {
        console.log(`    \u2713 PASS`);
      } else {
        console.log(`    \u274C FAILED: Expected ${test.expected}, got ${result.severity}`);
      }
    });
  }
  /**
   * Test edge cases and error handling
   */
  testEdgeCases() {
    console.log("\n\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501");
    console.log("TEST 5: Edge Cases");
    console.log("\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501");
    const edgeCases = [
      {
        name: "Empty text",
        text: "",
        expectNull: true
      },
      {
        name: "No IOC type",
        text: "Random text without IOC type",
        expectNull: true
      },
      {
        name: "Mixed case technique",
        text: `<div>IP Address</div>
IP: 1.1.1.1
Mitre Tactic: ex
Mitre Technique: t1053.005`,
        expectNull: false
      },
      {
        name: "Technique with description",
        text: `<div>IP Address</div>
IP: 1.1.1.1
Mitre Tactic: EX
Mitre Technique: T1053.005 - Scheduled Task`,
        expectNull: false
      },
      {
        name: "Extra whitespace",
        text: `<div>IP Address</div>
IP: 1.1.1.1
Mitre Tactic:    EX    
Mitre Technique:   T1053.005   `,
        expectNull: false
      }
    ];
    edgeCases.forEach((test, index) => {
      console.log(`
  Test ${index + 1}: ${test.name}`);
      const result = parseIOCNode({ id: `edge-${index}`, text: test.text });
      if (test.expectNull) {
        if (result === null) {
          console.log(`    \u2713 PASS: Correctly returned null`);
        } else {
          console.log(`    \u274C FAILED: Should have returned null`);
        }
      } else {
        if (result !== null) {
          console.log(`    \u2713 PASS: Successfully parsed`);
          console.log(`    Tactic: ${result.tactic}`);
          console.log(`    Technique: ${result.technique}`);
        } else {
          console.log(`    \u274C FAILED: Should have parsed successfully`);
        }
      }
    });
  }
};
function runDiagnostics(dataset) {
  const tests = new DiagnosticTests(dataset);
  tests.runAllTests();
}

// src/main.ts
var IOCCanvasPlugin = class extends import_obsidian5.Plugin {
  constructor() {
    super(...arguments);
    /** Typed settings object persisted to data.json. */
    this.settings = DEFAULT_SETTINGS;
    /** Whether the canvas IOC cards are currently in compact/reduced view. */
    this.isReducedView = false;
  }
  // ---------------------------------------------------------------
  // Plugin lifecycle
  // ---------------------------------------------------------------
  /**
   * Called by Obsidian when the plugin is activated.
   *
   * Order of operations:
   *   1. Load persisted settings from data.json.
   *   2. Register ribbon icons (sidebar shortcuts).
   *   3. Register commands (accessible via Ctrl/Cmd+P).
   *   4. Register the single settings tab from PluginSettings.ts.
   *   5. Register the canvas context-menu entry.
   *   6. Listen for active-leaf changes to inject floating buttons.
   *   7. Perform an initial button injection for the currently open leaf.
   */
  async onload() {
    console.log("Loading IOC Canvas Plugin");
    await this.loadSettings();
    this.addRibbonIcon("clock", "Show Attack Timelines", () => {
      new RenderTimelinesModal(this.app, this).open();
    });
    this.addCommand({
      id: "show-timelines",
      name: "Show Attack Timelines",
      callback: () => {
        new RenderTimelinesModal(this.app, this).open();
      }
    });
    this.addCommand({
      id: "show-ioc-cards",
      name: "Show All IOC Cards",
      callback: () => {
        this.openIOCCardSelector();
      }
    });
    this.addCommand({
      id: "run-diagnostics",
      name: "Run Diagnostic Tests",
      callback: async () => {
        new import_obsidian5.Notice("Running diagnostic tests... Check console for results.");
        const dataset = await loadMitreDataset(this.app);
        runDiagnostics(dataset);
        new import_obsidian5.Notice("Diagnostic tests complete. Check console (Ctrl+Shift+I).");
      }
    });
    this.addSettingTab(new PluginSettings(this.app, this));
    this.registerEvent(
      this.app.workspace.on("file-menu", (menu, file) => {
        if (file instanceof import_obsidian5.TFile && file.extension === "canvas") {
          menu.addItem((item) => {
            item.setTitle("Show Attack Timelines").setIcon("clock").onClick(() => {
              new RenderTimelinesModal(this.app, this).open();
            });
          });
        }
      })
    );
    this.registerEvent(
      this.app.workspace.on("active-leaf-change", () => {
        this.addCanvasButtons();
      })
    );
    this.addCanvasButtons();
  }
  /**
   * Called by Obsidian when the plugin is deactivated or Obsidian closes.
   * Cleans up all DOM elements injected by the plugin so they do not
   * persist after disable/uninstall.
   */
  onunload() {
    console.log("Unloading IOC Canvas Plugin");
    document.querySelectorAll(".ioc-toolbar").forEach((el) => el.remove());
    document.querySelectorAll(".ioc-reduced").forEach((el) => el.classList.remove("ioc-reduced"));
  }
  // ---------------------------------------------------------------
  // Settings persistence
  // ---------------------------------------------------------------
  /** Load settings from data.json, falling back to defaults for any missing keys. */
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  /** Persist the current settings object to data.json. */
  async saveSettings() {
    await this.saveData(this.settings);
  }
  // ---------------------------------------------------------------
  // Canvas floating button injection
  // ---------------------------------------------------------------
  /**
   * Injects control buttons into Obsidian's native canvas control bar.
   *
   * Buttons added:
   *   - Timeline button: opens the attack-timeline modal.
   *   - IOC Cards button: opens the IOC card selector.
   *
   * Uses the .ioc-toolbar class as a duplicate-injection guard.
   *
   * The entire method is wrapped in a try/catch so a failure in button
   * creation never takes down the plugin.
   */
  addCanvasButtons() {
    try {
      const activeView = this.app.workspace.getActiveViewOfType(import_obsidian5.ItemView);
      if (!activeView || activeView.getViewType() !== "canvas") {
        return;
      }
      const canvasView = activeView.containerEl;
      if (!canvasView) {
        return;
      }
      const canvasControls = canvasView.querySelector(".canvas-controls");
      if (!canvasControls) {
        return;
      }
      if (canvasControls.querySelector(".ioc-toolbar")) {
        return;
      }
      const iocToolbar = document.createElement("div");
      iocToolbar.className = "ioc-toolbar";
      const TIMELINE_SVG = '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>';
      const CARDS_SVG = '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="2" y="3" width="20" height="14" rx="2" ry="2"/><line x1="8" y1="21" x2="16" y2="21"/><line x1="12" y1="17" x2="12" y2="21"/></svg>';
      const REDUCE_SVG = '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="4 14 10 14 10 20"/><polyline points="20 10 14 10 14 4"/><line x1="14" y1="10" x2="21" y2="3"/><line x1="3" y1="21" x2="10" y2="14"/></svg>';
      const MITRE_SVG = '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><circle cx="12" cy="12" r="6"/><circle cx="12" cy="12" r="2"/></svg>';
      const timelineBtn = this.createToolbarButton(
        "Show Attack Timelines",
        TIMELINE_SVG,
        () => new RenderTimelinesModal(this.app, this).open()
      );
      const cardsBtn = this.createToolbarButton(
        "Add IOC Card",
        CARDS_SVG,
        () => this.openIOCCardSelector()
      );
      const reduceBtn = this.createToolbarButton("Toggle Reduce View", REDUCE_SVG, () => {
        this.toggleReduceView();
        const icon = reduceBtn.querySelector(".clickable-icon");
        if (icon)
          icon.classList.toggle("is-active", this.isReducedView);
      });
      const mitreBtn = this.createToolbarButton(
        "MITRE ATT&CK Mapper",
        MITRE_SVG,
        () => {
          const activeTechniqueId = this.getSelectedTechniqueId();
          new RenderMitreModal(this.app, this, activeTechniqueId).open();
        }
      );
      iocToolbar.appendChild(timelineBtn);
      iocToolbar.appendChild(cardsBtn);
      iocToolbar.appendChild(reduceBtn);
      iocToolbar.appendChild(mitreBtn);
      canvasControls.appendChild(iocToolbar);
    } catch (err) {
      console.error("IOC Canvas: failed to inject canvas buttons", err);
    }
  }
  /**
   * Creates a single toolbar button with SVG icon for the canvas control bar.
   */
  createToolbarButton(label, svgIcon, onClick) {
    const item = document.createElement("div");
    item.className = "canvas-control-item";
    item.setAttribute("aria-label", label);
    item.setAttribute("title", label);
    item.addEventListener("click", onClick);
    const icon = document.createElement("div");
    icon.className = "clickable-icon";
    icon.innerHTML = svgIcon;
    item.appendChild(icon);
    return item;
  }
  /**
   * Extract MITRE technique ID from the currently selected canvas node.
   *
   * Tries multiple approaches to detect canvas selection since the API is internal:
   * 1. canvas.selection (likely a Set)
   * 2. canvas.selectedNodes (array or Set)
   * 3. Iterate nodes and check node.selected flag
   *
   * @returns Technique ID (e.g., "T1566.001") or null if no selection or no technique
   */
  getSelectedTechniqueId() {
    try {
      const activeView = this.app.workspace.getActiveViewOfType(import_obsidian5.ItemView);
      if (!activeView || activeView.getViewType() !== "canvas") {
        return null;
      }
      const canvas = activeView.canvas;
      if (!canvas) {
        return null;
      }
      let selectedNode = null;
      if (canvas.selection && canvas.selection.size > 0) {
        const firstSelectedId = Array.from(canvas.selection)[0];
        selectedNode = canvas.nodes.get(firstSelectedId);
      }
      if (!selectedNode && canvas.selectedNodes) {
        if (Array.isArray(canvas.selectedNodes) && canvas.selectedNodes.length > 0) {
          selectedNode = canvas.selectedNodes[0];
        } else if (canvas.selectedNodes.size > 0) {
          selectedNode = Array.from(canvas.selectedNodes)[0];
        }
      }
      if (!selectedNode && canvas.nodes) {
        canvas.nodes.forEach((node) => {
          if (node.selected || node.isSelected) {
            selectedNode = node;
            return;
          }
        });
      }
      if (!selectedNode || !selectedNode.text) {
        return null;
      }
      const parsedData = parseIOCNode(selectedNode);
      if (!parsedData || !parsedData.technique || !parsedData.technique.trim()) {
        return null;
      }
      const technique = parsedData.technique.toUpperCase();
      const idMatch = technique.match(/T\d{4}(?:\.\d{3})?/i);
      if (idMatch) {
        return idMatch[0].toUpperCase();
      }
      return null;
    } catch (err) {
      console.error("[IOC Canvas] Error getting selected technique:", err);
      return null;
    }
  }
  // ---------------------------------------------------------------
  // Reduce view toggle
  // ---------------------------------------------------------------
  /**
   * Toggles the reduced/compact view for IOC cards on the active canvas.
   *
   * **Two-part implementation:**
   *
   * **1. CSS-based content hiding** (via `.ioc-reduced` class):
   * - Hides IOC card headers, field labels, and metadata
   * - Shows only the primary value field
   * - Defined in styles.css (`.ioc-reduced .canvas-node-content`)
   *
   * **2. Node height reduction** (via canvas API):
   * - Stores original height in node._iocOriginalHeight custom property
   * - Resizes all text nodes to 60px height (single-line compact view)
   * - Restores original heights when toggled off
   *
   * **Why 60px?**
   * Enough to show a single line of text with padding, matches typical
   * single-line card height in canvas views.
   *
   * **Algorithm:**
   * 1. Toggle isReducedView flag
   * 2. Add/remove `.ioc-reduced` class on canvas wrapper
   * 3. Loop through all canvas nodes:
   *    - If reducing: store original height, resize to 60px
   *    - If restoring: read stored height, restore original dimensions
   * 4. Call canvas.requestFrame() and canvas.requestSave() to persist
   *
   * **Obsidian Canvas API:**
   * - `canvas.nodes` is a Map of all nodes on the canvas
   * - `node.resize({width, height})` or `node.height =` to change dimensions
   * - `node._iocOriginalHeight` is a custom property we add for state tracking
   */
  toggleReduceView() {
    const activeView = this.app.workspace.getActiveViewOfType(import_obsidian5.ItemView);
    if (!activeView || activeView.getViewType() !== "canvas")
      return;
    const canvas = activeView.canvas;
    if (!canvas)
      return;
    this.isReducedView = !this.isReducedView;
    const wrapperEl = canvas.wrapperEl;
    if (wrapperEl) {
      if (this.isReducedView) {
        wrapperEl.classList.add("ioc-reduced");
      } else {
        wrapperEl.classList.remove("ioc-reduced");
      }
    }
    if (canvas.nodes) {
      canvas.nodes.forEach((node) => {
        if (!node.text)
          return;
        if (this.isReducedView) {
          if (!node._iocOriginalHeight) {
            node._iocOriginalHeight = node.height;
          }
          if (node.resize) {
            node.resize({ width: node.width, height: 60 });
          } else {
            node.height = 60;
          }
        } else {
          const originalH = node._iocOriginalHeight || 400;
          if (node.resize) {
            node.resize({ width: node.width, height: originalH });
          } else {
            node.height = originalH;
          }
        }
      });
    }
    canvas.requestFrame();
    canvas.requestSave();
  }
  // ---------------------------------------------------------------
  // IOC card creation helpers
  // ---------------------------------------------------------------
  /**
   * Opens the IOC card selector modal. The callback creates the card on
   * the active canvas.
   */
  openIOCCardSelector() {
    new RenderIOCCardsModal(
      this.app,
      IOC_TYPES,
      (iocTypeId, osType) => {
        this.createIOCCard(iocTypeId, osType);
      }
    ).open();
  }
  /**
   * Creates an IOC card on the active canvas.
   *
   * **Card Creation Flow:**
   * 1. **Validate canvas view** - Ensure user is in a canvas view (not markdown/reading)
   * 2. **Access internal canvas API** - Get canvas object from (view as any).canvas
   * 3. **Generate timestamp-based card ID** - Format: #YYYYMMDD-HHMM (e.g., #20260214-1534)
   * 4. **Generate card content** - Call RenderIOCCards.createCardContent()
   * 5. **Create canvas text node** - Use canvas.createTextNode() with random position
   * 6. **Persist to disk** - Call canvas.requestSave() to write .canvas file
   *
   * **Card ID Format:**
   * - Timestamp-based for uniqueness: #YYYYMMDD-HHMM
   * - Example: #20260214-1534 (February 14, 2026 at 3:34 PM)
   * - Displayed as metadata field at bottom of card
   * - Used for referencing cards in validation errors
   *
   * **Random Positioning:**
   * - New cards are placed at random coordinates within a 400x400 area
   * - User can drag cards to desired position after creation
   * - Prevents cards from stacking exactly on top of each other
   *
   * **Obsidian Canvas API:**
   * - `canvas.createTextNode()` creates a markdown text node
   * - `pos`: {x, y} coordinates on the infinite canvas
   * - `size`: {width, height} in pixels (default 400x400)
   * - `text`: Markdown content (generated by RenderIOCCards)
   *
   * @param iocTypeId - The snake_case IOC type key from IOC_TYPES (e.g., "ip_address")
   * @param osType - Optional OS variant for hostname cards ("windows", "macos", "linux")
   */
  createIOCCard(iocTypeId, osType) {
    const activeView = this.app.workspace.getActiveViewOfType(import_obsidian5.ItemView);
    if (!activeView || activeView.getViewType() !== "canvas") {
      new import_obsidian5.Notice("Please open a canvas first");
      return;
    }
    const canvas = activeView.canvas;
    if (!canvas) {
      new import_obsidian5.Notice("Please open a canvas first");
      return;
    }
    const iocType = IOC_TYPES[iocTypeId];
    if (!iocType) {
      new import_obsidian5.Notice("Unknown IOC type: " + iocTypeId);
      return;
    }
    const now = new Date();
    const year = now.getFullYear();
    const month = String(now.getMonth() + 1).padStart(2, "0");
    const day = String(now.getDate()).padStart(2, "0");
    const hours = String(now.getHours()).padStart(2, "0");
    const minutes = String(now.getMinutes()).padStart(2, "0");
    const cardId = `#${year}${month}${day}-${hours}${minutes}`;
    const content = RenderIOCCards.createCardContent(iocType, iocTypeId, osType || null, cardId);
    canvas.createTextNode({
      pos: { x: Math.random() * 400, y: Math.random() * 400 },
      // Random placement
      size: { width: 400, height: 400 },
      // Standard card size
      text: content
      // Markdown with HTML header
    });
    canvas.requestSave();
    new import_obsidian5.Notice(`Created ${iocType.name} card`);
  }
};
