/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => IOCCanvasPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian12 = require("obsidian");

// src/timeline/RenderTimelinesModal.ts
var import_obsidian4 = require("obsidian");

// src/debug.ts
var DEBUG = false;

// src/parsing/IOCTypeDetection.ts
var IOC_TYPE_PATTERNS = [
  { pattern: /IP Address/i, type: "IP Address" },
  { pattern: /Domain Name/i, type: "Domain Name" },
  { pattern: /File Hash/i, type: "File Hash" },
  { pattern: /URL/i, type: "URL" },
  { pattern: /Email Address/i, type: "Email Address" },
  { pattern: /Hostname/i, type: "Hostname" },
  { pattern: /YARA Rule/i, type: "YARA Rule" },
  { pattern: /Sigma Rule/i, type: "Sigma Rule" },
  { pattern: /Registry Key/i, type: "Registry Key" },
  { pattern: /Process Name/i, type: "Process Name" },
  // FIX: The IOC_TYPES constant uses "Network" (not "Network Traffic").
  // The old code used "Network Traffic" which would never match the
  // IOC_TYPES lookup, so color and icon were never resolved for this type.
  { pattern: /Network/i, type: "Network" },
  { pattern: /Command Line/i, type: "Command Line" },
  { pattern: /File/i, type: "File" },
  { pattern: /Note/i, type: "Note" },
  { pattern: /DLL/i, type: "DLL" },
  { pattern: /C2/i, type: "C2" }
];
function detectIOCType(text) {
  for (const { pattern, type } of IOC_TYPE_PATTERNS) {
    if (pattern.test(text)) {
      return type;
    }
  }
  return "";
}

// src/parsing/IOCFieldExtractors.ts
function extractValue(text) {
  if (DEBUG)
    console.debug("[IOCFieldExtractors] extractValue - input length:", text.length);
  const codeBlockMatch = text.match(/```([\s\S]*?)```/);
  if (codeBlockMatch && codeBlockMatch[1] && codeBlockMatch[1].trim()) {
    const value2 = codeBlockMatch[1].trim();
    if (DEBUG)
      console.debug("[IOCFieldExtractors] extractValue - found code block:", value2);
    return value2;
  }
  const parts = text.split("</div></div>");
  if (parts.length < 2) {
    if (DEBUG)
      console.debug("[IOCFieldExtractors] extractValue - no HTML header found");
    return "";
  }
  let afterHeader = parts[1].trim();
  if (DEBUG)
    console.debug("[IOCFieldExtractors] extractValue - content after header length:", afterHeader.length);
  const fieldMatch = afterHeader.match(/[^:\n]+:\s*/);
  if (!fieldMatch) {
    if (DEBUG)
      console.debug("[IOCFieldExtractors] extractValue - no field label found");
    return "";
  }
  if (DEBUG)
    console.debug("[IOCFieldExtractors] extractValue - first field:", fieldMatch[0].trim());
  const afterFieldLabel = afterHeader.substring(fieldMatch.index + fieldMatch[0].length);
  const separatorMatch = afterFieldLabel.match(/\n?-----/);
  const nextFieldMatch = afterFieldLabel.match(/\n([^:\n]+:\s*)/);
  let value;
  let delimiterIndex;
  if (separatorMatch && separatorMatch.index !== void 0) {
    delimiterIndex = separatorMatch.index;
  }
  if (nextFieldMatch && nextFieldMatch.index !== void 0) {
    if (delimiterIndex === void 0 || nextFieldMatch.index < delimiterIndex) {
      delimiterIndex = nextFieldMatch.index;
    }
  }
  if (delimiterIndex === void 0) {
    const timeIndex = afterFieldLabel.indexOf("Time of Event:");
    value = timeIndex === -1 ? afterFieldLabel : afterFieldLabel.substring(0, timeIndex);
  } else {
    value = afterFieldLabel.substring(0, delimiterIndex);
  }
  const trimmedValue = value.trim();
  if (DEBUG)
    console.debug("[IOCFieldExtractors] extractValue - result:", trimmedValue || "(empty)");
  return trimmedValue;
}
function extractTime(text) {
  const timePatterns = [
    /\*\*Time of Event:\*\*\s*(\d{4}-\d{2}-\d{2}\s\d{2}:\d{2}:\d{2})/i,
    /\*\*Time of Event:\*\*\s*(\d{4}-\d{2}-\d{2})/i,
    /Time of Event[:\s]*(\d{4}-\d{2}-\d{2}[T\s]\d{2}:\d{2}:\d{2})/i,
    /Time of Event[:\s]*(\d{4}-\d{2}-\d{2})/i,
    /Time[:\s]*(\d{4}-\d{2}-\d{2}[T\s]\d{2}:\d{2}:\d{2})/i,
    /(\d{4}-\d{2}-\d{2}[T\s]\d{2}:\d{2}:\d{2})/i
  ];
  for (const pattern of timePatterns) {
    const match = text.match(pattern);
    if (match && match[1]) {
      return match[1].trim();
    }
  }
  return "";
}
function extractSplunkQuery(text) {
  const match = text.match(/\*\*Splunk Query:\*\*[:\s]*([\s\S]*?)(?=\*\*|$)/i);
  if (match && match[1] && match[1].trim()) {
    return match[1].trim();
  }
  return "";
}
function extractMitreField(text, fieldName) {
  var _a;
  if (DEBUG)
    console.debug(`[IOCFieldExtractors] Extracting ${fieldName}...`);
  const pattern = new RegExp(
    `Mitre ${fieldName}:[ \\t]*([\\s\\S]*?)(?=\\n-{4,}|Mitre |$)`,
    "i"
  );
  const match = text.match(pattern);
  if (match && ((_a = match[1]) == null ? void 0 : _a.trim())) {
    const value = match[1].trim().toUpperCase();
    if (DEBUG)
      console.debug(`[IOCFieldExtractors] Found ${fieldName}:`, value);
    return value;
  }
  if (DEBUG)
    console.debug(`[IOCFieldExtractors] No ${fieldName} found`);
  return "";
}
var extractTactic = (text) => extractMitreField(text, "Tactic");
var extractTechnique = (text) => extractMitreField(text, "Technique");
function extractCardRole(text) {
  if (/\[P\]/.test(text))
    return "parent";
  if (/\[C\]/.test(text))
    return "child";
  return "";
}
function extractCardId(text) {
  if (DEBUG)
    console.debug("[IOCFieldExtractors] Extracting Card ID...");
  const commentMatch = text.match(/<!-- IOC_CARD_ID:([^>]+) -->/);
  if (commentMatch && commentMatch[1]) {
    const cardId = commentMatch[1].trim();
    if (DEBUG)
      console.debug("[IOCFieldExtractors] Found Card ID in HTML comment:", cardId);
    return cardId;
  }
  const cardIdMatch = text.match(/Card ID:\s*([^\n]+)/i);
  if (cardIdMatch && cardIdMatch[1]) {
    const cardId = cardIdMatch[1].trim();
    if (DEBUG)
      console.debug("[IOCFieldExtractors] Found Card ID in legacy field format:", cardId);
    return cardId;
  }
  if (DEBUG)
    console.debug("[IOCFieldExtractors] No Card ID found");
  return "";
}

// src/types/IOCCardsTypes.ts
var IOC_TYPES = {
  // --- Network-related IOC types ---
  ip_address: {
    name: "IP Address",
    icon: "network",
    color: "#FF6B6B",
    fields: ["IP", "country", "asn"],
    svg: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="32" height="32" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
  <circle cx="12" cy="15" r="7"/>
  <path d="M12 8c-3.9 0-7 3.1-7 7"/>
  <path d="M12 8c3.9 0 7 3.1 7 7"/>
  <line x1="5" y1="15" x2="19" y2="15"/>
  <line x1="12" y1="8" x2="12" y2="22"/>
  <path d="M12 8c-1.7-3-1.7-6 0-6s1.7 3 0 6z"/>
  <circle cx="12" cy="4" r="2" fill="currentColor"/>
</svg>`
  },
  domain: {
    name: "Domain Name",
    icon: "globe",
    color: "#4ECDC4",
    fields: ["name", "IP"],
    svg: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="32" height="32" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
    <circle cx="12" cy="12" r="10"/>
    <line x1="2" y1="12" x2="22" y2="12"/>
    <path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"/>
  </svg>`
  },
  file_hash: {
    name: "File Hash",
    icon: "hash",
    color: "#45B7D1",
    fields: ["hash", "hash_type", "filename", "file_size"],
    svg: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="32" height="32" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
    <line x1="4" y1="9" x2="20" y2="9"/>
    <line x1="4" y1="15" x2="20" y2="15"/>
    <line x1="10" y1="3" x2="8" y2="21"/>
    <line x1="16" y1="3" x2="14" y2="21"/>
  </svg>`
  },
  url: {
    name: "URL",
    icon: "link",
    color: "#96CEB4",
    fields: ["url", "domain", "category"],
    svg: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="32" height="32" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
    <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"/>
    <path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"/>
  </svg>`
  },
  email: {
    name: "Email Address",
    icon: "mail",
    color: "#FECA57",
    fields: ["email", "domain"],
    svg: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="32" height="32" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
    <path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"/>
    <polyline points="22,6 12,13 2,6"/>
  </svg>`
  },
  // Hostname is the only IOC type with os_icons, triggering a secondary
  // OS selector sub-view in RenderIOCCardsModal before card creation.
  hostname: {
    name: "Hostname",
    icon: "monitor",
    color: "#9C27B0",
    fields: ["hostname", "os_type", "domain"],
    svg: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="32" height="32" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
    <rect x="2" y="3" width="20" height="14" rx="2" ry="2"/>
    <line x1="8" y1="21" x2="16" y2="21"/>
    <line x1="12" y1="17" x2="12" y2="21"/>
  </svg>`,
    os_icons: {
      windows_workstation: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="32" height="32" fill="currentColor">
    <path d="M0 3.5L10 2v9.5H0V3.5zM11 1.9l13-1.9v11H11V1.9zM0 12.5h10V22l-10-1.5v-8zM11 12h13v10l-13 2v-12z"/>
  </svg>`,
      windows_server: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="32" height="32" fill="currentColor">
    <path d="M0 3.5L10 2v9.5H0V3.5zM11 1.9l13-1.9v11H11V1.9zM0 12.5h10V22l-10-1.5v-8zM11 12h13v10l-13 2v-12z"/>
  </svg>`,
      macos: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="32" height="32" fill="currentColor">
    <path d="M17.05 20.28c-.98.95-2.05.8-3.08.35-1.09-.46-2.09-.48-3.24 0-1.44.62-2.2.44-3.06-.35C2.79 15.25 3.51 7.59 9.05 7.31c1.35.07 2.29.74 3.08.8 1.18-.24 2.31-.93 3.57-.84 1.51.12 2.65.72 3.4 1.8-3.12 1.87-2.38 5.98.48 7.13-.57 1.5-1.31 2.99-2.54 4.09l.01-.01zM12.03 7.25c-.15-2.23 1.66-4.07 3.74-4.25.29 2.58-2.34 4.5-3.74 4.25z"/>
  </svg>`,
      linux: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="32" height="32" fill="currentColor">
    <path d="M12.504 0c-.155 0-.315.008-.48.021-4.226.333-3.105 4.807-3.17 6.298-.076 1.092-.3 1.953-1.05 3.02-.885 1.051-2.127 2.75-2.716 4.521-.278.84-.41 1.684-.287 2.489.845 5.548 5.676 6.016 6.855 6.016.178 0 .287-.016.287-.016s8.029-.192 8.03-8.047c0-4.662-3.916-9.69-7.47-14.302z"/>
  </svg>`
    }
  },
  // --- Detection rule types ---
  yara_rule: {
    name: "YARA Rule",
    icon: "shield",
    color: "#FF9FF3",
    fields: ["rule_name", "rule_content"],
    svg: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="32" height="32" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
    <path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"/>
    <text x="12" y="15" font-size="10" text-anchor="middle" fill="currentColor" font-weight="bold">Y</text>
  </svg>`
  },
  sigma_rule: {
    name: "Sigma Rule",
    icon: "search",
    color: "#A8E6CF",
    fields: ["rule_name", "rule_content"],
    svg: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="32" height="32" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
    <circle cx="12" cy="12" r="10"/>
    <text x="12" y="17" font-size="14" text-anchor="middle" fill="currentColor" font-weight="bold">\u03A3</text>
  </svg>`
  },
  // --- Host-based IOC types ---
  registry_key: {
    name: "Registry Key",
    icon: "settings",
    color: "#FFB74D",
    fields: ["key_path", "key_name", "key_data"],
    svg: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="32" height="32" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
    <rect x="3" y="11" width="18" height="11" rx="2" ry="2"/>
    <path d="M7 11V7a5 5 0 0 1 9.9-1"/>
  </svg>`
  },
  process_name: {
    name: "Process Name",
    icon: "cpu",
    color: "#81C784",
    fields: ["process_name", "command_line", "pid", "parent_process"],
    svg: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="32" height="32" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
  <rect x="3" y="5" width="18" height="14" rx="2" ry="2"/>
  <line x1="3" y1="9" x2="21" y2="9"/>
  <circle cx="6" cy="7" r="0.8" fill="currentColor"/>
  <circle cx="9" cy="7" r="0.8" fill="currentColor"/>
  <line x1="7" y1="13" x2="17" y2="13"/>
  <line x1="7" y1="16" x2="14" y2="16"/>
</svg>`
  },
  network: {
    name: "Network",
    icon: "activity",
    color: "#9575CD",
    fields: ["protocol", "port", "direction"],
    svg: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="32" height="32" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
    <polyline points="22 12 18 12 15 21 9 3 6 12 2 12"/>
  </svg>`
  },
  command_line: {
    name: "Command Line",
    icon: "terminal",
    color: "#2E8B57",
    fields: ["command", "pid", "parent_process"],
    svg: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="32" height="32" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
    <polyline points="4 17 10 11 4 5"/>
    <line x1="12" y1="19" x2="20" y2="19"/>
  </svg>`
  },
  // --- File and artifact types ---
  file: {
    name: "File",
    icon: "file",
    color: "#E91E63",
    fields: ["name", "type", "path", "size", "hash", "pid"],
    svg: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="32" height="32" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
  <path d="M4 4h12l4 4v12a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2z"/>
  <line x1="8" y1="11" x2="16" y2="11"/>
  <line x1="8" y1="15" x2="16" y2="15"/>
</svg>`
  },
  // --- Utility types ---
  note: {
    name: "Note",
    icon: "note",
    color: "#F39C12",
    fields: ["NB"],
    svg: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="32" height="32" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
  <rect x="4" y="4" width="16" height="16" rx="2" ry="2"/>
  <line x1="8" y1="8" x2="16" y2="8"/>
  <line x1="8" y1="12" x2="16" y2="12"/>
  <line x1="8" y1="16" x2="14" y2="16"/>
</svg>`
  },
  dll: {
    name: "DLL",
    icon: "dll",
    color: "#3498DB",
    fields: ["name", "type", "path", "size", "hash"],
    svg: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="32" height="32" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
  <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8l-6-6z"/>
  <polyline points="14 2 14 8 20 8"/>
  <circle cx="12" cy="13" r="2"/>
  <path d="M12 10.5v-1"/>
  <path d="M12 15.5v1"/>
  <path d="M14.5 11.5l0.7-0.7"/>
  <path d="M9.8 16.2l-0.7 0.7"/>
  <path d="M15.5 13h1"/>
  <path d="M8.5 13h-1"/>
  <path d="M14.5 14.5l0.7 0.7"/>
  <path d="M9.8 9.8l-0.7-0.7"/>
</svg>`
  },
  // --- Threat infrastructure ---
  c2: {
    name: "C2",
    icon: "c2",
    color: "#E74C3C",
    fields: ["domain", "IP"],
    svg: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="32" height="32" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
  <circle cx="12" cy="12" r="9"/>
  <path d="M12 3v1.5"/>
  <path d="M12 19.5V21"/>
  <path d="M3 12h1.5"/>
  <path d="M19.5 12H21"/>
  <path d="M5.6 5.6l1.1 1.1"/>
  <path d="M17.3 17.3l1.1 1.1"/>
  <path d="M5.6 18.4l1.1-1.1"/>
  <path d="M17.3 6.7l1.1-1.1"/>
  <polyline points="8 10 11 13 8 16"/>
  <line x1="13" y1="16" x2="16" y2="16"/>
</svg>`
  }
};

// src/parsing/IOCVisualLookup.ts
function lookupTypeVisuals(iocType, fallbackColor) {
  let icon = "";
  let color = fallbackColor;
  if (IOC_TYPES && typeof IOC_TYPES === "object") {
    for (const key of Object.keys(IOC_TYPES)) {
      if (IOC_TYPES[key].name === iocType) {
        icon = IOC_TYPES[key].svg;
        color = IOC_TYPES[key].color;
        break;
      }
    }
  }
  return { icon, color };
}

// src/parsing/IOCParser.ts
function parseIOCNode(node) {
  var _a;
  if (DEBUG)
    console.debug("[IOCParser] ==================== PARSING NODE ====================");
  if (DEBUG)
    console.debug("[IOCParser] Node ID:", node.id);
  if (DEBUG)
    console.debug("[IOCParser] Text length:", ((_a = node.text) == null ? void 0 : _a.length) || 0);
  if (!node.text) {
    if (DEBUG)
      console.debug("[IOCParser] No text content");
    return null;
  }
  const iocType = detectIOCType(node.text);
  if (!iocType) {
    if (DEBUG)
      console.debug("[IOCParser] No IOC type detected");
    return null;
  }
  if (DEBUG)
    console.debug("[IOCParser] IOC Type:", iocType);
  const value = extractValue(node.text);
  const time = extractTime(node.text);
  const splunkQuery = extractSplunkQuery(node.text);
  const tactic = extractTactic(node.text);
  const technique = extractTechnique(node.text);
  const cardId = extractCardId(node.text);
  const role = extractCardRole(node.text);
  const fallbackColor = node.color || "#333";
  const { icon, color } = lookupTypeVisuals(iocType, fallbackColor);
  const result = {
    id: node.id,
    cardId,
    type: iocType,
    value,
    time,
    splunkQuery,
    tactic,
    technique,
    icon,
    color,
    ...role === "child" ? { isChild: true } : {}
  };
  if (DEBUG)
    console.debug("[IOCParser] EXTRACTION COMPLETE:", {
      type: iocType,
      cardId: cardId || "(no ID)",
      value: value || "(empty)",
      time: time || "(empty)",
      tactic: tactic || "(empty)",
      technique: technique || "(empty)"
    });
  return result;
}

// src/timeline/TimeTimelineProcessing.ts
function extractFixedIOCData(app) {
  if (DEBUG)
    console.debug("[TimeProcessor] Starting extraction");
  const activeLeaf = app.workspace.activeLeaf;
  if (!activeLeaf || !activeLeaf.view || activeLeaf.view.getViewType() !== "canvas") {
    if (DEBUG)
      console.debug("[TimeProcessor] No active canvas view");
    return [];
  }
  const canvasView = activeLeaf.view;
  const canvas = canvasView.canvas;
  if (!canvas || !canvas.nodes) {
    if (DEBUG)
      console.debug("[TimeProcessor] No canvas or nodes");
    return [];
  }
  const totalNodes = canvas.nodes.size || canvas.nodes.length || 0;
  if (DEBUG)
    console.debug("[TimeProcessor] Processing", totalNodes, "nodes");
  const iocData = [];
  let emptyValueCount = 0;
  canvas.nodes.forEach((node) => {
    if (node.text) {
      const parsedData = parseIOCNode(node);
      if (parsedData) {
        if (!parsedData.value || !parsedData.value.trim()) {
          emptyValueCount++;
        }
        iocData.push(parsedData);
      }
    }
  });
  if (DEBUG)
    console.debug("[TimeProcessor] Extraction complete - found:", iocData.length, "IOCs,", emptyValueCount, "empty values");
  return iocData;
}

// src/timeline/TimeTimelineTab.ts
var import_obsidian = require("obsidian");

// src/timeline/TimelineCopyExport.ts
function generateCopyText(iocData, startTime, endTime) {
  let filteredData = iocData;
  if (startTime !== void 0 && endTime !== void 0) {
    filteredData = iocData.filter((ioc) => {
      const ts = new Date(ioc.time).getTime();
      return !isNaN(ts) && ts >= startTime && ts <= endTime;
    });
  }
  const header = "Time	Tactic	Technique	Value";
  const lines = filteredData.map(
    (ioc) => `${ioc.time || ""}	${ioc.tactic || ""}	${ioc.technique || ""}	${ioc.value || ""}`
  );
  return [header, ...lines].join("\n");
}

// src/timeline/TimeTimelineTab.ts
function renderTimeTimeline(container, iocData) {
  if (DEBUG)
    console.debug("[TimeTimeline] Starting render");
  if (iocData.length === 0) {
    container.createEl("p", {
      text: "No IOC cards found in the current canvas. Create some IOC cards first to see the timeline.",
      cls: "timeline-empty-message"
    });
    return;
  }
  const timeCopyBtn = container.createEl("button", {
    text: "Copy Timeline",
    cls: "timeline-copy-button"
  });
  timeCopyBtn.style.position = "absolute";
  timeCopyBtn.style.top = "10px";
  timeCopyBtn.style.right = "10px";
  timeCopyBtn.addEventListener("click", () => {
    const text = generateCopyText(iocData);
    navigator.clipboard.writeText(text).then(() => {
      new import_obsidian.Notice(`Copied ${iocData.length} entries to clipboard`);
    });
  });
  const timelineContainer = container.createDiv("timeline-container");
  iocData.forEach((ioc, index) => {
    const timelineItem = timelineContainer.createDiv("timeline-item");
    timelineItem.style.setProperty("--ioc-color", ioc.color);
    timelineItem.style.setProperty("--ioc-color-30", `${ioc.color}30`);
    timelineItem.style.background = `linear-gradient(135deg, ${ioc.color}15 0%, ${ioc.color}05 100%)`;
    timelineItem.style.boxShadow = `0 4px 12px ${ioc.color}25`;
    timelineItem.style.borderColor = ioc.color;
    if (index < iocData.length - 1) {
      const connector = timelineItem.createDiv("timeline-connector");
      connector.style.background = `linear-gradient(180deg, ${ioc.color} 0%, ${iocData[index + 1].color} 100%)`;
    }
    const iconContainer = timelineItem.createDiv("timeline-icon");
    iconContainer.innerHTML = ioc.icon;
    iconContainer.style.background = `${ioc.color}20`;
    iconContainer.style.borderColor = ioc.color;
    const detailsContainer = timelineItem.createDiv("timeline-details");
    const titleEl = detailsContainer.createEl("h3", { text: ioc.type });
    titleEl.style.textShadow = `0 1px 3px ${ioc.color}40`;
    const timeEl = detailsContainer.createDiv("timeline-time");
    timeEl.textContent = `Time: ${ioc.time}`;
    if (ioc.value && ioc.value.trim()) {
      const valueEl = detailsContainer.createDiv("timeline-value");
      valueEl.textContent = `Value: ${ioc.value}`;
    }
    if (ioc.splunkQuery && ioc.splunkQuery.trim()) {
      const splunkEl = detailsContainer.createDiv("timeline-splunk");
      splunkEl.textContent = `Splunk Query: ${ioc.splunkQuery}`;
    }
    if (ioc.tactic) {
      const tacticEl = detailsContainer.createDiv("timeline-tactic");
      tacticEl.textContent = `Tactic: ${ioc.tactic}`;
    }
    if (ioc.technique) {
      const techniqueEl = detailsContainer.createDiv("timeline-technique");
      techniqueEl.textContent = `Technique: ${ioc.technique}`;
    }
    timelineItem.addEventListener("mouseover", () => {
      timelineItem.style.boxShadow = `0 8px 20px ${ioc.color}35`;
    });
    timelineItem.addEventListener("mouseout", () => {
      timelineItem.style.boxShadow = `0 4px 12px ${ioc.color}25`;
    });
  });
}

// src/timeline/GraphTimelineTab.ts
var import_obsidian2 = require("obsidian");

// src/timeline/GraphTimelineHelpers.ts
var EDGE_PADDING_PERCENT = 0.08;
function computePaddedViewport(viewMin, viewMax) {
  const viewSpan = viewMax - viewMin || 1;
  const paddingMs = EDGE_PADDING_PERCENT * viewSpan;
  return {
    paddedMin: viewMin - paddingMs,
    paddedMax: viewMax + paddingMs,
    paddedSpan: viewMax + paddingMs - (viewMin - paddingMs)
  };
}
function formatTimestamp(ts) {
  const d = new Date(ts);
  return d.toISOString().replace("T", " ").substring(0, 19);
}
function formatShortTime(ts) {
  const d = new Date(ts);
  const year = d.getFullYear();
  const month = String(d.getMonth() + 1).padStart(2, "0");
  const day = String(d.getDate()).padStart(2, "0");
  const hours = String(d.getHours()).padStart(2, "0");
  const minutes = String(d.getMinutes()).padStart(2, "0");
  const seconds = String(d.getSeconds()).padStart(2, "0");
  return `${year}-${month}-${day}
${hours}:${minutes}:${seconds}`;
}

// src/timeline/GraphTimelineRendering.ts
function createGraphTimelineDOM(container, timedData, dataMinTime, dataMaxTime) {
  const controlsEl = container.createDiv("graph-range-controls");
  controlsEl.createEl("span", { text: "From: ", cls: "graph-range-label" });
  const startInput = controlsEl.createEl("input", {
    cls: "graph-range-input",
    type: "text"
  });
  startInput.value = formatTimestamp(dataMinTime);
  controlsEl.createEl("span", { text: " To: ", cls: "graph-range-label" });
  const endInput = controlsEl.createEl("input", {
    cls: "graph-range-input",
    type: "text"
  });
  endInput.value = formatTimestamp(dataMaxTime);
  const resetBtn = controlsEl.createEl("button", {
    text: "Reset",
    cls: "graph-range-reset"
  });
  const graphArea = container.createDiv("graph-timeline-area");
  const axisEl = graphArea.createDiv("graph-time-axis");
  const tooltip = graphArea.createDiv("graph-tooltip");
  tooltip.style.display = "none";
  const selectionOverlay = graphArea.createDiv("graph-selection-overlay");
  selectionOverlay.style.display = "none";
  const dots = [];
  timedData.forEach((d, idx) => {
    const yOffset = (idx % 2 === 0 ? -1 : 1) * (idx % 4 * 6 + 4);
    const dot = graphArea.createDiv("graph-dot");
    dot.style.top = `calc(50% + ${yOffset}px)`;
    dot.style.backgroundColor = d.ioc.color;
    dot.style.borderColor = d.ioc.color;
    dot.setAttribute("data-ts", String(d.ts));
    dot.addEventListener("mouseenter", () => {
      tooltip.style.display = "block";
      tooltip.innerHTML = `<strong>${d.ioc.type}</strong><br/>${d.ioc.value || "(no value)"}<br/><span class="graph-tooltip-time">${d.ioc.time}</span>`;
      const rect = graphArea.getBoundingClientRect();
      const dotRect = dot.getBoundingClientRect();
      tooltip.style.left = `${dotRect.left - rect.left + 6}px`;
      tooltip.style.top = `${dotRect.top - rect.top - 60}px`;
    });
    dot.addEventListener("mouseleave", () => {
      tooltip.style.display = "none";
    });
    dots.push(dot);
  });
  const listContainer = container.createDiv("graph-filtered-list");
  const copyBtn = container.createEl("button", {
    text: "Copy Filtered Range",
    cls: "timeline-copy-button graph-timeline-copy"
  });
  copyBtn.style.position = "absolute";
  copyBtn.style.top = "10px";
  copyBtn.style.right = "10px";
  return {
    controlsEl,
    startInput,
    endInput,
    resetBtn,
    graphArea,
    axisEl,
    tooltip,
    selectionOverlay,
    dots,
    listContainer,
    copyBtn
  };
}

// src/timeline/GraphTimelineTab.ts
function renderGraphTimeline(container, iocData) {
  if (iocData.length === 0) {
    container.createEl("p", {
      text: "No IOC cards found. Create some IOC cards with timestamps to see the graph.",
      cls: "timeline-empty-message"
    });
    return;
  }
  const timedData = iocData.map((ioc) => ({ ioc, ts: new Date(ioc.time).getTime() })).filter((d) => !isNaN(d.ts)).sort((a, b) => a.ts - b.ts);
  if (timedData.length === 0) {
    container.createEl("p", {
      text: "No IOC cards with valid timestamps found.",
      cls: "timeline-empty-message"
    });
    return;
  }
  const dataMinTime = timedData[0].ts;
  const dataMaxTime = timedData[timedData.length - 1].ts;
  let viewMinTime = dataMinTime;
  let viewMaxTime = dataMaxTime;
  let rangeStart = dataMinTime;
  let rangeEnd = dataMaxTime;
  let isDragging = false;
  let dragStartTime = 0;
  const dom = createGraphTimelineDOM(container, timedData, dataMinTime, dataMaxTime);
  const {
    startInput,
    endInput,
    resetBtn,
    graphArea,
    axisEl,
    selectionOverlay,
    dots,
    listContainer
  } = dom;
  function updateAxisTicks() {
    axisEl.querySelectorAll(".graph-axis-tick").forEach((el) => el.remove());
    const { paddedMin, paddedSpan } = computePaddedViewport(viewMinTime, viewMaxTime);
    const tickCount = Math.min(6, timedData.length);
    for (let i = 0; i < tickCount; i++) {
      const pct = tickCount === 1 ? 50 : i / (tickCount - 1) * 100;
      const tickTime = paddedMin + pct / 100 * paddedSpan;
      const tick = axisEl.createDiv("graph-axis-tick");
      tick.style.left = `${pct}%`;
      tick.setAttribute("data-label", formatShortTime(tickTime));
    }
  }
  function updateDotPositions() {
    const { paddedMin, paddedSpan } = computePaddedViewport(viewMinTime, viewMaxTime);
    dots.forEach((dot) => {
      const ts = Number(dot.getAttribute("data-ts"));
      if (ts < viewMinTime || ts > viewMaxTime) {
        dot.style.display = "none";
      } else {
        dot.style.display = "block";
        const pct = (ts - paddedMin) / paddedSpan * 100;
        dot.style.left = `${pct}%`;
      }
    });
  }
  function updateFilter() {
    dots.forEach((dot) => {
      const ts = Number(dot.getAttribute("data-ts"));
      if (ts >= rangeStart && ts <= rangeEnd) {
        dot.classList.add("selected");
      } else {
        dot.classList.remove("selected");
      }
    });
    listContainer.empty();
    const filtered = timedData.filter((d) => d.ts >= rangeStart && d.ts <= rangeEnd);
    if (filtered.length === 0) {
      listContainer.createEl("p", { text: "No cards in selected range.", cls: "timeline-empty-message" });
      return;
    }
    listContainer.createEl("p", { text: `Showing ${filtered.length} of ${timedData.length} cards`, cls: "graph-filter-count" });
    filtered.forEach((d) => {
      const item = listContainer.createDiv("timeline-item");
      item.style.setProperty("--ioc-color", d.ioc.color);
      item.style.background = `linear-gradient(135deg, ${d.ioc.color}15 0%, ${d.ioc.color}05 100%)`;
      item.style.boxShadow = `0 4px 12px ${d.ioc.color}25`;
      item.style.borderColor = d.ioc.color;
      const iconContainer = item.createDiv("timeline-icon");
      iconContainer.innerHTML = d.ioc.icon;
      iconContainer.style.background = `${d.ioc.color}20`;
      iconContainer.style.borderColor = d.ioc.color;
      const details = item.createDiv("timeline-details");
      const titleEl = details.createEl("h3", { text: d.ioc.type });
      titleEl.style.textShadow = `0 1px 3px ${d.ioc.color}40`;
      details.createDiv({ cls: "timeline-time", text: `Time: ${d.ioc.time}` });
      if (d.ioc.value && d.ioc.value.trim()) {
        details.createDiv({ cls: "timeline-value", text: `Value: ${d.ioc.value}` });
      }
      if (d.ioc.tactic) {
        details.createDiv({ cls: "timeline-tactic", text: `Tactic: ${d.ioc.tactic}` });
      }
      if (d.ioc.technique) {
        details.createDiv({ cls: "timeline-technique", text: `Technique: ${d.ioc.technique}` });
      }
    });
  }
  function zoomToRange(newStart, newEnd) {
    if (newStart > newEnd) {
      [newStart, newEnd] = [newEnd, newStart];
    }
    viewMinTime = newStart;
    viewMaxTime = newEnd;
    rangeStart = newStart;
    rangeEnd = newEnd;
    startInput.value = formatTimestamp(newStart);
    endInput.value = formatTimestamp(newEnd);
    updateAxisTicks();
    updateDotPositions();
    updateFilter();
  }
  dom.copyBtn.addEventListener("click", () => {
    const text = generateCopyText(timedData.map((d) => d.ioc), viewMinTime, viewMaxTime);
    const filtered = timedData.filter((d) => d.ts >= viewMinTime && d.ts <= viewMaxTime);
    navigator.clipboard.writeText(text).then(() => {
      new import_obsidian2.Notice(`Copied ${filtered.length} of ${timedData.length} entries to clipboard`);
    });
  });
  graphArea.addEventListener("mousedown", (e) => {
    if (e.target.classList.contains("graph-dot"))
      return;
    const rect = graphArea.getBoundingClientRect();
    const clickX = e.clientX - rect.left;
    const pct = (clickX - 30) / (rect.width - 60);
    const { paddedMin, paddedSpan } = computePaddedViewport(viewMinTime, viewMaxTime);
    dragStartTime = paddedMin + pct * paddedSpan;
    dragStartTime = Math.max(dataMinTime, Math.min(dataMaxTime, dragStartTime));
    isDragging = true;
    graphArea.classList.add("dragging");
    startInput.value = formatTimestamp(dragStartTime);
    selectionOverlay.style.display = "block";
    selectionOverlay.style.left = `${clickX}px`;
    selectionOverlay.style.width = "0px";
  });
  graphArea.addEventListener("mousemove", (e) => {
    if (!isDragging)
      return;
    const rect = graphArea.getBoundingClientRect();
    const currentX = e.clientX - rect.left;
    const pct = (currentX - 30) / (rect.width - 60);
    const { paddedMin, paddedSpan } = computePaddedViewport(viewMinTime, viewMaxTime);
    const currentTime = paddedMin + pct * paddedSpan;
    const clampedTime = Math.max(dataMinTime, Math.min(dataMaxTime, currentTime));
    endInput.value = formatTimestamp(clampedTime);
    const startX = (dragStartTime - paddedMin) / paddedSpan * (rect.width - 60) + 30;
    const endX = currentX;
    const left = Math.min(startX, endX);
    const width = Math.abs(endX - startX);
    selectionOverlay.style.left = `${left}px`;
    selectionOverlay.style.width = `${width}px`;
  });
  graphArea.addEventListener("mouseup", (e) => {
    if (!isDragging)
      return;
    const rect = graphArea.getBoundingClientRect();
    const endX = e.clientX - rect.left;
    const pct = (endX - 30) / (rect.width - 60);
    const { paddedMin, paddedSpan } = computePaddedViewport(viewMinTime, viewMaxTime);
    let dragEndTime = paddedMin + pct * paddedSpan;
    dragEndTime = Math.max(dataMinTime, Math.min(dataMaxTime, dragEndTime));
    isDragging = false;
    graphArea.classList.remove("dragging");
    selectionOverlay.style.display = "none";
    if (Math.abs(dragEndTime - dragStartTime) > 1e3) {
      zoomToRange(dragStartTime, dragEndTime);
    }
  });
  graphArea.addEventListener("mouseleave", () => {
    if (isDragging) {
      isDragging = false;
      graphArea.classList.remove("dragging");
      selectionOverlay.style.display = "none";
    }
  });
  startInput.addEventListener("change", () => {
    const parsed = new Date(startInput.value).getTime();
    if (!isNaN(parsed)) {
      zoomToRange(parsed, rangeEnd);
    }
  });
  endInput.addEventListener("change", () => {
    const parsed = new Date(endInput.value).getTime();
    if (!isNaN(parsed)) {
      zoomToRange(rangeStart, parsed);
    }
  });
  resetBtn.addEventListener("click", () => {
    zoomToRange(dataMinTime, dataMaxTime);
  });
  updateAxisTicks();
  updateDotPositions();
  updateFilter();
}

// src/canvas/CanvasEdges.ts
var import_obsidian3 = require("obsidian");
function getCanvasEdges(app) {
  const activeView = app.workspace.getActiveViewOfType(import_obsidian3.ItemView);
  if (!activeView || activeView.getViewType() !== "canvas") {
    if (DEBUG)
      console.debug("[CanvasEdges] No active canvas view");
    return [];
  }
  const canvas = activeView.canvas;
  if (!canvas || !canvas.edges) {
    if (DEBUG)
      console.debug("[CanvasEdges] No canvas or edges");
    return [];
  }
  const edges = [];
  canvas.edges.forEach((edge) => {
    var _a, _b, _c, _d;
    const fromId = (_b = (_a = edge == null ? void 0 : edge.from) == null ? void 0 : _a.node) == null ? void 0 : _b.id;
    const toId = (_d = (_c = edge == null ? void 0 : edge.to) == null ? void 0 : _c.node) == null ? void 0 : _d.id;
    if (fromId && toId) {
      edges.push({ fromNodeId: fromId, toNodeId: toId });
    } else if (DEBUG) {
      console.debug("[CanvasEdges] Skipping edge with missing node IDs:", edge);
    }
  });
  if (DEBUG)
    console.debug("[CanvasEdges] Found", edges.length, "edges");
  return edges;
}

// src/timeline/LinkTimelineProcessing.ts
function buildParentChildGroups(iocData, edges) {
  const nodeMap = /* @__PURE__ */ new Map();
  for (const ioc of iocData) {
    nodeMap.set(ioc.id, ioc);
  }
  const outgoingEdges = /* @__PURE__ */ new Map();
  const hasIncomingEdge = /* @__PURE__ */ new Set();
  const incomingFrom = /* @__PURE__ */ new Map();
  for (const edge of edges) {
    if (!nodeMap.has(edge.fromNodeId) || !nodeMap.has(edge.toNodeId))
      continue;
    if (!outgoingEdges.has(edge.fromNodeId)) {
      outgoingEdges.set(edge.fromNodeId, /* @__PURE__ */ new Set());
    }
    outgoingEdges.get(edge.fromNodeId).add(edge.toNodeId);
    hasIncomingEdge.add(edge.toNodeId);
    if (!incomingFrom.has(edge.toNodeId)) {
      incomingFrom.set(edge.toNodeId, /* @__PURE__ */ new Set());
    }
    incomingFrom.get(edge.toNodeId).add(edge.fromNodeId);
  }
  function isRootParent(nodeId) {
    const node = nodeMap.get(nodeId);
    if (!node || !outgoingEdges.has(nodeId))
      return false;
    if (!node.isChild)
      return true;
    return !hasIncomingEdge.has(nodeId);
  }
  function buildChildHierarchy(parentId, visited) {
    const childIds = outgoingEdges.get(parentId);
    if (!childIds || childIds.size === 0)
      return [];
    const children = [];
    for (const childId of childIds) {
      if (visited.has(childId))
        continue;
      const childNode = nodeMap.get(childId);
      if (!childNode)
        continue;
      if (!childNode.isChild)
        continue;
      const newVisited = new Set(visited);
      newVisited.add(childId);
      if (outgoingEdges.has(childId)) {
        const grandchildren = buildChildHierarchy(childId, newVisited);
        children.push({
          parent: childNode,
          children: grandchildren
        });
      } else {
        children.push(childNode);
      }
    }
    children.sort((a, b) => {
      const aTime = "time" in a ? new Date(a.time).getTime() : new Date(a.parent.time).getTime();
      const bTime = "time" in b ? new Date(b.time).getTime() : new Date(b.parent.time).getTime();
      return aTime - bTime;
    });
    return children;
  }
  const groups = [];
  for (const [parentId, _] of outgoingEdges) {
    if (!isRootParent(parentId))
      continue;
    const parent = nodeMap.get(parentId);
    const visited = /* @__PURE__ */ new Set([parentId]);
    const children = buildChildHierarchy(parentId, visited);
    groups.push({ parent, children });
  }
  groups.sort((a, b) => new Date(a.parent.time).getTime() - new Date(b.parent.time).getTime());
  const badDirectionalCards = [];
  for (const ioc of iocData) {
    if (ioc.isChild)
      continue;
    const incomingSources = incomingFrom.get(ioc.id);
    if (!incomingSources || incomingSources.size === 0)
      continue;
    let hasChildSource = false;
    for (const sourceId of incomingSources) {
      const sourceNode = nodeMap.get(sourceId);
      if (sourceNode && sourceNode.isChild) {
        hasChildSource = true;
        break;
      }
    }
    if (hasChildSource) {
      badDirectionalCards.push(ioc);
    }
  }
  badDirectionalCards.sort((a, b) => new Date(a.time).getTime() - new Date(b.time).getTime());
  return { groups, badDirectionalCards };
}

// src/timeline/LinkTimelineCardRow.ts
function renderIOCCardRow(opts) {
  const { container, ioc, showConnector = false, depth = 0, extraClasses = [] } = opts;
  const rowEl = container.createDiv("link-timeline-child");
  extraClasses.forEach((cls) => rowEl.classList.add(cls));
  if (depth > 0) {
    rowEl.classList.add(`depth-${depth}`);
    rowEl.style.marginLeft = `${depth * 30}px`;
  }
  rowEl.style.borderLeftColor = ioc.color;
  if (showConnector) {
    rowEl.createDiv("link-timeline-connector");
  }
  rowEl.createEl("span", {
    text: ioc.isChild ? "[C]" : "[P]",
    cls: `link-timeline-role-badge ${ioc.isChild ? "role-child" : "role-parent"}`
  });
  const iconEl = rowEl.createDiv("link-timeline-icon");
  iconEl.innerHTML = ioc.icon;
  iconEl.style.color = ioc.color;
  const detailsEl = rowEl.createDiv("link-timeline-details");
  detailsEl.createEl("strong", { text: ioc.type });
  if (ioc.time) {
    detailsEl.createEl("span", { text: ` | ${ioc.time}`, cls: "link-timeline-time" });
  }
  if (ioc.cardId) {
    detailsEl.createEl("span", { text: ` | ${ioc.cardId}`, cls: "link-timeline-card-id" });
  }
  if (ioc.value && ioc.value.trim()) {
    detailsEl.createDiv({ text: ioc.value, cls: "link-timeline-value" });
  }
  if (ioc.tactic) {
    detailsEl.createDiv({ text: `Tactic: ${ioc.tactic}`, cls: "link-timeline-tactic" });
  }
  if (ioc.technique) {
    detailsEl.createDiv({ text: `Technique: ${ioc.technique}`, cls: "link-timeline-technique" });
  }
  return rowEl;
}

// src/timeline/LinkTimelineTab.ts
function isParentChildGroup(item) {
  return "children" in item && Array.isArray(item.children);
}
function renderLinkTimeline(container, result) {
  const { groups, badDirectionalCards } = result;
  if (groups.length === 0) {
    container.createEl("p", {
      text: "No IOC cards found. Create parent and child cards, then draw arrows between them.",
      cls: "timeline-empty-message"
    });
    return;
  }
  const linkedGroups = groups.filter((g) => g.children.length > 0);
  if (linkedGroups.length === 0) {
    container.createEl("p", {
      text: "No parent-child relationships found. Draw arrows between IOC cards to create links (arrow from parent to child).",
      cls: "timeline-empty-message"
    });
  }
  function renderChild(childrenContainer, child, depth) {
    if (isParentChildGroup(child)) {
      renderNestedGroup(childrenContainer, child, depth);
    } else {
      renderLeafNode(childrenContainer, child, depth);
    }
  }
  function renderLeafNode(childrenContainer, child, depth) {
    renderIOCCardRow({
      container: childrenContainer,
      ioc: child,
      showConnector: true,
      depth
    });
  }
  function renderNestedGroup(childrenContainer, group, depth) {
    const nestedGroupEl = childrenContainer.createDiv("link-timeline-child link-timeline-nested-parent");
    nestedGroupEl.classList.add(`depth-${depth}`);
    nestedGroupEl.style.borderLeftColor = group.parent.color;
    nestedGroupEl.style.marginLeft = `${depth * 30}px`;
    nestedGroupEl.createDiv("link-timeline-connector");
    const toggleEl = nestedGroupEl.createDiv("link-timeline-expand-toggle");
    toggleEl.textContent = "\u25B6";
    toggleEl.classList.add("has-children");
    nestedGroupEl.createEl("span", {
      text: group.parent.isChild ? "[C]" : "[P]",
      cls: `link-timeline-role-badge ${group.parent.isChild ? "role-child" : "role-parent"}`
    });
    const iconEl = nestedGroupEl.createDiv("link-timeline-icon");
    iconEl.innerHTML = group.parent.icon;
    iconEl.style.color = group.parent.color;
    const detailsEl = nestedGroupEl.createDiv("link-timeline-details");
    detailsEl.createEl("strong", { text: group.parent.type });
    if (group.parent.time) {
      detailsEl.createEl("span", { text: ` | ${group.parent.time}`, cls: "link-timeline-time" });
    }
    if (group.parent.cardId) {
      detailsEl.createEl("span", { text: ` | ${group.parent.cardId}`, cls: "link-timeline-card-id" });
    }
    if (group.parent.value && group.parent.value.trim()) {
      detailsEl.createDiv({ text: group.parent.value, cls: "link-timeline-value" });
    }
    nestedGroupEl.createEl("span", {
      text: String(group.children.length),
      cls: "link-timeline-count"
    });
    const nestedChildrenEl = childrenContainer.createDiv("link-timeline-nested-children");
    nestedChildrenEl.style.display = "none";
    group.children.forEach((nestedChild) => {
      renderChild(nestedChildrenEl, nestedChild, depth + 1);
    });
    nestedGroupEl.style.cursor = "pointer";
    nestedGroupEl.addEventListener("click", (e) => {
      e.stopPropagation();
      const isExpanded = nestedChildrenEl.style.display !== "none";
      nestedChildrenEl.style.display = isExpanded ? "none" : "block";
      toggleEl.textContent = isExpanded ? "\u25B6" : "\u25BC";
      toggleEl.classList.toggle("expanded", !isExpanded);
    });
  }
  groups.forEach((group) => {
    const groupEl = container.createDiv("link-timeline-group");
    const parentEl = groupEl.createDiv("link-timeline-parent");
    parentEl.style.borderLeftColor = group.parent.color;
    const hasChildren = group.children.length > 0;
    const toggleEl = parentEl.createDiv("link-timeline-expand-toggle");
    if (hasChildren) {
      toggleEl.textContent = "\u25B6";
      toggleEl.classList.add("has-children");
    }
    const roleBadge = parentEl.createEl("span", {
      text: group.parent.isChild ? "[C]" : "[P]",
      cls: `link-timeline-role-badge ${group.parent.isChild ? "role-child" : "role-parent"}`
    });
    const iconEl = parentEl.createDiv("link-timeline-icon");
    iconEl.innerHTML = group.parent.icon;
    iconEl.style.color = group.parent.color;
    const detailsEl = parentEl.createDiv("link-timeline-details");
    detailsEl.createEl("strong", { text: group.parent.type });
    if (group.parent.time) {
      detailsEl.createEl("span", { text: ` | ${group.parent.time}`, cls: "link-timeline-time" });
    }
    if (group.parent.cardId) {
      detailsEl.createEl("span", { text: ` | ${group.parent.cardId}`, cls: "link-timeline-card-id" });
    }
    if (group.parent.value && group.parent.value.trim()) {
      detailsEl.createDiv({ text: group.parent.value, cls: "link-timeline-value" });
    }
    if (hasChildren) {
      parentEl.createEl("span", {
        text: String(group.children.length),
        cls: "link-timeline-count"
      });
    }
    const childrenEl = groupEl.createDiv("link-timeline-children");
    childrenEl.style.display = "none";
    group.children.forEach((child) => {
      renderChild(childrenEl, child, 0);
    });
    if (hasChildren) {
      parentEl.style.cursor = "pointer";
      parentEl.addEventListener("click", () => {
        const isExpanded = childrenEl.style.display !== "none";
        childrenEl.style.display = isExpanded ? "none" : "block";
        toggleEl.textContent = isExpanded ? "\u25B6" : "\u25BC";
        toggleEl.classList.toggle("expanded", !isExpanded);
      });
    }
  });
  if (badDirectionalCards.length > 0) {
    const errorSection = container.createDiv("link-timeline-error-section");
    const errorHeader = errorSection.createDiv("link-timeline-error-header");
    errorHeader.textContent = "\u26A0\uFE0F Cards with Child\u2192Parent Arrows";
    const errorDesc = errorSection.createDiv("link-timeline-error-description");
    errorDesc.textContent = "These cards are marked [P] (parent) but have incoming arrows FROM [C] (child) cards. Child cards should not point to parent cards. Note: Parent\u2192Parent arrows are allowed.";
    badDirectionalCards.forEach((card) => {
      const errorItem = errorSection.createDiv("link-timeline-error-item");
      errorItem.style.borderLeftColor = card.color;
      errorItem.createEl("span", {
        text: "[P]",
        cls: "link-timeline-role-badge role-parent"
      });
      const iconEl = errorItem.createDiv("link-timeline-icon");
      iconEl.innerHTML = card.icon;
      iconEl.style.color = card.color;
      const detailsEl = errorItem.createDiv("link-timeline-details");
      detailsEl.createEl("strong", { text: card.type });
      if (card.time) {
        detailsEl.createEl("span", { text: ` | ${card.time}`, cls: "link-timeline-time" });
      }
      if (card.cardId) {
        detailsEl.createEl("span", { text: ` | ${card.cardId}`, cls: "link-timeline-card-id" });
      }
      if (card.value && card.value.trim()) {
        detailsEl.createDiv({ text: card.value, cls: "link-timeline-value" });
      }
    });
  }
}

// src/timeline/RenderTimelinesModal.ts
var RenderTimelinesModal = class extends import_obsidian4.Modal {
  constructor(app, plugin) {
    super(app);
    this.plugin = plugin;
  }
  onOpen() {
    const { contentEl } = this;
    this.modalEl.classList.add("timeline-modal-fullscreen");
    const iocData = extractFixedIOCData(this.app);
    if (DEBUG)
      console.debug("[TimelineModal] Extracted", iocData.length, "IOC cards");
    const sortedData = [...iocData].sort(
      (a, b) => new Date(a.time).getTime() - new Date(b.time).getTime()
    );
    const headerContainer = contentEl.createDiv("timeline-modal-header");
    headerContainer.createEl("h2", { text: "IOC Timeline" });
    const tabBar = contentEl.createDiv("timeline-tab-bar");
    const tabs = [
      { id: "time", label: "Time Timeline" },
      { id: "graph", label: "Graph" },
      { id: "link", label: "Link Timeline" }
    ];
    const tabContents = {};
    const tabButtons = [];
    tabs.forEach((tab, idx) => {
      const btn = tabBar.createEl("button", {
        text: tab.label,
        cls: "timeline-tab-button"
      });
      if (idx === 0)
        btn.classList.add("active");
      tabButtons.push(btn);
      btn.addEventListener("click", () => {
        tabButtons.forEach((b) => b.classList.remove("active"));
        btn.classList.add("active");
        Object.values(tabContents).forEach((c) => c.style.display = "none");
        tabContents[tab.id].style.display = "block";
      });
    });
    const contentArea = contentEl.createDiv("timeline-tab-content-area");
    const timeTab = contentArea.createDiv("timeline-tab-pane");
    tabContents["time"] = timeTab;
    renderTimeTimeline(timeTab, sortedData);
    const graphTab = contentArea.createDiv("timeline-tab-pane");
    graphTab.style.display = "none";
    tabContents["graph"] = graphTab;
    renderGraphTimeline(graphTab, sortedData);
    const linkTab = contentArea.createDiv("timeline-tab-pane");
    linkTab.style.display = "none";
    tabContents["link"] = linkTab;
    const edges = getCanvasEdges(this.app);
    const result = buildParentChildGroups(iocData, edges);
    renderLinkTimeline(linkTab, result);
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/mitre/RenderMitreModal.ts
var import_obsidian5 = require("obsidian");

// src/mitre/MitreStixParser.ts
var TACTIC_ABBREVIATIONS = {
  "Reconnaissance": ["RECON", "RECCE", "RE"],
  "Resource Development": ["RESOURCE", "RES", "RD"],
  "Initial Access": ["IA", "INIT"],
  "Execution": ["EXEC", "EXE", "EX"],
  "Persistence": ["PERSIST", "PERS", "PS"],
  "Privilege Escalation": ["PRIV", "PE", "PRIVESC", "PRIV ESC"],
  "Defense Evasion": ["DEFENSE", "DEF", "DE"],
  "Credential Access": ["CRED", "CA", "CRED ACCESS"],
  "Discovery": ["DISC", "DIS", "DI"],
  "Lateral Movement": ["LATERAL", "LM", "LAT MOVE"],
  "Collection": ["COLLECT", "COL", "CO"],
  "Command and Control": ["C2", "CNC", "CC"],
  "Exfiltration": ["EXFIL", "EXFILTRATE"],
  "Impact": ["IMP", "IM"]
};
function generateAbbreviations(tacticName) {
  const abbrevs = [];
  const words = tacticName.split(/[\s\-]+/);
  if (words.length > 0) {
    abbrevs.push(words.map((w) => w[0]).join("").toUpperCase());
  }
  if (TACTIC_ABBREVIATIONS[tacticName]) {
    abbrevs.push(...TACTIC_ABBREVIATIONS[tacticName]);
  }
  return abbrevs;
}
function parseStixBundle(stixBundle) {
  var _a, _b, _c, _d, _e, _f, _g, _h;
  if (DEBUG)
    console.debug("[MitreLoader] Parsing STIX bundle with", (_a = stixBundle.objects) == null ? void 0 : _a.length, "objects");
  const tactics = {};
  const techniques = {};
  let version = "unknown";
  let last_updated = new Date().toISOString().split("T")[0];
  for (const obj of stixBundle.objects) {
    if (obj.type === "x-mitre-collection") {
      version = obj.x_mitre_version || "unknown";
      last_updated = ((_b = obj.modified) == null ? void 0 : _b.split("T")[0]) || last_updated;
      if (DEBUG)
        console.debug("[MitreLoader] Found collection metadata - version:", version, "updated:", last_updated);
    }
  }
  for (const obj of stixBundle.objects) {
    if (obj.type === "x-mitre-tactic" && !obj.x_mitre_deprecated) {
      const tacticId = (_d = (_c = obj.external_references) == null ? void 0 : _c.find((ref) => ref.source_name === "mitre-attack")) == null ? void 0 : _d.external_id;
      if (!tacticId)
        continue;
      const shortName = obj.x_mitre_shortname || tacticId.toLowerCase();
      tactics[tacticId] = {
        id: tacticId,
        name: obj.name,
        short_name: shortName,
        description: obj.description || "",
        abbreviations: generateAbbreviations(obj.name)
      };
    }
  }
  if (DEBUG)
    console.debug("[MitreLoader] Parsed", Object.keys(tactics).length, "tactics");
  const shortNameToTacticId = /* @__PURE__ */ new Map();
  for (const [tacticId, tactic] of Object.entries(tactics)) {
    shortNameToTacticId.set(tactic.short_name, tacticId);
  }
  for (const obj of stixBundle.objects) {
    if (obj.type === "attack-pattern" && !obj.x_mitre_deprecated) {
      const techniqueId = (_f = (_e = obj.external_references) == null ? void 0 : _e.find((ref) => ref.source_name === "mitre-attack")) == null ? void 0 : _f.external_id;
      if (!techniqueId)
        continue;
      const tacticIds = [];
      if (obj.kill_chain_phases) {
        for (const phase of obj.kill_chain_phases) {
          if (phase.kill_chain_name === "mitre-attack") {
            const tacticId = shortNameToTacticId.get(phase.phase_name);
            if (tacticId) {
              tacticIds.push(tacticId);
            }
          }
        }
      }
      let parent;
      if (obj.x_mitre_is_subtechnique && techniqueId.includes(".")) {
        parent = techniqueId.split(".")[0];
      }
      techniques[techniqueId] = {
        id: techniqueId,
        name: obj.name,
        description: obj.description || "",
        tactics: tacticIds,
        parent,
        url: ((_h = (_g = obj.external_references) == null ? void 0 : _g.find((ref) => ref.source_name === "mitre-attack")) == null ? void 0 : _h.url) || `https://attack.mitre.org/techniques/${techniqueId.replace(".", "/")}`
      };
    }
  }
  if (DEBUG)
    console.debug("[MitreLoader] Parsed", Object.keys(techniques).length, "techniques");
  return {
    version,
    last_updated,
    tactics,
    techniques
  };
}

// src/mitre/MitreValidation.ts
function normalizeTacticName(name, dataset) {
  const normalized = name.toLowerCase().replace(/[\s\-_]+/g, "");
  if (DEBUG)
    console.debug("[MitreLoader] Normalizing tactic:", name, "\u2192", normalized);
  for (const [tacticId, tactic] of Object.entries(dataset.tactics)) {
    if (tactic.short_name.replace(/\-/g, "") === normalized) {
      if (DEBUG)
        console.debug("[MitreLoader] Matched by short_name:", tactic.name, "(" + tacticId + ")");
      return tacticId;
    }
  }
  for (const [tacticId, tactic] of Object.entries(dataset.tactics)) {
    if (tactic.name.toLowerCase().replace(/[\s\-_]+/g, "") === normalized) {
      if (DEBUG)
        console.debug("[MitreLoader] Matched by full name:", tactic.name, "(" + tacticId + ")");
      return tacticId;
    }
  }
  const upper = name.toUpperCase().trim();
  for (const [tacticId, tactic] of Object.entries(dataset.tactics)) {
    if (tactic.abbreviations.includes(upper)) {
      if (DEBUG)
        console.debug("[MitreLoader] Matched by abbreviation:", upper, "\u2192", tactic.name, "(" + tacticId + ")");
      return tacticId;
    }
  }
  if (DEBUG)
    console.debug("[MitreLoader] No match found for:", name);
  return null;
}
function validateTechniqueTactic(techniqueId, tacticInput, dataset) {
  const tacticId = normalizeTacticName(tacticInput, dataset);
  if (!tacticId) {
    return {
      severity: "unknown_tactic",
      message: `Unknown tactic: "${tacticInput}"`
    };
  }
  const technique = dataset.techniques[techniqueId];
  if (!technique) {
    return {
      severity: "unknown_technique",
      message: `Unknown technique: "${techniqueId}"`
    };
  }
  if (!technique.tactics.includes(tacticId)) {
    const validTactics = technique.tactics.map((tid) => {
      var _a;
      return ((_a = dataset.tactics[tid]) == null ? void 0 : _a.name) || tid;
    }).join(", ");
    return {
      severity: "mismatch",
      message: `${techniqueId} (${technique.name}) does not belong to ${dataset.tactics[tacticId].name}. Valid tactics: ${validTactics}`,
      tacticId
    };
  }
  return {
    severity: "valid",
    tacticId
  };
}

// src/mitre/MitreLoader.ts
var cachedDataset = null;
async function loadMitreDataset(app) {
  if (cachedDataset) {
    if (DEBUG)
      console.debug("[MitreLoader] Returning cached dataset");
    return cachedDataset;
  }
  try {
    const adapter = app.vault.adapter;
    const jsonPath = ".obsidian/plugins/cyber_canvas/MITRE/enterprise-attack.json";
    if (DEBUG)
      console.debug("[MitreLoader] Attempting to load from:", jsonPath);
    if (await adapter.exists(jsonPath)) {
      const content = await adapter.read(jsonPath);
      const stixBundle = JSON.parse(content);
      if (stixBundle.type === "bundle" && Array.isArray(stixBundle.objects)) {
        if (DEBUG)
          console.debug("[MitreLoader] Parsing STIX 2.1 bundle format...");
        cachedDataset = parseStixBundle(stixBundle);
        if (DEBUG)
          console.debug("[MitreLoader] Loaded full dataset from STIX bundle. Tactics:", Object.keys(cachedDataset.tactics).length, "Techniques:", Object.keys(cachedDataset.techniques).length);
        return cachedDataset;
      } else if (stixBundle.version && stixBundle.tactics && stixBundle.techniques) {
        cachedDataset = stixBundle;
        if (DEBUG)
          console.debug("[MitreLoader] Loaded pre-processed dataset. Version:", cachedDataset.version, "Techniques:", Object.keys(cachedDataset.techniques).length);
        return cachedDataset;
      } else {
        console.warn("[MitreLoader] Unknown JSON format");
      }
    } else {
      console.error("[MitreLoader] JSON file not found at:", jsonPath);
      throw new Error(
        "MITRE ATT&CK dataset not found. Please ensure enterprise-attack.json exists in the MITRE folder. Download from: https://github.com/mitre-attack/attack-stix-data"
      );
    }
  } catch (err) {
    console.error("[MitreLoader] Failed to load MITRE dataset:", err);
    throw new Error(
      "MITRE ATT&CK dataset not found. Please ensure enterprise-attack.json exists in the MITRE folder. Download from: https://github.com/mitre-attack/attack-stix-data"
    );
  }
  throw new Error("MITRE ATT&CK dataset could not be loaded");
}

// src/mitre/MitreAggregatorTypes.ts
var TACTIC_ORDER = [
  "TA0043",
  // Reconnaissance
  "TA0042",
  // Resource Development
  "TA0001",
  // Initial Access
  "TA0002",
  // Execution
  "TA0003",
  // Persistence
  "TA0004",
  // Privilege Escalation
  "TA0005",
  // Defense Evasion
  "TA0006",
  // Credential Access
  "TA0007",
  // Discovery
  "TA0008",
  // Lateral Movement
  "TA0009",
  // Collection
  "TA0011",
  // Command and Control
  "TA0010",
  // Exfiltration
  "TA0040"
  // Impact
];
function extractTechniqueId(technique) {
  const idMatch = technique.match(/T\d{4}(?:\.\d{3})?/i);
  if (idMatch) {
    const techniqueId = idMatch[0].toUpperCase();
    if (DEBUG)
      console.debug("[MitreAggregator] Extracted technique ID:", techniqueId, "from:", technique);
    return techniqueId;
  }
  if (DEBUG)
    console.debug("[MitreAggregator] No technique ID found in:", technique, "- using raw string");
  return technique.trim();
}
function extractTechniqueName(technique, dataset) {
  const dashMatch = technique.match(/T\d{4}(?:\.\d{3})?\s*-\s*(.+)/);
  if (dashMatch) {
    const name = dashMatch[1].trim();
    if (DEBUG)
      console.debug("[MitreAggregator] Extracted name from dash format:", name);
    return name;
  }
  const parenMatch = technique.match(/(.+?)\s*\(T\d{4}(?:\.\d{3})?\)/);
  if (parenMatch) {
    const name = parenMatch[1].trim();
    if (DEBUG)
      console.debug("[MitreAggregator] Extracted name from paren format:", name);
    return name;
  }
  const idOnlyMatch = technique.match(/^T\d{4}(?:\.\d{3})?$/);
  if (idOnlyMatch && dataset) {
    const techData = dataset.techniques[idOnlyMatch[0]];
    if (techData) {
      if (DEBUG)
        console.debug("[MitreAggregator] Looked up name for ID:", idOnlyMatch[0], "->", techData.name);
      return techData.name;
    }
  }
  if (DEBUG)
    console.debug("[MitreAggregator] Using raw technique string as name:", technique);
  return technique.trim();
}

// src/mitre/MitreSeverity.ts
function isCriticalSeverity(severity) {
  return severity === "unknown_technique" || severity === "unknown_tactic";
}
function getSeverityIcon(severity) {
  return isCriticalSeverity(severity) ? "\u{1F534}" : "\u26A0\uFE0F";
}
function applySeverityClass(element, severity) {
  if (severity === "valid") {
    element.addClass("mitre-technique-valid");
  } else if (isCriticalSeverity(severity)) {
    element.addClass("mitre-technique-error");
  } else if (severity === "mismatch") {
    element.addClass("mitre-technique-warning");
  }
}
function shouldOverrideSeverity(newSeverity, existingSeverity) {
  const severityRank = {
    "unknown_technique": 4,
    "unknown_tactic": 3,
    "mismatch": 2,
    "valid": 1
  };
  return severityRank[newSeverity] > severityRank[existingSeverity];
}

// src/mitre/MitreAggregatorCardProcessing.ts
function markParentAsFound(techniqueId, foundTechniques, tactic) {
  if (!techniqueId.includes("."))
    return;
  const parentId = techniqueId.split(".")[0];
  if (foundTechniques.has(parentId)) {
    const existing = foundTechniques.get(parentId);
    existing.count++;
  } else {
    foundTechniques.set(parentId, {
      count: 1,
      iocCards: [],
      // Empty - cards reference subtechniques, not parent
      severity: "valid",
      validationMessage: void 0,
      userProvidedTactic: tactic
    });
  }
  if (DEBUG)
    console.debug("[MitreAggregator] Marked parent technique as found:", {
      subtechnique: techniqueId,
      parent: parentId,
      tactic
    });
}
function buildFoundTechniquesFromIOC(iocData, dataset) {
  const foundTechniques = /* @__PURE__ */ new Map();
  const cardValidations = /* @__PURE__ */ new Map();
  const missingTacticCards = [];
  const missingTechniqueCards = [];
  let iocCount = 0;
  iocData.forEach((ioc) => {
    const rawTactic = (ioc.tactic || "").trim();
    const rawTechnique = (ioc.technique || "").trim();
    if (DEBUG)
      console.debug("[MitreAggregator] Processing IOC card:", {
        cardId: ioc.cardId || "(no ID)",
        type: ioc.type,
        nodeId: ioc.id,
        rawTactic: rawTactic || "(empty)",
        rawTechnique: rawTechnique || "(empty)"
      });
    if (!rawTechnique) {
      if (DEBUG)
        console.debug("[MitreAggregator] IOC card has empty technique:", ioc.id);
      const missingInfo = {
        cardId: ioc.cardId || ioc.id,
        iocType: ioc.type,
        nodeId: ioc.id,
        missing: !rawTactic ? "both" : "technique"
      };
      missingTechniqueCards.push(missingInfo);
      if (!rawTactic) {
        missingTacticCards.push({ ...missingInfo, missing: "both" });
      }
      iocCount++;
      return;
    }
    const technique = rawTechnique;
    const techniqueId = extractTechniqueId(technique);
    const techniqueName = extractTechniqueName(technique, dataset);
    if (!rawTactic) {
      if (DEBUG)
        console.debug("[MitreAggregator] IOC card has empty tactic:", ioc.id);
      missingTacticCards.push({
        cardId: ioc.cardId || ioc.id,
        iocType: ioc.type,
        nodeId: ioc.id,
        missing: "tactic"
      });
      iocCount++;
      if (!foundTechniques.has(techniqueId)) {
        foundTechniques.set(techniqueId, {
          count: 1,
          iocCards: [ioc.id],
          severity: "valid",
          // No severity penalty for missing tactic
          validationMessage: void 0,
          userProvidedTactic: "(empty)"
        });
      } else {
        const existing = foundTechniques.get(techniqueId);
        existing.count++;
        existing.iocCards.push(ioc.id);
      }
      markParentAsFound(techniqueId, foundTechniques, "(empty)");
      return;
    }
    const tactic = rawTactic;
    const validation = validateTechniqueTactic(techniqueId, tactic, dataset);
    if (DEBUG)
      console.debug("[MitreAggregator] Validated technique:", {
        cardId: ioc.cardId || ioc.id,
        techniqueId,
        tactic,
        severity: validation.severity,
        message: validation.message || "valid"
      });
    iocCount++;
    cardValidations.set(ioc.id, {
      cardId: ioc.cardId || ioc.id,
      techniqueId,
      techniqueName,
      tactic,
      severity: validation.severity,
      validationMessage: validation.message,
      iocType: ioc.type,
      nodeId: ioc.id
    });
    if (foundTechniques.has(techniqueId)) {
      const existing = foundTechniques.get(techniqueId);
      existing.count++;
      existing.iocCards.push(ioc.id);
      if (shouldOverrideSeverity(validation.severity, existing.severity)) {
        existing.severity = validation.severity;
        existing.validationMessage = validation.message;
      }
    } else {
      foundTechniques.set(techniqueId, {
        count: 1,
        iocCards: [ioc.id],
        severity: validation.severity,
        validationMessage: validation.message,
        userProvidedTactic: tactic
      });
    }
    markParentAsFound(techniqueId, foundTechniques, tactic);
  });
  if (DEBUG)
    console.debug("[MitreAggregator] Found", foundTechniques.size, "unique techniques in IOC cards");
  return {
    foundTechniques,
    cardValidations,
    missingTacticCards,
    missingTechniqueCards,
    iocCount
  };
}

// src/mitre/MitreAggregator.ts
function aggregateTacticsTechniques(iocData, dataset) {
  if (DEBUG)
    console.debug("[MitreAggregator] Starting full matrix aggregation with", iocData.length, "IOC cards");
  if (DEBUG)
    console.debug("[MitreAggregator] Dataset has", Object.keys(dataset.techniques).length, "techniques");
  const iocDataMap = /* @__PURE__ */ new Map();
  iocData.forEach((ioc) => {
    iocDataMap.set(ioc.id, ioc);
  });
  const {
    foundTechniques,
    cardValidations,
    missingTacticCards,
    missingTechniqueCards,
    iocCount
  } = buildFoundTechniquesFromIOC(iocData, dataset);
  const tacticMap = /* @__PURE__ */ new Map();
  Object.values(dataset.tactics).forEach((tacticData) => {
    tacticMap.set(tacticData.id, {
      name: tacticData.id,
      displayName: `${tacticData.name} (${tacticData.id})`,
      techniques: []
    });
  });
  const subtechniquesMap = /* @__PURE__ */ new Map();
  Object.values(dataset.techniques).forEach((techData) => {
    const foundData = foundTechniques.get(techData.id);
    const isFound = !!foundData;
    const techniqueObj = {
      id: techData.id,
      name: techData.name,
      tactic: "",
      tacticId: "",
      count: (foundData == null ? void 0 : foundData.count) || 0,
      iocCards: (foundData == null ? void 0 : foundData.iocCards) || [],
      severity: (foundData == null ? void 0 : foundData.severity) || "not_found",
      validationMessage: foundData == null ? void 0 : foundData.validationMessage,
      description: techData.description,
      isFound
    };
    if (techData.parent) {
      if (!subtechniquesMap.has(techData.parent)) {
        subtechniquesMap.set(techData.parent, []);
      }
      if (techData.tactics.length > 0) {
        techniqueObj.tactic = (foundData == null ? void 0 : foundData.userProvidedTactic) || techData.tactics[0];
        techniqueObj.tacticId = techData.tactics[0];
      }
      subtechniquesMap.get(techData.parent).push(techniqueObj);
      if (DEBUG)
        console.debug("[MitreAggregator] Added subtechnique:", {
          id: techData.id,
          parent: techData.parent,
          isFound,
          totalSubtechniques: subtechniquesMap.get(techData.parent).length
        });
      return;
    }
    techData.tactics.forEach((tacticId) => {
      if (!tacticMap.has(tacticId)) {
        console.warn("[MitreAggregator] Unknown tactic ID in dataset:", tacticId);
        return;
      }
      const tactic = tacticMap.get(tacticId);
      tactic.techniques.push({
        ...techniqueObj,
        tactic: (foundData == null ? void 0 : foundData.userProvidedTactic) || tacticId,
        tacticId
      });
    });
  });
  const tactics = Array.from(tacticMap.values());
  tactics.sort((a, b) => {
    const indexA = TACTIC_ORDER.indexOf(a.name);
    const indexB = TACTIC_ORDER.indexOf(b.name);
    if (indexA === -1)
      return 1;
    if (indexB === -1)
      return -1;
    return indexA - indexB;
  });
  tactics.forEach((tactic) => {
    tactic.techniques.sort((a, b) => {
      if (a.isFound && !b.isFound)
        return -1;
      if (!a.isFound && b.isFound)
        return 1;
      return a.id.localeCompare(b.id);
    });
  });
  if (DEBUG)
    console.debug("[MitreAggregator] Full matrix built:", {
      totalTactics: tactics.length,
      totalTechniques: tactics.reduce((sum, t) => sum + t.techniques.length, 0),
      foundTechniques: foundTechniques.size
    });
  if (DEBUG)
    console.debug("[MitreAggregator] Collecting validation errors from card-level validation...");
  const validationErrors = [];
  const errorsByTechnique = /* @__PURE__ */ new Map();
  cardValidations.forEach((cardValidation, cardId) => {
    if (cardValidation.severity !== "valid") {
      const key = `${cardValidation.techniqueId}-${cardValidation.severity}`;
      if (!errorsByTechnique.has(key)) {
        errorsByTechnique.set(key, {
          techniqueId: cardValidation.techniqueId,
          techniqueName: cardValidation.techniqueName,
          severity: cardValidation.severity,
          message: cardValidation.validationMessage || "Validation error",
          cards: []
        });
      }
      errorsByTechnique.get(key).cards.push({
        cardId: cardValidation.cardId,
        iocType: cardValidation.iocType,
        nodeId: cardValidation.nodeId
      });
    }
  });
  errorsByTechnique.forEach((errorData) => {
    validationErrors.push({
      techniqueId: errorData.techniqueId,
      techniqueName: errorData.techniqueName,
      severity: errorData.severity,
      message: errorData.message,
      iocCards: errorData.cards
    });
  });
  if (DEBUG)
    console.debug("[MitreAggregator] Aggregation complete:", {
      errorGroups: validationErrors.length,
      cardsWithErrors: Array.from(cardValidations.values()).filter((v) => v.severity !== "valid").length,
      missingTactic: missingTacticCards.length,
      missingTechnique: missingTechniqueCards.length
    });
  return {
    tactics,
    validationErrors,
    subtechniquesMap,
    iocDataMap,
    iocCount,
    missingFields: {
      missingTactic: missingTacticCards,
      missingTechnique: missingTechniqueCards
    }
  };
}

// src/mitre/MitreExport.ts
function exportToNavigator(tactics, iocCount, dataset) {
  if (DEBUG)
    console.debug("[MitreExport] Starting export -", tactics.length, "tactics,", iocCount, "IOC cards");
  const layer = {
    name: "Cyber Canvas IOC Analysis",
    versions: {
      attack: "14",
      navigator: "4.9.4",
      layer: "4.5"
    },
    domain: "enterprise-attack",
    description: `Generated from ${iocCount} IOC cards in Obsidian Canvas`,
    filters: {
      platforms: ["windows", "linux", "macos"]
    },
    sorting: 0,
    layout: {
      layout: "side",
      aggregateFunction: "average",
      showID: true,
      showName: true,
      showAggregateScores: false,
      countUnscored: false
    },
    hideDisabled: false,
    techniques: [],
    gradient: {
      colors: ["#ff6666", "#ffe766", "#8ec843"],
      minValue: 0,
      maxValue: 100
    },
    legendItems: [],
    metadata: [],
    links: [],
    showTacticRowBackground: true,
    tacticRowBackground: "#dddddd",
    selectTechniquesAcrossTactics: true,
    selectSubtechniquesWithParent: false
  };
  tactics.forEach((tactic) => {
    tactic.techniques.forEach((technique) => {
      if (!technique.isFound)
        return;
      const tacticData = dataset.tactics[technique.tacticId];
      const tacticShortName = (tacticData == null ? void 0 : tacticData.short_name) || tactic.name.toLowerCase().replace(/\s+/g, "-");
      let color;
      if (technique.severity === "valid") {
        color = "#66bb6a";
      } else if (isCriticalSeverity(technique.severity)) {
        color = "#f44336";
      } else if (technique.severity === "mismatch") {
        color = "#ffa500";
      } else {
        color = "#66bb6a";
      }
      let comment = `Used in ${technique.count} IOC card${technique.count > 1 ? "s" : ""}`;
      if (technique.severity !== "valid" && technique.validationMessage) {
        comment += `
${getSeverityIcon(technique.severity)} ${technique.validationMessage}`;
      }
      layer.techniques.push({
        techniqueID: technique.id,
        tactic: tacticShortName,
        color,
        comment,
        enabled: true,
        metadata: [
          { name: "severity", value: technique.severity },
          { name: "ioc_cards", value: technique.iocCards.join(", ") }
        ],
        links: [],
        showSubtechniques: false,
        score: technique.count * 10
        // Scale count for visual weight
      });
    });
  });
  if (DEBUG)
    console.debug("[MitreExport] Exported", layer.techniques.length, "techniques to Navigator format");
  const jsonString = JSON.stringify(layer, null, 2);
  const blob = new Blob([jsonString], { type: "application/json" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = `mitre-navigator-${Date.now()}.json`;
  a.click();
  URL.revokeObjectURL(url);
}

// src/mitre/MitreResizable.ts
function makeResizable(modal) {
  if (DEBUG)
    console.debug("[MitreResizable] Attaching resize handles");
  const MIN_WIDTH = 600;
  const MIN_HEIGHT = 400;
  const MAX_WIDTH = window.innerWidth * 0.95;
  const MAX_HEIGHT = window.innerHeight * 0.95;
  const handles = [
    ["resize-handle-n", "ns-resize", false],
    // Top edge
    ["resize-handle-s", "ns-resize", false],
    // Bottom edge
    ["resize-handle-e", "ew-resize", false],
    // Right edge
    ["resize-handle-w", "ew-resize", false],
    // Left edge
    ["resize-handle-ne", "nesw-resize", true],
    // Top-right corner
    ["resize-handle-nw", "nwse-resize", true],
    // Top-left corner
    ["resize-handle-se", "nwse-resize", true],
    // Bottom-right corner
    ["resize-handle-sw", "nesw-resize", true]
    // Bottom-left corner
  ];
  handles.forEach(([className, cursor, isCorner]) => {
    const handle = modal.createDiv(`mitre-resize-handle ${className}`);
    handle.style.cursor = cursor;
    let startX = 0, startY = 0, startWidth = 0, startHeight = 0, startLeft = 0, startTop = 0;
    const onMouseDown = (e) => {
      e.preventDefault();
      e.stopPropagation();
      startX = e.clientX;
      startY = e.clientY;
      const rect = modal.getBoundingClientRect();
      startWidth = rect.width;
      startHeight = rect.height;
      startLeft = rect.left;
      startTop = rect.top;
      document.addEventListener("mousemove", onMouseMove);
      document.addEventListener("mouseup", onMouseUp);
      modal.addClass("mitre-modal-resizing");
    };
    const onMouseMove = (e) => {
      const deltaX = e.clientX - startX;
      const deltaY = e.clientY - startY;
      let newWidth = startWidth;
      let newHeight = startHeight;
      let newLeft = startLeft;
      let newTop = startTop;
      if (className.includes("-e")) {
        newWidth = Math.max(MIN_WIDTH, Math.min(MAX_WIDTH, startWidth + deltaX));
      }
      if (className.includes("-w")) {
        newWidth = Math.max(MIN_WIDTH, Math.min(MAX_WIDTH, startWidth - deltaX));
        newLeft = startLeft + (startWidth - newWidth);
      }
      if (className.includes("-s")) {
        newHeight = Math.max(MIN_HEIGHT, Math.min(MAX_HEIGHT, startHeight + deltaY));
      }
      if (className.includes("-n")) {
        newHeight = Math.max(MIN_HEIGHT, Math.min(MAX_HEIGHT, startHeight - deltaY));
        newTop = startTop + (startHeight - newHeight);
      }
      modal.style.setProperty("width", `${newWidth}px`, "important");
      modal.style.setProperty("height", `${newHeight}px`, "important");
      modal.style.setProperty("max-width", `${newWidth}px`, "important");
      modal.style.setProperty("max-height", `${newHeight}px`, "important");
      if (className.includes("-w") || className.includes("-n")) {
        modal.style.left = `${newLeft}px`;
        modal.style.top = `${newTop}px`;
      }
    };
    const onMouseUp = () => {
      document.removeEventListener("mousemove", onMouseMove);
      document.removeEventListener("mouseup", onMouseUp);
      modal.removeClass("mitre-modal-resizing");
      if (DEBUG)
        console.debug("[MitreResizable] Resize complete");
    };
    handle.addEventListener("mousedown", onMouseDown);
  });
}

// src/mitre/MitreStatsBar.ts
function renderStatsBar(statsContainer, tactics, iocCount, missingFields) {
  const totalTechniques = tactics.reduce((sum, t) => sum + t.techniques.length, 0);
  const foundTechniques = tactics.reduce(
    (sum, t) => sum + t.techniques.filter((tech) => tech.isFound).length,
    0
  );
  const coveragePercent = totalTechniques > 0 ? Math.round(foundTechniques / totalTechniques * 100) : 0;
  statsContainer.createEl("div", {
    text: `\u{1F4CA} Coverage: ${foundTechniques}/${totalTechniques} techniques (${coveragePercent}%)`,
    cls: "mitre-stat-item"
  });
  const activeTactics = tactics.filter((t) => t.techniques.some((tech) => tech.isFound)).length;
  statsContainer.createEl("div", {
    text: `\u2694\uFE0F Tactics: ${activeTactics}/${tactics.length} active`,
    cls: "mitre-stat-item"
  });
  statsContainer.createEl("div", {
    text: `\u{1F4C7} IOC Cards: ${iocCount} total`,
    cls: "mitre-stat-item"
  });
  const missingTacticCount = missingFields.missingTactic.length;
  if (missingTacticCount > 0) {
    const missingTacticEl = statsContainer.createEl("div", {
      text: `\u26A0\uFE0F Missing Tactic: ${missingTacticCount} card${missingTacticCount === 1 ? "" : "s"}`,
      cls: "mitre-stat-item mitre-stat-warning"
    });
    const tooltipText = missingFields.missingTactic.map((info) => {
      const missing = info.missing === "both" ? "tactic, technique" : "tactic";
      return `${info.iocType} ${info.cardId} (missing: ${missing})`;
    }).join("\n");
    missingTacticEl.setAttribute("title", tooltipText);
    missingTacticEl.setAttribute("aria-label", `${missingTacticCount} cards missing tactic field`);
  }
  const missingTechniqueCount = missingFields.missingTechnique.length;
  if (missingTechniqueCount > 0) {
    const missingTechniqueEl = statsContainer.createEl("div", {
      text: `\u26A0\uFE0F Missing Technique: ${missingTechniqueCount} card${missingTechniqueCount === 1 ? "" : "s"}`,
      cls: "mitre-stat-item mitre-stat-warning"
    });
    const tooltipText = missingFields.missingTechnique.map((info) => {
      const missing = info.missing === "both" ? "tactic, technique" : "technique";
      return `${info.iocType} ${info.cardId} (missing: ${missing})`;
    }).join("\n");
    missingTechniqueEl.setAttribute("title", tooltipText);
    missingTechniqueEl.setAttribute("aria-label", `${missingTechniqueCount} cards missing technique field`);
  }
}

// src/mitre/MitreTextUtils.ts
function cleanDescription(description) {
  if (!description)
    return "";
  let cleaned = description;
  cleaned = cleaned.replace(/\[([^\]]+)\]\([^)]+\)/g, "");
  cleaned = cleaned.replace(/\[[^\]]*\]/g, "");
  cleaned = cleaned.replace(/\s+/g, " ").trim();
  return cleaned;
}
function truncateDescription(description, maxChars = 180) {
  if (!description || description.length <= maxChars) {
    return description;
  }
  const truncated = description.substring(0, maxChars);
  const lastSpace = truncated.lastIndexOf(" ");
  if (lastSpace > 0) {
    return truncated.substring(0, lastSpace) + "...";
  }
  return truncated + "...";
}

// src/mitre/MitreSearch.ts
function parseSearchQuery(query) {
  if (!query || !query.trim()) {
    return {
      query: "",
      keywords: [],
      phrases: [],
      isActive: false
    };
  }
  const trimmedQuery = query.trim();
  const quoteCount = (trimmedQuery.match(/"/g) || []).length;
  let processedQuery = trimmedQuery;
  if (quoteCount % 2 !== 0) {
    const lastQuoteIndex = processedQuery.lastIndexOf('"');
    processedQuery = processedQuery.substring(0, lastQuoteIndex) + processedQuery.substring(lastQuoteIndex + 1);
  }
  const phrases = [];
  const phraseRegex = /"([^"]+)"/g;
  let match;
  while ((match = phraseRegex.exec(processedQuery)) !== null) {
    phrases.push(match[1].toLowerCase());
  }
  const remainingQuery = processedQuery.replace(/"[^"]+"/g, " ");
  const keywords = remainingQuery.split(/\s+/).map((k) => k.trim().toLowerCase()).filter((k) => k.length > 0);
  if (DEBUG)
    console.debug("[MitreSearch] Parsed query:", { query: trimmedQuery, keywords, phrases });
  return {
    query: trimmedQuery,
    keywords,
    phrases,
    isActive: keywords.length > 0 || phrases.length > 0
  };
}
function textMatchesQuery(text, searchState) {
  if (!searchState.isActive)
    return true;
  const lowerText = text.toLowerCase();
  const allKeywordsMatch = searchState.keywords.every(
    (keyword) => lowerText.includes(keyword)
  );
  const allPhrasesMatch = searchState.phrases.every(
    (phrase) => lowerText.includes(phrase)
  );
  return allKeywordsMatch && allPhrasesMatch;
}
function matchesSearch(technique, searchState, subtechniquesMap) {
  if (!searchState.isActive) {
    return { matched: true };
  }
  if (textMatchesQuery(technique.id, searchState)) {
    return { matched: true, matchType: "id", matchText: technique.id };
  }
  if (textMatchesQuery(technique.name, searchState)) {
    return { matched: true, matchType: "name", matchText: technique.name };
  }
  if (technique.description && textMatchesQuery(technique.description, searchState)) {
    return { matched: true, matchType: "description", matchText: technique.description };
  }
  const subtechniques = subtechniquesMap.get(technique.id) || [];
  for (const subtech of subtechniques) {
    if (textMatchesQuery(subtech.id, searchState) || textMatchesQuery(subtech.name, searchState) || subtech.description && textMatchesQuery(subtech.description, searchState)) {
      return { matched: true, matchType: "subtechnique", matchText: subtech.name };
    }
  }
  return { matched: false };
}
function escapeHtml(text) {
  const div = document.createElement("div");
  div.textContent = text;
  return div.innerHTML;
}
function escapeRegex(text) {
  return text.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function highlightMatches(element, originalText, searchState) {
  if (!searchState.isActive || !originalText) {
    return;
  }
  let escapedText = escapeHtml(originalText);
  searchState.phrases.forEach((phrase) => {
    const escapedPhrase = escapeRegex(phrase);
    const regex = new RegExp(`(${escapedPhrase})`, "gi");
    escapedText = escapedText.replace(regex, '<mark class="mitre-search-highlight">$1</mark>');
  });
  searchState.keywords.forEach((keyword) => {
    const escapedKeyword = escapeRegex(keyword);
    const regex = new RegExp(`(?!<mark[^>]*>)(${escapedKeyword})(?![^<]*</mark>)`, "gi");
    escapedText = escapedText.replace(regex, '<mark class="mitre-search-highlight">$1</mark>');
  });
  element.innerHTML = escapedText;
}

// src/mitre/MitreModalHelpers.ts
function isActiveTechnique(techniqueId, activeTechniqueId) {
  if (!activeTechniqueId)
    return false;
  if (techniqueId === activeTechniqueId)
    return true;
  if (activeTechniqueId.includes(".")) {
    const parentId = activeTechniqueId.split(".")[0];
    if (techniqueId === parentId)
      return true;
  }
  return false;
}
function toggleExpansion(element, ctx, subtechniques) {
  var _a, _b, _c;
  const isCollapsed = element.hasClass("collapsed");
  const expandIcon = element.querySelector(".mitre-expand-icon");
  const descEl = element.querySelector(".mitre-technique-description");
  if (isCollapsed) {
    element.removeClass("collapsed");
    element.addClass("expanded");
    element.setAttribute("data-is-expanded", "true");
    if (expandIcon)
      expandIcon.setText("\u25BC");
    if (subtechniques && subtechniques.length > 0) {
      ctx.renderSubtechniques(element, subtechniques, ctx.currentSearchState);
    }
    if (descEl) {
      const fullDesc = element.getAttribute("data-full-description");
      if (fullDesc) {
        descEl.textContent = fullDesc;
        if ((_a = ctx.currentSearchState) == null ? void 0 : _a.isActive) {
          highlightMatches(descEl, fullDesc, ctx.currentSearchState);
        }
      }
    }
  } else {
    element.removeClass("expanded");
    element.addClass("collapsed");
    element.setAttribute("data-is-expanded", "false");
    if (expandIcon)
      expandIcon.setText("\u25B6");
    (_b = element.querySelector(".mitre-subtechniques-container")) == null ? void 0 : _b.remove();
    if (descEl) {
      const fullDesc = element.getAttribute("data-full-description");
      const truncatedDesc = element.getAttribute("data-truncated-description");
      const displayText = truncatedDesc || (fullDesc ? truncateDescription(fullDesc) : null);
      if (displayText) {
        descEl.textContent = displayText;
        if ((_c = ctx.currentSearchState) == null ? void 0 : _c.isActive) {
          highlightMatches(descEl, displayText, ctx.currentSearchState);
        }
      }
    }
  }
}

// src/mitre/MitreCountBadge.ts
function createCountBadgeWithTooltip(parentEl, technique, ctx, extraIocCards) {
  const badge = parentEl.createDiv("mitre-technique-count-badge");
  badge.textContent = `${technique.count} card${technique.count > 1 ? "s" : ""}`;
  const allCardIds = [...technique.iocCards, ...extraIocCards || []];
  const tooltip = badge.createDiv("mitre-count-tooltip");
  tooltip.style.display = "none";
  allCardIds.forEach((cardId, index) => {
    const iocData = ctx.iocDataMap.get(cardId);
    if (!iocData)
      return;
    const cardItem = tooltip.createDiv("mitre-tooltip-card");
    const iocType = Object.values(IOC_TYPES).find((t) => t.name === iocData.type);
    const typeColor = (iocType == null ? void 0 : iocType.color) || "#888";
    const typeEl = cardItem.createDiv("mitre-tooltip-type");
    typeEl.style.color = typeColor;
    typeEl.style.fontWeight = "bold";
    typeEl.textContent = iocData.type;
    if (iocData.value) {
      const valueEl = cardItem.createDiv("mitre-tooltip-value");
      valueEl.textContent = iocData.value;
    }
    if (index < allCardIds.length - 1) {
      cardItem.style.borderBottom = "1px solid var(--background-modifier-border)";
      cardItem.style.paddingBottom = "8px";
      cardItem.style.marginBottom = "8px";
    }
  });
  badge.addEventListener("mouseenter", () => {
    tooltip.style.display = "block";
  });
  badge.addEventListener("mouseleave", () => {
    tooltip.style.display = "none";
  });
  if (DEBUG)
    console.debug("[MitreModalRenderer]   \u2192 Count badge with tooltip:", technique.count, "card(s), allCards:", allCardIds.length);
}

// src/mitre/MitreModalTacticRenderer.ts
function renderTacticSection(container, tactic, ctx, searchState) {
  if (DEBUG)
    console.debug("[MitreModalRenderer] ========== RENDERING TACTIC SECTION ==========");
  if (DEBUG)
    console.debug("[MitreModalRenderer] Tactic:", tactic.displayName || tactic.name);
  const tacticColumn = container.createDiv("mitre-tactic-column");
  const foundCount = tactic.techniques.filter((t) => t.isFound).length;
  const totalCount = tactic.techniques.length;
  if (DEBUG)
    console.debug("[MitreModalRenderer] Found techniques:", foundCount, "/", totalCount);
  const tacticHeader = tacticColumn.createDiv("mitre-tactic-header");
  tacticHeader.createEl("h3", { text: `\u2694\uFE0F ${tactic.displayName || tactic.name}` });
  tacticHeader.createEl("span", {
    text: `${foundCount} active / ${totalCount} total techniques`,
    cls: "mitre-technique-count"
  });
  const techniqueList = tacticColumn.createDiv("mitre-technique-list");
  tactic.techniques.forEach((technique) => {
    renderTechniqueItem(techniqueList, technique, ctx, searchState);
  });
  if (DEBUG)
    console.debug("[MitreModalRenderer] ========== TACTIC RENDERING COMPLETE ==========");
}
function renderTechniqueItem(techniqueList, technique, ctx, searchState) {
  const techItem = techniqueList.createDiv("mitre-technique-item");
  const subtechniques = ctx.subtechniquesMap.get(technique.id) || [];
  const hasSubtechniques = subtechniques.length > 0;
  const cleanedDesc = cleanDescription(technique.description || "");
  const isLongDescription = cleanedDesc.length > ctx.TECHNIQUE_TRUNCATE_LIMIT;
  const isExpandable = isLongDescription || hasSubtechniques;
  techItem.setAttribute("data-technique-id", technique.id);
  techItem.setAttribute("data-subtechnique-count", subtechniques.length.toString());
  techItem.setAttribute("data-is-expandable", isExpandable.toString());
  techItem.setAttribute("data-full-description", cleanedDesc);
  if (isLongDescription) {
    const truncated = truncateDescription(cleanedDesc);
    techItem.setAttribute("data-truncated-description", truncated);
  }
  const isActive = isActiveTechnique(technique.id, ctx.activeTechniqueId);
  if (isActive) {
    techItem.addClass("mitre-technique-active");
  }
  if (!technique.isFound) {
    techItem.addClass("mitre-technique-unfound");
  } else {
    applySeverityClass(techItem, technique.severity);
  }
  const techInfo = techItem.createDiv("mitre-technique-info");
  if (isExpandable) {
    techInfo.createEl("span", {
      cls: "mitre-expand-icon",
      text: "\u25B6"
    });
    techItem.addClass("has-expandable");
    techItem.addClass("collapsed");
    techItem.addEventListener("click", (e) => {
      e.stopPropagation();
      toggleExpansion(techItem, ctx, subtechniques);
    });
  }
  techInfo.createEl("span", {
    text: technique.id,
    cls: "mitre-technique-id"
  });
  const nameText = hasSubtechniques ? `${technique.name} (${subtechniques.length})` : technique.name;
  const nameEl = techInfo.createEl("span", {
    text: nameText,
    cls: "mitre-technique-name"
  });
  if (searchState == null ? void 0 : searchState.isActive) {
    highlightMatches(nameEl, technique.name, searchState);
  }
  if (technique.description) {
    const descEl = techItem.createDiv("mitre-technique-description");
    const isExpanded = techItem.hasClass("expanded");
    let displayText;
    if (isExpanded || !isExpandable) {
      displayText = cleanedDesc;
    } else {
      displayText = truncateDescription(cleanedDesc);
    }
    descEl.textContent = displayText;
    if (searchState == null ? void 0 : searchState.isActive) {
      highlightMatches(descEl, displayText, searchState);
    }
  }
  if (technique.isFound) {
    const subtechCards = [];
    subtechniques.forEach((sub) => {
      if (sub.isFound && sub.iocCards.length > 0) {
        subtechCards.push(...sub.iocCards);
      }
    });
    createCountBadgeWithTooltip(techItem, technique, ctx, subtechCards);
  }
}

// src/mitre/MitreSubtechniqueRenderer.ts
function renderSubtechniques(parentEl, subtechniques, ctx, searchState) {
  const container = parentEl.createDiv({ cls: "mitre-subtechniques-container" });
  subtechniques.forEach((subtech) => {
    const subItem = container.createDiv("mitre-technique-item mitre-subtechnique");
    const cleanedDesc = cleanDescription(subtech.description || "");
    const isLongDescription = cleanedDesc.length > ctx.SUBTECHNIQUE_TRUNCATE_LIMIT;
    subItem.setAttribute("data-technique-id", subtech.id);
    subItem.setAttribute("data-full-description", cleanedDesc);
    if (isLongDescription) {
      const truncated = truncateDescription(cleanedDesc, ctx.SUBTECHNIQUE_TRUNCATE_LIMIT);
      subItem.setAttribute("data-truncated-description", truncated);
    }
    const isActive = isActiveTechnique(subtech.id, ctx.activeTechniqueId);
    if (isActive) {
      subItem.addClass("mitre-technique-active");
    }
    if (!subtech.isFound) {
      subItem.addClass("mitre-technique-unfound");
    } else {
      applySeverityClass(subItem, subtech.severity);
    }
    const subInfo = subItem.createDiv("mitre-technique-info");
    if (isLongDescription) {
      subInfo.createEl("span", {
        cls: "mitre-expand-icon",
        text: "\u25B6"
      });
      subItem.addClass("has-expandable");
      subItem.addClass("collapsed");
      subItem.addEventListener("click", (e) => {
        e.stopPropagation();
        toggleExpansion(subItem, ctx);
      });
    }
    subInfo.createEl("span", {
      text: subtech.id,
      cls: "mitre-technique-id"
    });
    const nameEl = subInfo.createEl("span", {
      text: subtech.name,
      cls: "mitre-technique-name"
    });
    if (searchState == null ? void 0 : searchState.isActive) {
      highlightMatches(nameEl, subtech.name, searchState);
    }
    if (subtech.description) {
      const descEl = subItem.createDiv("mitre-technique-description");
      let displayText;
      if (isLongDescription) {
        displayText = truncateDescription(cleanedDesc, ctx.SUBTECHNIQUE_TRUNCATE_LIMIT);
      } else {
        displayText = cleanedDesc;
      }
      descEl.textContent = displayText;
      if (searchState == null ? void 0 : searchState.isActive) {
        highlightMatches(descEl, displayText, searchState);
      }
    }
    if (subtech.isFound) {
      createCountBadgeWithTooltip(subItem, subtech, ctx);
    }
  });
}

// src/mitre/MitreModalValidation.ts
function renderValidationErrors(container, validationErrors) {
  if (validationErrors.length === 0)
    return;
  if (DEBUG)
    console.debug("[MitreModalValidation] Rendering", validationErrors.length, "validation errors");
  const tacticErrors = validationErrors.filter((e) => e.severity === "unknown_tactic");
  const techniqueErrors = validationErrors.filter((e) => e.severity === "unknown_technique");
  const mismatchErrors = validationErrors.filter((e) => e.severity === "mismatch");
  const errorSection = container.createDiv("mitre-validation-errors");
  const header = errorSection.createDiv("mitre-errors-header");
  header.createEl("h3", {
    text: `\u26A0\uFE0F Validation Issues (${validationErrors.length})`
  });
  const toggleBtn = header.createEl("button", {
    text: "Hide",
    cls: "mitre-errors-toggle"
  });
  const errorsList = errorSection.createDiv("mitre-errors-list");
  errorSection.addClass("expanded");
  toggleBtn.addEventListener("click", () => {
    if (errorSection.hasClass("expanded")) {
      errorSection.removeClass("expanded");
      errorSection.addClass("collapsed");
      toggleBtn.setText("Show");
      errorsList.style.display = "none";
    } else {
      errorSection.removeClass("collapsed");
      errorSection.addClass("expanded");
      toggleBtn.setText("Hide");
      errorsList.style.display = "block";
    }
  });
  if (tacticErrors.length > 0) {
    renderErrorCategory(errorsList, "Unknown Tactic", tacticErrors, "\u{1F534}");
  }
  if (techniqueErrors.length > 0) {
    renderErrorCategory(errorsList, "Technique Errors", techniqueErrors, "\u{1F534}");
  }
  if (mismatchErrors.length > 0) {
    renderErrorCategory(errorsList, "Validation Mismatches", mismatchErrors, "\u26A0\uFE0F");
  }
}
function renderErrorCategory(container, categoryTitle, errors, icon) {
  const categorySection = container.createDiv("mitre-error-category");
  const categoryHeader = categorySection.createDiv("mitre-error-category-header");
  categoryHeader.createEl("h4", {
    text: `${icon} ${categoryTitle} (${errors.length})`
  });
  errors.forEach((error) => {
    const errorItem = categorySection.createDiv("mitre-error-item");
    if (isCriticalSeverity(error.severity)) {
      errorItem.addClass("mitre-error-critical");
    } else if (error.severity === "mismatch") {
      errorItem.addClass("mitre-error-warning");
    }
    const errorHeader = errorItem.createDiv("mitre-error-header");
    errorHeader.createEl("span", {
      text: error.techniqueId,
      cls: "mitre-error-technique-id"
    });
    errorHeader.createEl("span", {
      text: error.techniqueName,
      cls: "mitre-error-technique-name"
    });
    errorItem.createDiv({
      text: error.message,
      cls: "mitre-error-message"
    });
    const cardsSection = errorItem.createDiv("mitre-error-cards");
    cardsSection.createEl("span", {
      text: "Affected cards: ",
      cls: "mitre-error-cards-label"
    });
    error.iocCards.forEach((card, index) => {
      const cardBadge = cardsSection.createEl("span", {
        cls: "mitre-error-card-badge",
        attr: { "title": `Node ID: ${card.nodeId}` }
      });
      cardBadge.createEl("span", {
        text: card.iocType,
        cls: "mitre-error-card-type"
      });
      cardBadge.createEl("span", {
        text: ` ${card.cardId}`,
        cls: "mitre-error-card-id"
      });
      if (index < error.iocCards.length - 1) {
        cardsSection.createEl("span", { text: ", " });
      }
    });
  });
}

// src/mitre/MitreModalSearch.ts
function renderSearchBar(headerContainer, onSearchChange) {
  const searchContainer = headerContainer.createDiv("mitre-search-container");
  const searchInput = searchContainer.createEl("input", {
    type: "text",
    placeholder: 'Search techniques (use "quotes" for exact phrases)...',
    cls: "mitre-search-input"
  });
  const clearButton = searchContainer.createEl("button", {
    text: "\u2715",
    cls: "mitre-search-clear",
    attr: { "aria-label": "Clear search" }
  });
  clearButton.style.display = "none";
  const matchCount = searchContainer.createDiv("mitre-search-match-count");
  matchCount.style.display = "none";
  let debounceTimer = null;
  searchInput.addEventListener("input", () => {
    if (debounceTimer !== null) {
      clearTimeout(debounceTimer);
    }
    debounceTimer = window.setTimeout(() => {
      onSearchChange(searchInput.value);
    }, 300);
  });
  clearButton.addEventListener("click", () => {
    searchInput.value = "";
    onSearchChange("");
  });
  searchInput.addEventListener("keydown", (e) => {
    if (e.key === "Escape") {
      searchInput.value = "";
      onSearchChange("");
    }
  });
  return {
    searchBar: searchInput,
    searchClearButton: clearButton,
    searchMatchCount: matchCount
  };
}
function handleSearchInput(query, modalEl, currentTactics, ctx, searchUI) {
  const searchState = parseSearchQuery(query);
  if (DEBUG)
    console.debug("[MitreModalSearch] Search query:", query, "- Parsed:", searchState);
  if (searchUI.searchClearButton) {
    searchUI.searchClearButton.style.display = searchState.isActive ? "block" : "none";
  }
  const container = modalEl.querySelector(".mitre-content-area");
  if (container && currentTactics) {
    container.empty();
    const updatedCtx = { ...ctx, currentSearchState: searchState };
    let matchCount = 0;
    currentTactics.forEach((tactic) => {
      const matchingTechniques = tactic.techniques.filter((tech) => {
        if (!searchState.isActive)
          return true;
        const match = matchesSearch(tech, searchState, ctx.subtechniquesMap);
        if (match.matched)
          matchCount++;
        return match.matched;
      });
      if (matchingTechniques.length > 0) {
        const filteredTactic = { ...tactic, techniques: matchingTechniques };
        renderTacticSection(container, filteredTactic, updatedCtx, searchState);
      }
    });
    if (searchUI.searchMatchCount) {
      if (searchState.isActive) {
        searchUI.searchMatchCount.textContent = `${matchCount} technique${matchCount !== 1 ? "s" : ""} found`;
        searchUI.searchMatchCount.style.display = "block";
      } else {
        searchUI.searchMatchCount.style.display = "none";
      }
    }
    if (matchCount === 0 && searchState.isActive) {
      container.createDiv({
        cls: "mitre-no-results",
        text: "No techniques match your search"
      });
    }
  }
  return searchState;
}

// src/mitre/RenderMitreModal.ts
var RenderMitreModal = class extends import_obsidian5.Modal {
  constructor(app, plugin, activeTechniqueId) {
    super(app);
    this.mitreDataset = null;
    this.subtechniquesMap = /* @__PURE__ */ new Map();
    this.currentSearchState = null;
    this.currentTactics = null;
    this.validationErrors = [];
    this.activeTechniqueId = null;
    this.iocDataMap = /* @__PURE__ */ new Map();
    this.iocCount = 0;
    this.searchUI = { searchBar: null, searchClearButton: null, searchMatchCount: null };
    // Truncation limits
    this.TECHNIQUE_TRUNCATE_LIMIT = 180;
    this.SUBTECHNIQUE_TRUNCATE_LIMIT = 100;
    this.plugin = plugin;
    this.activeTechniqueId = activeTechniqueId || null;
    this.loadDataset();
  }
  // ---------------------------------------------------------------
  // Lifecycle
  // ---------------------------------------------------------------
  async loadDataset() {
    try {
      this.mitreDataset = await loadMitreDataset(this.app);
      if (DEBUG)
        console.debug("[MitreModal] Dataset loaded:", this.mitreDataset.version, "- Techniques:", Object.keys(this.mitreDataset.techniques).length);
    } catch (err) {
      console.error("[MitreModal] Failed to load dataset:", err);
      this.mitreDataset = null;
    }
  }
  onOpen() {
    if (DEBUG)
      console.debug("[MitreModal] ===== MODAL OPENED =====");
    const { contentEl } = this;
    this.modalEl.classList.add("mitre-modal-fullscreen");
    makeResizable(this.modalEl);
    const headerContainer = contentEl.createDiv("mitre-modal-header");
    const titleRow = headerContainer.createDiv("mitre-title-row");
    titleRow.createEl("h2", { text: "\u{1F3AF} MITRE ATT&CK Technique Mapper" });
    const exportBtn = titleRow.createEl("button", {
      text: "Export to Navigator",
      cls: "mitre-export-button"
    });
    exportBtn.addEventListener("click", () => {
      if (this.currentTactics && this.mitreDataset) {
        exportToNavigator(this.currentTactics, this.iocCount, this.mitreDataset);
      }
    });
    this.searchUI = renderSearchBar(headerContainer, (query) => {
      this.currentSearchState = handleSearchInput(
        query,
        this.modalEl,
        this.currentTactics,
        this.getContext(),
        this.searchUI
      );
    });
    const statsContainer = contentEl.createDiv("mitre-stats");
    const contentArea = contentEl.createDiv("mitre-content-area");
    this.renderMitreMapping(contentArea, statsContainer);
  }
  onClose() {
    if (DEBUG)
      console.debug("[MitreModal] ===== MODAL CLOSED =====");
    const { contentEl } = this;
    contentEl.empty();
  }
  // ---------------------------------------------------------------
  // Context builder
  // ---------------------------------------------------------------
  /**
   * Build a MitreModalContext from current class state.
   * Passed to extracted rendering functions instead of `this`.
   */
  getContext() {
    return {
      activeTechniqueId: this.activeTechniqueId,
      currentSearchState: this.currentSearchState,
      subtechniquesMap: this.subtechniquesMap,
      iocDataMap: this.iocDataMap,
      TECHNIQUE_TRUNCATE_LIMIT: this.TECHNIQUE_TRUNCATE_LIMIT,
      SUBTECHNIQUE_TRUNCATE_LIMIT: this.SUBTECHNIQUE_TRUNCATE_LIMIT,
      renderSubtechniques: (parentEl, subtechniques, searchState) => {
        renderSubtechniques(parentEl, subtechniques, this.getContext(), searchState);
      }
    };
  }
  // ---------------------------------------------------------------
  // Core rendering (stays as class method - mutates 5+ properties)
  // ---------------------------------------------------------------
  /**
   * Main rendering entry point. Extracts IOC data, runs aggregation,
   * and renders the full MITRE matrix.
   */
  async renderMitreMapping(container, statsContainer) {
    if (DEBUG)
      console.debug("[MitreModal] ===== STARTING DATA EXTRACTION =====");
    const iocData = extractFixedIOCData(this.app);
    if (DEBUG)
      console.debug("[MitreModal] Extracted IOC count:", iocData.length);
    this.iocCount = iocData.length;
    if (iocData.length === 0) {
      container.createEl("p", {
        text: "No IOC cards found in the current canvas.",
        cls: "mitre-empty-message"
      });
      return;
    }
    if (!this.mitreDataset) {
      await this.loadDataset();
    }
    if (!this.mitreDataset) {
      container.createEl("div", {
        cls: "mitre-error-message",
        text: "\u274C MITRE ATT&CK dataset could not be loaded."
      });
      container.createEl("p", {
        text: "Please ensure enterprise-attack.json exists in the MITRE folder."
      });
      container.createEl("a", {
        text: "Download dataset from MITRE",
        attr: { href: "https://github.com/mitre-attack/attack-stix-data", target: "_blank" }
      });
      return;
    }
    const result = aggregateTacticsTechniques(iocData, this.mitreDataset);
    const tactics = result.tactics;
    this.subtechniquesMap = result.subtechniquesMap;
    this.validationErrors = result.validationErrors;
    this.iocDataMap = result.iocDataMap;
    this.iocCount = result.iocCount;
    const missingFields = result.missingFields;
    if (DEBUG)
      console.debug("[MitreModal] ===== AGGREGATION COMPLETE =====");
    if (tactics.length === 0) {
      container.createEl("p", {
        text: 'No MITRE tactics or techniques found in IOC cards. Add "Mitre Tactic" and "Mitre Technique" fields to your cards.',
        cls: "mitre-empty-message"
      });
      return;
    }
    renderStatsBar(statsContainer, tactics, result.iocCount, missingFields);
    this.currentTactics = tactics;
    const ctx = this.getContext();
    renderValidationErrors(container, this.validationErrors);
    if (DEBUG)
      console.debug("[MitreModal] Rendering MITRE matrix -", tactics.length, "tactics");
    tactics.forEach((tactic) => {
      renderTacticSection(container, tactic, ctx, this.currentSearchState);
    });
    if (DEBUG)
      console.debug("[MitreModal] Matrix rendering complete:", {
        tactics: tactics.length,
        iocCards: result.iocCount
      });
  }
};

// src/settings/PluginSettings.ts
var import_obsidian6 = require("obsidian");
var DEFAULT_SETTINGS = {
  cardSize: "medium",
  showTimelineButton: true
};
var PluginSettings = class extends import_obsidian6.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "IOC Canvas Plugin Settings" });
    new import_obsidian6.Setting(containerEl).setName("Default card size").setDesc("Set the default size for IOC cards").addDropdown(
      (dropdown) => dropdown.addOption("small", "Small").addOption("medium", "Medium").addOption("large", "Large").setValue(this.plugin.settings.cardSize).onChange(async (value) => {
        this.plugin.settings.cardSize = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian6.Setting(containerEl).setName("Show timeline button").setDesc("Display timeline button in canvas toolbar").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.showTimelineButton).onChange(async (value) => {
        this.plugin.settings.showTimelineButton = value;
        await this.plugin.saveSettings();
      })
    );
  }
};

// src/canvas/CanvasToolbar.ts
var import_obsidian7 = require("obsidian");
var TIMELINE_SVG = '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>';
var CARDS_SVG = '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="2" y="3" width="20" height="14" rx="2" ry="2"/><line x1="8" y1="21" x2="16" y2="21"/><line x1="12" y1="17" x2="12" y2="21"/></svg>';
var REDUCE_SVG = '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="4 14 10 14 10 20"/><polyline points="20 10 14 10 14 4"/><line x1="14" y1="10" x2="21" y2="3"/><line x1="3" y1="21" x2="10" y2="14"/></svg>';
var CHILD_CARD_SVG = '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="5" y="6" width="16" height="12" rx="2" ry="2"/><line x1="9" y1="22" x2="15" y2="22"/><line x1="12" y1="18" x2="12" y2="22"/><polyline points="1 12 4 9 7 12"/></svg>';
var MITRE_SVG = '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><circle cx="12" cy="12" r="6"/><circle cx="12" cy="12" r="2"/></svg>';
function createToolbarButton(label, svgIcon, onClick) {
  const item = document.createElement("div");
  item.className = "canvas-control-item";
  item.setAttribute("aria-label", label);
  item.setAttribute("title", label);
  item.addEventListener("click", onClick);
  const icon = document.createElement("div");
  icon.className = "clickable-icon";
  icon.innerHTML = svgIcon;
  item.appendChild(icon);
  return item;
}
function addCanvasButtons(ctx) {
  try {
    const activeView = ctx.app.workspace.getActiveViewOfType(import_obsidian7.ItemView);
    if (!activeView || activeView.getViewType() !== "canvas") {
      return;
    }
    const canvasView = activeView.containerEl;
    if (!canvasView) {
      return;
    }
    const canvasControls = canvasView.querySelector(".canvas-controls");
    if (!canvasControls) {
      return;
    }
    if (canvasControls.querySelector(".ioc-toolbar")) {
      return;
    }
    if (DEBUG)
      console.debug("[CanvasToolbar] Injecting toolbar buttons");
    const iocToolbar = document.createElement("div");
    iocToolbar.className = "ioc-toolbar";
    const timelineBtn = createToolbarButton("Show Attack Timelines", TIMELINE_SVG, ctx.onTimeline);
    const parentBtn = createToolbarButton("Parent Card", CARDS_SVG, ctx.onAddCard);
    const childBtn = createToolbarButton("Child Card", CHILD_CARD_SVG, ctx.onChildCard);
    const reduceBtn = createToolbarButton("Toggle Reduce View", REDUCE_SVG, () => {
      const newState = ctx.onReduce();
      const icon = reduceBtn.querySelector(".clickable-icon");
      if (icon)
        icon.classList.toggle("is-active", newState);
    });
    const mitreBtn = createToolbarButton("MITRE ATT&CK Mapper", MITRE_SVG, ctx.onMitre);
    iocToolbar.appendChild(timelineBtn);
    iocToolbar.appendChild(parentBtn);
    iocToolbar.appendChild(childBtn);
    iocToolbar.appendChild(reduceBtn);
    iocToolbar.appendChild(mitreBtn);
    canvasControls.appendChild(iocToolbar);
  } catch (err) {
    console.error("IOC Canvas: failed to inject canvas buttons", err);
  }
}

// src/canvas/CanvasSelection.ts
var import_obsidian8 = require("obsidian");
function getSelectedTechniqueId(app) {
  try {
    const activeView = app.workspace.getActiveViewOfType(import_obsidian8.ItemView);
    if (!activeView || activeView.getViewType() !== "canvas") {
      return null;
    }
    const canvas = activeView.canvas;
    if (!canvas) {
      return null;
    }
    let selectedNode = null;
    if (canvas.selection && canvas.selection.size > 0) {
      const firstSelectedId = Array.from(canvas.selection)[0];
      selectedNode = canvas.nodes.get(firstSelectedId);
    }
    if (!selectedNode && canvas.selectedNodes) {
      if (Array.isArray(canvas.selectedNodes) && canvas.selectedNodes.length > 0) {
        selectedNode = canvas.selectedNodes[0];
      } else if (canvas.selectedNodes.size > 0) {
        selectedNode = Array.from(canvas.selectedNodes)[0];
      }
    }
    if (!selectedNode && canvas.nodes) {
      canvas.nodes.forEach((node) => {
        if (node.selected || node.isSelected) {
          selectedNode = node;
          return;
        }
      });
    }
    if (!selectedNode || !selectedNode.text) {
      return null;
    }
    const parsedData = parseIOCNode(selectedNode);
    if (!parsedData || !parsedData.technique || !parsedData.technique.trim()) {
      return null;
    }
    const technique = parsedData.technique.toUpperCase();
    const idMatch = technique.match(/T\d{4}(?:\.\d{3})?/i);
    if (idMatch) {
      if (DEBUG)
        console.debug("[CanvasSelection] Selected technique:", idMatch[0].toUpperCase());
      return idMatch[0].toUpperCase();
    }
    return null;
  } catch (err) {
    console.error("[CanvasSelection] Error getting selected technique:", err);
    return null;
  }
}

// src/canvas/ReduceView.ts
var import_obsidian9 = require("obsidian");
function toggleReduceView(app, isReducedView) {
  const activeView = app.workspace.getActiveViewOfType(import_obsidian9.ItemView);
  if (!activeView || activeView.getViewType() !== "canvas")
    return isReducedView;
  const canvas = activeView.canvas;
  if (!canvas)
    return isReducedView;
  const newState = !isReducedView;
  if (DEBUG)
    console.debug("[ReduceView] Toggling reduce view:", isReducedView, "->", newState);
  const wrapperEl = canvas.wrapperEl;
  if (wrapperEl) {
    if (newState) {
      wrapperEl.classList.add("ioc-reduced");
    } else {
      wrapperEl.classList.remove("ioc-reduced");
    }
  }
  if (canvas.nodes) {
    canvas.nodes.forEach((node) => {
      if (!node.text)
        return;
      if (newState) {
        if (!node._iocOriginalHeight) {
          node._iocOriginalHeight = node.height;
        }
        if (node.resize) {
          node.resize({ width: node.width, height: 60 });
        } else {
          node.height = 60;
        }
      } else {
        const originalH = node._iocOriginalHeight || 400;
        if (node.resize) {
          node.resize({ width: node.width, height: originalH });
        } else {
          node.height = originalH;
        }
      }
    });
  }
  canvas.requestFrame();
  canvas.requestSave();
  return newState;
}

// src/canvas/IOCCardCreation.ts
var import_obsidian11 = require("obsidian");

// src/canvas/RenderIOCCardsModal.ts
var import_obsidian10 = require("obsidian");
var RenderIOCCardsModal = class extends import_obsidian10.Modal {
  constructor(app, iocTypes, onSelect, title) {
    super(app);
    this.iocTypes = iocTypes;
    this.onSelect = onSelect;
    this.title = title || "Select IOC Type";
  }
  /** Builds the primary IOC type grid view. */
  onOpen() {
    const { contentEl } = this;
    this.modalEl.classList.add("ioc-type-selector-modal");
    this.modalEl.style.maxWidth = "900px";
    this.modalEl.style.width = "90vw";
    contentEl.createEl("h2", { text: this.title });
    const container = contentEl.createDiv("ioc-type-container");
    const typeCount = Object.keys(this.iocTypes).length;
    const cols = Math.min(Math.ceil(Math.sqrt(typeCount)), 5);
    container.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;
    Object.keys(this.iocTypes).forEach((iocTypeId) => {
      const iocType = this.iocTypes[iocTypeId];
      const button = container.createEl("button", { cls: "ioc-type-button" });
      button.setAttribute("data-ioc-type", iocTypeId);
      button.style.borderLeft = `4px solid ${iocType.color}`;
      const iconContainer = button.createDiv("ioc-button-icon");
      iconContainer.innerHTML = iocType.svg;
      const textContainer = button.createDiv("ioc-button-text");
      textContainer.textContent = iocType.name;
      button.addEventListener("click", () => {
        if (iocTypeId === "hostname") {
          this.showOSSelector(iocTypeId);
        } else {
          this.onSelect(iocTypeId);
          this.close();
        }
      });
    });
  }
  /**
   * Replaces the type grid with an OS selector sub-view.
   * Only reachable when iocTypeId === 'hostname' and the type has os_icons.
   */
  showOSSelector(iocTypeId) {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "Select Operating System" });
    contentEl.createEl("p", { text: "Choose the operating system for this hostname:" });
    const container = contentEl.createDiv("os-selector-container");
    const iocType = this.iocTypes[iocTypeId];
    if (iocType.os_icons) {
      Object.keys(iocType.os_icons).forEach((osType) => {
        const osButton = container.createEl("button", { cls: "os-type-button" });
        osButton.setAttribute("data-os-type", osType);
        const iconContainer = osButton.createDiv("os-button-icon");
        iconContainer.innerHTML = iocType.os_icons[osType];
        const textContainer = osButton.createDiv("os-button-text");
        textContainer.textContent = osType.charAt(0).toUpperCase() + osType.slice(1);
        osButton.addEventListener("click", () => {
          this.onSelect(iocTypeId, osType);
          this.close();
        });
      });
    }
    const backButton = contentEl.createEl("button", {
      text: "\u2190 Back to IOC Types",
      cls: "back-button"
    });
    backButton.addEventListener("click", () => {
      contentEl.empty();
      this.onOpen();
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/canvas/RenderIOCCards.ts
function createCardContent(iocType, iocTypeId, osType = null, cardId = "", isChild = false) {
  const now = new Date();
  const timestamp = now.toISOString().replace("T", " ").substring(0, 19);
  let iconSvg = iocType.svg;
  if (iocTypeId === "hostname" && osType && iocType.os_icons) {
    iconSvg = iocType.os_icons[osType] || iocType.svg;
  }
  const roleLabel = isChild ? "[C]" : "[P]";
  const roleClass = isChild ? "ioc-role-child" : "ioc-role-parent";
  const roleBadge = `<span class="ioc-card-role ${roleClass}" style="font-size: 12px; font-weight: 700; padding: 2px 6px; border-radius: 4px; margin-right: 4px;">${roleLabel}</span>`;
  let content = `<div class="ioc-card-container"><div class="ioc-card-header"
        style="display: flex; align-items: center; gap: 16px; margin-bottom: 30px; padding: 20px;
        background: linear-gradient(135deg, ${iocType.color}22, transparent);
        border-radius: 8px; border-bottom: 3px solid ${iocType.color};">
        <div class="ioc-header-content" style="display: flex; align-items: center; gap: 16px; width: 100%;">
        <div class="ioc-icon" style="flex-shrink: 0;">${iconSvg}</div><h2 style="margin: 0;
        color: ${iocType.color}; font-size: 24px; font-weight: 700;">${roleBadge}${iocType.name}</h2>
        <span class="ioc-card-id" style="margin-left: auto; padding: 2px 8px; font-size: 11px; font-weight: 600; background: var(--background-modifier-border); color: var(--text-muted); border-radius: 4px; font-family: var(--font-monospace);">${cardId}</span>
        </div><!-- IOC_CARD_ID:${cardId} --></div></div>
`;
  iocType.fields.forEach((field) => {
    content += `${field}: 


------------
`;
  });
  content += `Time of Event: ${timestamp}


------------
`;
  content += `Splunk Query: 


------------
`;
  content += `Mitre Tactic: 


------------
`;
  content += `Mitre Technique: 


------------
`;
  return content;
}

// src/canvas/IOCCardCreation.ts
function openIOCCardSelector(app, createCard, title) {
  new RenderIOCCardsModal(
    app,
    IOC_TYPES,
    (iocTypeId, osType) => {
      createCard(iocTypeId, osType);
    },
    title
  ).open();
}
function createIOCCard(app, iocTypeId, osType, isChild = false) {
  const activeView = app.workspace.getActiveViewOfType(import_obsidian11.ItemView);
  if (!activeView || activeView.getViewType() !== "canvas") {
    new import_obsidian11.Notice("Please open a canvas first");
    return;
  }
  const canvas = activeView.canvas;
  if (!canvas) {
    new import_obsidian11.Notice("Please open a canvas first");
    return;
  }
  const iocType = IOC_TYPES[iocTypeId];
  if (!iocType) {
    new import_obsidian11.Notice("Unknown IOC type: " + iocTypeId);
    return;
  }
  const now = new Date();
  const year = now.getFullYear();
  const month = String(now.getMonth() + 1).padStart(2, "0");
  const day = String(now.getDate()).padStart(2, "0");
  const hours = String(now.getHours()).padStart(2, "0");
  const minutes = String(now.getMinutes()).padStart(2, "0");
  const cardId = `#${year}${month}${day}-${hours}${minutes}`;
  if (DEBUG)
    console.debug("[CardCreation] Creating card:", iocTypeId, cardId);
  const content = createCardContent(iocType, iocTypeId, osType || null, cardId, isChild);
  canvas.createTextNode({
    pos: { x: Math.random() * 400, y: Math.random() * 400 },
    // Random placement
    size: { width: 400, height: 400 },
    // Standard card size
    text: content
    // Markdown with HTML header
  });
  canvas.requestSave();
  new import_obsidian11.Notice(`Created ${iocType.name} card`);
}

// src/main.ts
var IOCCanvasPlugin = class extends import_obsidian12.Plugin {
  constructor() {
    super(...arguments);
    /** Typed settings object persisted to data.json. */
    this.settings = DEFAULT_SETTINGS;
    /** Whether the canvas IOC cards are currently in compact/reduced view. */
    this.isReducedView = false;
  }
  // ---------------------------------------------------------------
  // Plugin lifecycle
  // ---------------------------------------------------------------
  async onload() {
    console.log("Loading IOC Canvas Plugin");
    await this.loadSettings();
    this.addRibbonIcon("clock", "Show Attack Timelines", () => {
      new RenderTimelinesModal(this.app, this).open();
    });
    this.addCommand({
      id: "show-timelines",
      name: "Show Attack Timelines",
      callback: () => {
        new RenderTimelinesModal(this.app, this).open();
      }
    });
    this.addCommand({
      id: "show-ioc-cards",
      name: "Add Parent IOC Card",
      callback: () => {
        openIOCCardSelector(this.app, (id, os) => createIOCCard(this.app, id, os, false), "Select Parent IOC Type");
      }
    });
    this.addCommand({
      id: "add-child-card",
      name: "Add Child IOC Card",
      callback: () => {
        openIOCCardSelector(this.app, (id, os) => createIOCCard(this.app, id, os, true), "Select Child IOC Type");
      }
    });
    this.addSettingTab(new PluginSettings(this.app, this));
    this.registerEvent(
      this.app.workspace.on("file-menu", (menu, file) => {
        if (file instanceof import_obsidian12.TFile && file.extension === "canvas") {
          menu.addItem((item) => {
            item.setTitle("Show Attack Timelines").setIcon("clock").onClick(() => {
              new RenderTimelinesModal(this.app, this).open();
            });
          });
        }
      })
    );
    this.registerEvent(
      this.app.workspace.on("active-leaf-change", () => {
        this.injectCanvasButtons();
      })
    );
    this.injectCanvasButtons();
  }
  onunload() {
    console.log("Unloading IOC Canvas Plugin");
    document.querySelectorAll(".ioc-toolbar").forEach((el) => el.remove());
    document.querySelectorAll(".ioc-reduced").forEach((el) => el.classList.remove("ioc-reduced"));
  }
  // ---------------------------------------------------------------
  // Settings persistence
  // ---------------------------------------------------------------
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  // ---------------------------------------------------------------
  // Thin delegation to canvas modules
  // ---------------------------------------------------------------
  /** Inject toolbar buttons into the active canvas view. */
  injectCanvasButtons() {
    addCanvasButtons({
      app: this.app,
      isReducedView: this.isReducedView,
      onTimeline: () => new RenderTimelinesModal(this.app, this).open(),
      onAddCard: () => openIOCCardSelector(this.app, (id, os) => createIOCCard(this.app, id, os, false), "Select Parent IOC Type"),
      onChildCard: () => openIOCCardSelector(this.app, (id, os) => createIOCCard(this.app, id, os, true), "Select Child IOC Type"),
      onReduce: () => {
        this.isReducedView = toggleReduceView(this.app, this.isReducedView);
        return this.isReducedView;
      },
      onMitre: () => {
        const activeTechniqueId = getSelectedTechniqueId(this.app);
        new RenderMitreModal(this.app, this, activeTechniqueId).open();
      }
    });
  }
};
