/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => IOCCanvasPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian4 = require("obsidian");

// src/RenderTimelinesModal.ts
var import_obsidian = require("obsidian");

// src/IOCCardsTypes.ts
var IOC_TYPES = {
  // --- Network-related IOC types ---
  ip_address: {
    name: "IP Address",
    icon: "network",
    color: "#FF6B6B",
    fields: ["IP", "country", "asn"],
    svg: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="32" height="32" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
  <circle cx="12" cy="15" r="7"/>
  <path d="M12 8c-3.9 0-7 3.1-7 7"/>
  <path d="M12 8c3.9 0 7 3.1 7 7"/>
  <line x1="5" y1="15" x2="19" y2="15"/>
  <line x1="12" y1="8" x2="12" y2="22"/>
  <path d="M12 8c-1.7-3-1.7-6 0-6s1.7 3 0 6z"/>
  <circle cx="12" cy="4" r="2" fill="currentColor"/>
</svg>`
  },
  domain: {
    name: "Domain Name",
    icon: "globe",
    color: "#4ECDC4",
    fields: ["name", "IP"],
    svg: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="32" height="32" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
    <circle cx="12" cy="12" r="10"/>
    <line x1="2" y1="12" x2="22" y2="12"/>
    <path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"/>
  </svg>`
  },
  file_hash: {
    name: "File Hash",
    icon: "hash",
    color: "#45B7D1",
    fields: ["hash", "hash_type", "filename", "file_size"],
    svg: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="32" height="32" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
    <line x1="4" y1="9" x2="20" y2="9"/>
    <line x1="4" y1="15" x2="20" y2="15"/>
    <line x1="10" y1="3" x2="8" y2="21"/>
    <line x1="16" y1="3" x2="14" y2="21"/>
  </svg>`
  },
  url: {
    name: "URL",
    icon: "link",
    color: "#96CEB4",
    fields: ["url", "domain", "category"],
    svg: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="32" height="32" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
    <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"/>
    <path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"/>
  </svg>`
  },
  email: {
    name: "Email Address",
    icon: "mail",
    color: "#FECA57",
    fields: ["email", "domain"],
    svg: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="32" height="32" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
    <path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"/>
    <polyline points="22,6 12,13 2,6"/>
  </svg>`
  },
  // Hostname is the only IOC type with os_icons, triggering a secondary
  // OS selector sub-view in RenderIOCCardsModal before card creation.
  hostname: {
    name: "Hostname",
    icon: "monitor",
    color: "#9C27B0",
    fields: ["hostname", "os_type", "domain"],
    svg: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="32" height="32" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
    <rect x="2" y="3" width="20" height="14" rx="2" ry="2"/>
    <line x1="8" y1="21" x2="16" y2="21"/>
    <line x1="12" y1="17" x2="12" y2="21"/>
  </svg>`,
    os_icons: {
      windows_workstation: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="32" height="32" fill="currentColor">
    <path d="M0 3.5L10 2v9.5H0V3.5zM11 1.9l13-1.9v11H11V1.9zM0 12.5h10V22l-10-1.5v-8zM11 12h13v10l-13 2v-12z"/>
  </svg>`,
      windows_server: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="32" height="32" fill="currentColor">
    <path d="M0 3.5L10 2v9.5H0V3.5zM11 1.9l13-1.9v11H11V1.9zM0 12.5h10V22l-10-1.5v-8zM11 12h13v10l-13 2v-12z"/>
  </svg>`,
      macos: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="32" height="32" fill="currentColor">
    <path d="M17.05 20.28c-.98.95-2.05.8-3.08.35-1.09-.46-2.09-.48-3.24 0-1.44.62-2.2.44-3.06-.35C2.79 15.25 3.51 7.59 9.05 7.31c1.35.07 2.29.74 3.08.8 1.18-.24 2.31-.93 3.57-.84 1.51.12 2.65.72 3.4 1.8-3.12 1.87-2.38 5.98.48 7.13-.57 1.5-1.31 2.99-2.54 4.09l.01-.01zM12.03 7.25c-.15-2.23 1.66-4.07 3.74-4.25.29 2.58-2.34 4.5-3.74 4.25z"/>
  </svg>`,
      linux: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="32" height="32" fill="currentColor">
    <path d="M12.504 0c-.155 0-.315.008-.48.021-4.226.333-3.105 4.807-3.17 6.298-.076 1.092-.3 1.953-1.05 3.02-.885 1.051-2.127 2.75-2.716 4.521-.278.84-.41 1.684-.287 2.489.845 5.548 5.676 6.016 6.855 6.016.178 0 .287-.016.287-.016s8.029-.192 8.03-8.047c0-4.662-3.916-9.69-7.47-14.302z"/>
  </svg>`
    }
  },
  // --- Detection rule types ---
  yara_rule: {
    name: "YARA Rule",
    icon: "shield",
    color: "#FF9FF3",
    fields: ["rule_name", "rule_content"],
    svg: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="32" height="32" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
    <path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"/>
    <text x="12" y="15" font-size="10" text-anchor="middle" fill="currentColor" font-weight="bold">Y</text>
  </svg>`
  },
  sigma_rule: {
    name: "Sigma Rule",
    icon: "search",
    color: "#A8E6CF",
    fields: ["rule_name", "rule_content"],
    svg: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="32" height="32" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
    <circle cx="12" cy="12" r="10"/>
    <text x="12" y="17" font-size="14" text-anchor="middle" fill="currentColor" font-weight="bold">\u03A3</text>
  </svg>`
  },
  // --- Host-based IOC types ---
  registry_key: {
    name: "Registry Key",
    icon: "settings",
    color: "#FFB74D",
    fields: ["key_path", "key_name", "key_data"],
    svg: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="32" height="32" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
    <rect x="3" y="11" width="18" height="11" rx="2" ry="2"/>
    <path d="M7 11V7a5 5 0 0 1 9.9-1"/>
  </svg>`
  },
  process_name: {
    name: "Process Name",
    icon: "cpu",
    color: "#81C784",
    fields: ["process_name", "command_line", "pid", "parent_process"],
    svg: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="32" height="32" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
  <rect x="3" y="5" width="18" height="14" rx="2" ry="2"/>
  <line x1="3" y1="9" x2="21" y2="9"/>
  <circle cx="6" cy="7" r="0.8" fill="currentColor"/>
  <circle cx="9" cy="7" r="0.8" fill="currentColor"/>
  <line x1="7" y1="13" x2="17" y2="13"/>
  <line x1="7" y1="16" x2="14" y2="16"/>
</svg>`
  },
  network: {
    name: "Network",
    icon: "activity",
    color: "#9575CD",
    fields: ["protocol", "port", "direction"],
    svg: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="32" height="32" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
    <polyline points="22 12 18 12 15 21 9 3 6 12 2 12"/>
  </svg>`
  },
  command_line: {
    name: "Command Line",
    icon: "terminal",
    color: "#2E8B57",
    fields: ["command", "pid", "parent_process"],
    svg: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="32" height="32" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
    <polyline points="4 17 10 11 4 5"/>
    <line x1="12" y1="19" x2="20" y2="19"/>
  </svg>`
  },
  // --- File and artifact types ---
  file: {
    name: "File",
    icon: "file",
    color: "#E91E63",
    fields: ["name", "type", "path", "size", "hash", "pid"],
    svg: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="32" height="32" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
  <path d="M4 4h12l4 4v12a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2z"/>
  <line x1="8" y1="11" x2="16" y2="11"/>
  <line x1="8" y1="15" x2="16" y2="15"/>
</svg>`
  },
  // --- Utility types ---
  note: {
    name: "Note",
    icon: "note",
    color: "#F39C12",
    fields: ["NB"],
    svg: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="32" height="32" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
  <rect x="4" y="4" width="16" height="16" rx="2" ry="2"/>
  <line x1="8" y1="8" x2="16" y2="8"/>
  <line x1="8" y1="12" x2="16" y2="12"/>
  <line x1="8" y1="16" x2="14" y2="16"/>
</svg>`
  },
  dll: {
    name: "DLL",
    icon: "dll",
    color: "#3498DB",
    fields: ["name", "type", "path", "size", "hash"],
    svg: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="32" height="32" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
  <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8l-6-6z"/>
  <polyline points="14 2 14 8 20 8"/>
  <circle cx="12" cy="13" r="2"/>
  <path d="M12 10.5v-1"/>
  <path d="M12 15.5v1"/>
  <path d="M14.5 11.5l0.7-0.7"/>
  <path d="M9.8 16.2l-0.7 0.7"/>
  <path d="M15.5 13h1"/>
  <path d="M8.5 13h-1"/>
  <path d="M14.5 14.5l0.7 0.7"/>
  <path d="M9.8 9.8l-0.7-0.7"/>
</svg>`
  },
  // --- Threat infrastructure ---
  c2: {
    name: "C2",
    icon: "c2",
    color: "#E74C3C",
    fields: ["domain", "IP"],
    svg: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="32" height="32" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
  <circle cx="12" cy="12" r="9"/>
  <path d="M12 3v1.5"/>
  <path d="M12 19.5V21"/>
  <path d="M3 12h1.5"/>
  <path d="M19.5 12H21"/>
  <path d="M5.6 5.6l1.1 1.1"/>
  <path d="M17.3 17.3l1.1 1.1"/>
  <path d="M5.6 18.4l1.1-1.1"/>
  <path d="M17.3 6.7l1.1-1.1"/>
  <polyline points="8 10 11 13 8 16"/>
  <line x1="13" y1="16" x2="16" y2="16"/>
</svg>`
  }
};

// src/IOCParser.ts
var IOC_TYPE_PATTERNS = [
  { pattern: /IP Address/i, type: "IP Address" },
  { pattern: /Domain Name/i, type: "Domain Name" },
  { pattern: /File Hash/i, type: "File Hash" },
  { pattern: /URL/i, type: "URL" },
  { pattern: /Email Address/i, type: "Email Address" },
  { pattern: /Hostname/i, type: "Hostname" },
  { pattern: /YARA Rule/i, type: "YARA Rule" },
  { pattern: /Sigma Rule/i, type: "Sigma Rule" },
  { pattern: /Registry Key/i, type: "Registry Key" },
  { pattern: /Process Name/i, type: "Process Name" },
  // FIX: The IOC_TYPES constant uses "Network" (not "Network Traffic").
  // The old code used "Network Traffic" which would never match the
  // IOC_TYPES lookup, so color and icon were never resolved for this type.
  { pattern: /Network/i, type: "Network" },
  { pattern: /Command Line/i, type: "Command Line" },
  { pattern: /File/i, type: "File" },
  { pattern: /Note/i, type: "Note" },
  { pattern: /DLL/i, type: "DLL" },
  { pattern: /C2/i, type: "C2" }
];
function detectIOCType(text) {
  for (const { pattern, type } of IOC_TYPE_PATTERNS) {
    if (pattern.test(text)) {
      return type;
    }
  }
  return "";
}
function extractValue(text) {
  console.log("\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501");
  console.log("[IOCParser] extractValue - ===== STARTING VALUE EXTRACTION =====");
  console.log("[IOCParser] extractValue - Input text length:", text.length);
  console.log("[IOCParser] extractValue - Full input text:");
  console.log(text);
  console.log("[IOCParser] extractValue - First 400 chars:", text.substring(0, 400));
  console.log("\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501");
  console.log("[IOCParser] extractValue - Checking for legacy code block format...");
  const codeBlockMatch = text.match(/```([\s\S]*?)```/);
  if (codeBlockMatch && codeBlockMatch[1] && codeBlockMatch[1].trim()) {
    const value2 = codeBlockMatch[1].trim();
    console.log("[IOCParser] extractValue - \u2713 Found code block value:", value2);
    console.log("[IOCParser] extractValue - ===== EXTRACTION COMPLETE (code block) =====");
    return value2;
  }
  console.log("[IOCParser] extractValue - \u2717 No code block found, proceeding with field extraction");
  console.log('[IOCParser] extractValue - Splitting by HTML header tag "</div></div>"...');
  const parts = text.split("</div></div>");
  console.log("[IOCParser] extractValue - Split resulted in", parts.length, "parts");
  if (parts.length > 1) {
    console.log("[IOCParser] extractValue - Part 0 (header) length:", parts[0].length);
    console.log("[IOCParser] extractValue - Part 1 (content) length:", parts[1].length);
  }
  if (parts.length < 2) {
    console.log("[IOCParser] extractValue - \u2717 ERROR: No HTML header found!");
    console.log('[IOCParser] extractValue - This means "</div></div>" was not found in the card text');
    console.log("[IOCParser] extractValue - ===== EXTRACTION FAILED (no header) =====");
    return "";
  }
  console.log("[IOCParser] extractValue - \u2713 HTML header found, processing content...");
  let afterHeader = parts[1].trim();
  console.log("[IOCParser] extractValue - ===== CONTENT AFTER HEADER (FULL TEXT) =====");
  console.log('"""');
  console.log(afterHeader);
  console.log('"""');
  console.log("[IOCParser] extractValue - afterHeader length:", afterHeader.length);
  console.log("[IOCParser] extractValue - First 400 chars:", afterHeader.substring(0, 400));
  console.log("\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501");
  console.log("[IOCParser] extractValue - Searching for first field label (pattern: [text]:)...");
  const fieldMatch = afterHeader.match(/[^:\n]+:\s*/);
  if (!fieldMatch) {
    console.log("[IOCParser] extractValue - \u2717 ERROR: No field label found!");
    console.log("[IOCParser] extractValue - afterHeader starts with:", JSON.stringify(afterHeader.substring(0, 100)));
    console.log('[IOCParser] extractValue - Looking for pattern like "fieldname: \\n"');
    console.log("[IOCParser] extractValue - ===== EXTRACTION FAILED (no field label) =====");
    return "";
  }
  const firstFieldName = fieldMatch[0].trim();
  console.log("[IOCParser] extractValue - \u2713 Found FIRST field:", JSON.stringify(firstFieldName));
  console.log("[IOCParser] extractValue - Field match raw text:", JSON.stringify(fieldMatch[0]));
  console.log("[IOCParser] extractValue - Field match index:", fieldMatch.index, "length:", fieldMatch[0].length);
  console.log("[IOCParser] extractValue - This field will be used as the card VALUE");
  console.log("\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501");
  console.log("[IOCParser] extractValue - Extracting content after field label...");
  const afterFieldLabel = afterHeader.substring(fieldMatch.index + fieldMatch[0].length);
  console.log("[IOCParser] extractValue - ===== CONTENT AFTER FIELD LABEL (should contain value) =====");
  console.log('"""');
  console.log(afterFieldLabel);
  console.log('"""');
  console.log("[IOCParser] extractValue - afterFieldLabel length:", afterFieldLabel.length);
  console.log("[IOCParser] extractValue - First 300 chars:", afterFieldLabel.substring(0, 300));
  console.log("\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501");
  console.log("[IOCParser] extractValue - Searching for value delimiter (separator or next field)...");
  const separatorMatch = afterFieldLabel.match(/\n?-----/);
  const nextFieldMatch = afterFieldLabel.match(/\n([^:\n]+:\s*)/);
  let value;
  let delimiterIndex;
  let delimiterType;
  if (separatorMatch && separatorMatch.index !== void 0) {
    delimiterIndex = separatorMatch.index;
    delimiterType = "separator (-----)";
  }
  if (nextFieldMatch && nextFieldMatch.index !== void 0) {
    if (delimiterIndex === void 0 || nextFieldMatch.index < delimiterIndex) {
      delimiterIndex = nextFieldMatch.index;
      delimiterType = "next field";
    }
  }
  if (delimiterIndex === void 0) {
    console.log("[IOCParser] extractValue - WARNING: No delimiter found!");
    console.log("[IOCParser] extractValue - Searching for Time of Event as fallback...");
    const timeIndex = afterFieldLabel.indexOf("Time of Event:");
    if (timeIndex === -1) {
      value = afterFieldLabel;
      console.log("[IOCParser] extractValue - No Time of Event either, using all remaining content");
    } else {
      value = afterFieldLabel.substring(0, timeIndex);
      console.log("[IOCParser] extractValue - Extracted until Time of Event at index", timeIndex);
    }
  } else {
    value = afterFieldLabel.substring(0, delimiterIndex);
    console.log(`[IOCParser] extractValue - SUCCESS: Found ${delimiterType} at index`, delimiterIndex);
    console.log("[IOCParser] extractValue - Raw value (before trim):", JSON.stringify(value));
    console.log("[IOCParser] extractValue - Raw value length:", value.length);
  }
  console.log("[IOCParser] extractValue - Trimming whitespace from extracted value...");
  const trimmedValue = value.trim();
  console.log("[IOCParser] extractValue - ===== FINAL EXTRACTED VALUE =====");
  console.log("[IOCParser] extractValue - Value (trimmed):", JSON.stringify(trimmedValue));
  console.log("[IOCParser] extractValue - Value length:", trimmedValue.length);
  console.log("[IOCParser] extractValue - Value is empty?", trimmedValue.length === 0);
  if (trimmedValue.length === 0) {
    console.log("[IOCParser] extractValue - \u26A0\uFE0F  WARNING: Extracted value is EMPTY!");
    console.log("[IOCParser] extractValue - This means no content was found between field label and separator");
  } else {
    console.log("[IOCParser] extractValue - \u2713 SUCCESS: Value extracted successfully");
  }
  console.log("[IOCParser] extractValue - ===== EXTRACTION COMPLETE =====");
  console.log("\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501");
  return trimmedValue;
}
function extractTime(text) {
  const timePatterns = [
    /\*\*Time of Event:\*\*\s*(\d{4}-\d{2}-\d{2}\s\d{2}:\d{2}:\d{2})/i,
    /\*\*Time of Event:\*\*\s*(\d{4}-\d{2}-\d{2})/i,
    /Time of Event[:\s]*(\d{4}-\d{2}-\d{2}[T\s]\d{2}:\d{2}:\d{2})/i,
    /Time of Event[:\s]*(\d{4}-\d{2}-\d{2})/i,
    /Time[:\s]*(\d{4}-\d{2}-\d{2}[T\s]\d{2}:\d{2}:\d{2})/i,
    /(\d{4}-\d{2}-\d{2}[T\s]\d{2}:\d{2}:\d{2})/i
  ];
  for (const pattern of timePatterns) {
    const match = text.match(pattern);
    if (match && match[1]) {
      return match[1].trim();
    }
  }
  return "";
}
function extractSplunkQuery(text) {
  const match = text.match(/\*\*Splunk Query:\*\*[:\s]*([\s\S]*?)(?=\*\*|$)/i);
  if (match && match[1] && match[1].trim()) {
    return match[1].trim();
  }
  return "";
}
function extractTactic(text) {
  const match = text.match(/\*\*Mitre Tactic:\*\*\s*([^\n]+)/i) || text.match(/\*\*Mitre Tactic:\*\*[:\s]*([\s\S]*?)(?=\*\*|$)/i);
  if (match && match[1]) {
    return match[1].trim();
  }
  return "";
}
function extractTechnique(text) {
  const match = text.match(/\*\*Mitre Technique:\*\*\s*([^\n]+)/i) || text.match(/\*\*Mitre Technique:\*\*[:\s]*([\s\S]*?)(?=\*\*|$)/i);
  if (match && match[1]) {
    return match[1].trim();
  }
  return "";
}
function lookupTypeVisuals(iocType, fallbackColor) {
  let icon = "";
  let color = fallbackColor;
  if (IOC_TYPES && typeof IOC_TYPES === "object") {
    for (const key of Object.keys(IOC_TYPES)) {
      if (IOC_TYPES[key].name === iocType) {
        icon = IOC_TYPES[key].svg;
        color = IOC_TYPES[key].color;
        break;
      }
    }
  }
  return { icon, color };
}
function parseIOCNode(node) {
  console.log("[IOCParser] parseIOCNode - Processing node ID:", node.id);
  if (!node.text) {
    console.log("[IOCParser] parseIOCNode - Node has no text, skipping");
    return null;
  }
  const text = node.text;
  console.log("[IOCParser] parseIOCNode - Node text length:", text.length);
  const iocType = detectIOCType(text);
  console.log("[IOCParser] parseIOCNode - Detected IOC type:", iocType || "NONE");
  if (!iocType) {
    console.log("[IOCParser] parseIOCNode - No IOC type detected, returning null");
    return null;
  }
  console.log("[IOCParser] parseIOCNode - Extracting fields for type:", iocType);
  console.log("[IOCParser] parseIOCNode - ===== VALUE EXTRACTION START =====");
  const value = extractValue(text);
  console.log("[IOCParser] parseIOCNode - ===== VALUE EXTRACTION END =====");
  console.log("[IOCParser] parseIOCNode - EXTRACTED VALUE:", value || "(empty/null)", "(length:", value ? value.length : 0, ")");
  const time = extractTime(text);
  const splunkQuery = extractSplunkQuery(text);
  const tactic = extractTactic(text);
  const technique = extractTechnique(text);
  console.log("[IOCParser] parseIOCNode - All extracted fields:");
  console.log("  - value:", value || "**EMPTY**");
  console.log("  - time:", time || "(empty)");
  console.log("  - splunkQuery:", splunkQuery || "(empty)");
  console.log("  - tactic:", tactic || "(empty)");
  console.log("  - technique:", technique || "(empty)");
  const fallbackColor = node.color || "#333";
  const { icon, color } = lookupTypeVisuals(iocType, fallbackColor);
  console.log("[IOCParser] parseIOCNode - Looked up visuals - color:", color, "icon length:", icon.length);
  const result = {
    id: node.id,
    type: iocType,
    value,
    time,
    splunkQuery,
    tactic,
    technique,
    icon,
    color
  };
  console.log("[IOCParser] parseIOCNode - ===== FINAL RESULT =====");
  console.log("[IOCParser] parseIOCNode - Returning node with value:", result.value || "**NO VALUE**");
  console.log("[IOCParser] parseIOCNode - Full result:", JSON.stringify(result, null, 2));
  console.log("[IOCParser] parseIOCNode - ===== END PARSING =====");
  return result;
}

// src/LinkTimelineProcessing.ts
var LinkTimelineProcessor = class {
  constructor(app, plugin, IOCCardsTypes) {
    this.app = app;
    this.plugin = plugin;
    this.IOCCardsTypes = IOCCardsTypes;
  }
  /**
   * Extract link-based attack chain data from the active canvas.
   *
   * Algorithm overview:
   *   1. Parse all canvas text nodes for IOC data using the shared parser
   *   2. Build adjacency lists (incoming/outgoing) from canvas edges
   *   3. Use BFS to assign each node to its maximum depth from any root
   *   4. Each node appears exactly ONCE at its calculated depth layer
   *   5. Group nodes into layers by depth for horizontal visualization
   *   6. Collect all edges for arrow rendering
   *   7. Collect isolated IOC nodes (no edges at all)
   *
   * This creates a layered DAG layout where nodes at the same depth are
   * displayed side-by-side horizontally, with SVG arrows connecting parents
   * to children across layers.
   *
   * @returns Object with layers (array of LayeredNode arrays), edges, isolatedNodes, and diagnostic counters
   */
  extractEnhancedLinkData() {
    var _a, _b;
    console.log("\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550");
    console.log("[LinkProcessor] ===== STARTING LINK TIMELINE EXTRACTION =====");
    const activeLeaf = this.app.workspace.activeLeaf;
    if (!activeLeaf || !activeLeaf.view) {
      console.log("[LinkProcessor] \u2717 No active workspace leaf found");
      console.log("[LinkProcessor] ===== EXTRACTION FAILED =====");
      return { layers: [], edges: [], isolatedNodes: [], canvasFound: false, totalNodes: 0, totalEdges: 0, iocNodes: 0, validConnections: 0, rootNodes: 0 };
    }
    if (activeLeaf.view.getViewType() !== "canvas") {
      console.log("[LinkProcessor] \u2717 Not a canvas view");
      console.log("[LinkProcessor] ===== EXTRACTION FAILED =====");
      return { layers: [], edges: [], isolatedNodes: [], canvasFound: false, totalNodes: 0, totalEdges: 0, iocNodes: 0, validConnections: 0, rootNodes: 0 };
    }
    const canvasView = activeLeaf.view;
    const canvas = canvasView.canvas;
    if (!canvas) {
      console.log("[LinkProcessor] \u2717 No canvas object in view");
      console.log("[LinkProcessor] ===== EXTRACTION FAILED =====");
      return { layers: [], edges: [], isolatedNodes: [], canvasFound: false, totalNodes: 0, totalEdges: 0, iocNodes: 0, validConnections: 0, rootNodes: 0 };
    }
    let nodes = [];
    let edges = [];
    if (canvas.nodes instanceof Map) {
      canvas.nodes.forEach((node) => nodes.push(node));
    } else if (Array.isArray(canvas.nodes)) {
      nodes = canvas.nodes;
    } else if ((_a = canvas.data) == null ? void 0 : _a.nodes) {
      nodes = Array.isArray(canvas.data.nodes) ? canvas.data.nodes : [];
    }
    if (canvas.edges instanceof Map) {
      canvas.edges.forEach((edge) => edges.push(edge));
    } else if (Array.isArray(canvas.edges)) {
      edges = canvas.edges;
    } else if ((_b = canvas.data) == null ? void 0 : _b.edges) {
      edges = Array.isArray(canvas.data.edges) ? canvas.data.edges : [];
    }
    console.log("[LinkProcessor] \u2713 Canvas data retrieved");
    console.log(`[LinkProcessor] Final counts: ${nodes.length} nodes, ${edges.length} edges`);
    if (nodes.length === 0) {
      console.log("[LinkProcessor] \u2717 No nodes found in canvas");
      console.log("[LinkProcessor] ===== EXTRACTION COMPLETE (EMPTY) =====");
      return { layers: [], edges: [], isolatedNodes: [], canvasFound: true, totalNodes: 0, totalEdges: edges.length, iocNodes: 0, validConnections: 0, rootNodes: 0 };
    }
    console.log("[LinkProcessor] \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500");
    console.log("[LinkProcessor] STEP 1: Parsing IOC nodes...");
    const iocNodeMap = /* @__PURE__ */ new Map();
    const incomingConnections = /* @__PURE__ */ new Map();
    const outgoingConnections = /* @__PURE__ */ new Map();
    const edgeLabels = /* @__PURE__ */ new Map();
    let iocNodeCount = 0;
    let emptyValueCount = 0;
    if (nodes.length !== 0) {
      nodes.forEach((node, index) => {
        if (node.text) {
          console.log(`[LinkProcessor]   Node ${index + 1}/${nodes.length}: ${node.id}`);
          const nodeData = parseIOCNode(node);
          if (nodeData) {
            iocNodeMap.set(node.id, nodeData);
            outgoingConnections.set(node.id, []);
            incomingConnections.set(node.id, []);
            iocNodeCount++;
            console.log(`[LinkProcessor]   \u2713 IOC detected: ${nodeData.type}`);
            console.log(`[LinkProcessor]     Value: ${nodeData.value ? `"${nodeData.value}"` : "(EMPTY)"}`);
            if (!nodeData.value || !nodeData.value.trim()) {
              emptyValueCount++;
              console.log("[LinkProcessor]     \u26A0\uFE0F  WARNING: This IOC has an EMPTY value!");
            }
          } else {
            console.log(`[LinkProcessor]   \u2717 Not an IOC node`);
          }
        }
      });
    }
    console.log("[LinkProcessor] \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500");
    console.log(`[LinkProcessor] STEP 1 COMPLETE: ${iocNodeCount} IOC nodes identified`);
    console.log(`[LinkProcessor]   IOCs with values: ${iocNodeCount - emptyValueCount}`);
    console.log(`[LinkProcessor]   IOCs with EMPTY values: ${emptyValueCount}`);
    if (iocNodeCount === 0) {
      console.log("[LinkProcessor] \u2717 No IOC nodes found in canvas");
      console.log("[LinkProcessor] ===== EXTRACTION COMPLETE (NO IOCs) =====");
      return {
        layers: [],
        edges: [],
        isolatedNodes: [],
        canvasFound: true,
        totalNodes: nodes.length,
        totalEdges: edges.length,
        iocNodes: 0,
        validConnections: 0,
        rootNodes: 0
      };
    }
    console.log("[LinkProcessor] \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500");
    console.log("[LinkProcessor] STEP 2: Processing edges...");
    let validConnectionCount = 0;
    if (nodes.length !== 0) {
      edges.forEach((edge, edgeIndex) => {
        var _a2, _b2, _c, _d, _e, _f;
        let fromId = null;
        let toId = null;
        if ((_b2 = (_a2 = edge.from) == null ? void 0 : _a2.node) == null ? void 0 : _b2.id) {
          fromId = edge.from.node.id;
        } else if ((_c = edge.from) == null ? void 0 : _c.id) {
          fromId = edge.from.id;
        } else if (typeof edge.from === "string") {
          fromId = edge.from;
        }
        if (!fromId) {
          for (const prop of ["fromNode", "fromId", "source", "sourceId"]) {
            if (edge[prop] && typeof edge[prop] === "string") {
              fromId = edge[prop];
              break;
            }
          }
        }
        if ((_e = (_d = edge.to) == null ? void 0 : _d.node) == null ? void 0 : _e.id) {
          toId = edge.to.node.id;
        } else if ((_f = edge.to) == null ? void 0 : _f.id) {
          toId = edge.to.id;
        } else if (typeof edge.to === "string") {
          toId = edge.to;
        }
        if (!toId) {
          for (const prop of ["toNode", "toId", "target", "targetId"]) {
            if (edge[prop] && typeof edge[prop] === "string") {
              toId = edge[prop];
              break;
            }
          }
        }
        if (!fromId || !toId)
          return;
        let edgeLabel = "";
        if (edge.label) {
          edgeLabel = edge.label;
        } else if (edge.text) {
          edgeLabel = edge.text;
        }
        console.log(`[LinkProcessor]   Edge ${edgeIndex + 1}/${edges.length}: ${fromId} -> ${toId}`);
        if (edgeLabel) {
          console.log(`[LinkProcessor]     Label: "${edgeLabel}"`);
        }
        if (iocNodeMap.has(fromId) && iocNodeMap.has(toId)) {
          const fromConnections = outgoingConnections.get(fromId);
          const toConnections = incomingConnections.get(toId);
          if (fromConnections && toConnections) {
            fromConnections.push(toId);
            toConnections.push(fromId);
            const edgeKey = `${fromId}->${toId}`;
            edgeLabels.set(edgeKey, edgeLabel);
            validConnectionCount++;
            console.log(`[LinkProcessor]     \u2713 Valid IOC connection`);
          }
        } else {
          console.log(`[LinkProcessor]     \u2717 Not an IOC-to-IOC edge (skipped)`);
        }
      });
    }
    console.log("[LinkProcessor] \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500");
    console.log(`[LinkProcessor] STEP 2 COMPLETE: ${validConnectionCount} valid connections`);
    console.log("[LinkProcessor] \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500");
    console.log("[LinkProcessor] STEP 3: Building layered DAG structure...");
    const nodeDepths = /* @__PURE__ */ new Map();
    const rootNodeIds = [];
    iocNodeMap.forEach((nodeData, nodeId) => {
      const incoming = incomingConnections.get(nodeId) || [];
      if (incoming.length === 0) {
        rootNodeIds.push(nodeId);
        nodeDepths.set(nodeId, 0);
        console.log(`[LinkProcessor]   \u2713 Root node: ${nodeId} (${nodeData.type})`);
      }
    });
    console.log(`[LinkProcessor] Found ${rootNodeIds.length} root nodes`);
    const queue = rootNodeIds.map((id) => ({ nodeId: id, depth: 0 }));
    const visited = /* @__PURE__ */ new Set();
    while (queue.length > 0) {
      const { nodeId, depth } = queue.shift();
      if (visited.has(nodeId)) {
        const currentDepth = nodeDepths.get(nodeId) || 0;
        if (depth > currentDepth) {
          nodeDepths.set(nodeId, depth);
        }
        continue;
      }
      visited.add(nodeId);
      nodeDepths.set(nodeId, depth);
      const children = outgoingConnections.get(nodeId) || [];
      for (const childId of children) {
        queue.push({ nodeId: childId, depth: depth + 1 });
      }
    }
    iocNodeMap.forEach((_, nodeId) => {
      var _a2, _b2;
      if (!nodeDepths.has(nodeId)) {
        const hasConn = (((_a2 = outgoingConnections.get(nodeId)) == null ? void 0 : _a2.length) || 0) > 0 || (((_b2 = incomingConnections.get(nodeId)) == null ? void 0 : _b2.length) || 0) > 0;
        if (hasConn) {
          nodeDepths.set(nodeId, 0);
          const orphanQueue = [{ nodeId, depth: 0 }];
          const orphanVisited = /* @__PURE__ */ new Set();
          while (orphanQueue.length > 0) {
            const { nodeId: currentId, depth: currentDepth } = orphanQueue.shift();
            if (orphanVisited.has(currentId))
              continue;
            orphanVisited.add(currentId);
            if (!nodeDepths.has(currentId)) {
              nodeDepths.set(currentId, currentDepth);
            }
            const orphanChildren = outgoingConnections.get(currentId) || [];
            for (const childId of orphanChildren) {
              if (!nodeDepths.has(childId)) {
                orphanQueue.push({ nodeId: childId, depth: currentDepth + 1 });
              }
            }
          }
        }
      }
    });
    const layerMap = /* @__PURE__ */ new Map();
    let maxDepth = 0;
    nodeDepths.forEach((depth, nodeId) => {
      const nodeData = iocNodeMap.get(nodeId);
      if (nodeData) {
        if (!layerMap.has(depth)) {
          layerMap.set(depth, []);
        }
        layerMap.get(depth).push({
          data: nodeData,
          nodeId,
          depth
        });
        maxDepth = Math.max(maxDepth, depth);
      }
    });
    const layers = [];
    for (let i = 0; i <= maxDepth; i++) {
      layers.push(layerMap.get(i) || []);
    }
    const graphEdges = [];
    edges.forEach((edge) => {
      var _a2, _b2, _c, _d, _e, _f;
      let fromId = null;
      let toId = null;
      if ((_b2 = (_a2 = edge.from) == null ? void 0 : _a2.node) == null ? void 0 : _b2.id) {
        fromId = edge.from.node.id;
      } else if ((_c = edge.from) == null ? void 0 : _c.id) {
        fromId = edge.from.id;
      } else if (typeof edge.from === "string") {
        fromId = edge.from;
      }
      if (!fromId) {
        for (const prop of ["fromNode", "fromId", "source", "sourceId"]) {
          if (edge[prop] && typeof edge[prop] === "string") {
            fromId = edge[prop];
            break;
          }
        }
      }
      if ((_e = (_d = edge.to) == null ? void 0 : _d.node) == null ? void 0 : _e.id) {
        toId = edge.to.node.id;
      } else if ((_f = edge.to) == null ? void 0 : _f.id) {
        toId = edge.to.id;
      } else if (typeof edge.to === "string") {
        toId = edge.to;
      }
      if (!toId) {
        for (const prop of ["toNode", "toId", "target", "targetId"]) {
          if (edge[prop] && typeof edge[prop] === "string") {
            toId = edge[prop];
            break;
          }
        }
      }
      if (fromId && toId && iocNodeMap.has(fromId) && iocNodeMap.has(toId)) {
        const edgeLabel = edge.label || edge.text || "";
        graphEdges.push({
          fromId,
          toId,
          label: edgeLabel
        });
      }
    });
    const isolatedNodeIds = [];
    iocNodeMap.forEach((nodeData, nodeId) => {
      const nodeOutgoing = outgoingConnections.get(nodeId) || [];
      const nodeIncoming = incomingConnections.get(nodeId) || [];
      const hasAnyConnections = nodeOutgoing.length > 0 || nodeIncoming.length > 0;
      if (!hasAnyConnections) {
        isolatedNodeIds.push(nodeId);
        console.log(`Isolated node identified: ${nodeId}`);
      }
    });
    const isolatedNodes = isolatedNodeIds.map((nodeId) => iocNodeMap.get(nodeId)).filter(Boolean);
    const result = {
      layers,
      edges: graphEdges,
      isolatedNodes,
      canvasFound: true,
      totalNodes: nodes.length,
      totalEdges: edges.length,
      iocNodes: iocNodeCount,
      validConnections: validConnectionCount,
      rootNodes: rootNodeIds.length
    };
    console.log("[LinkProcessor] \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500");
    console.log("[LinkProcessor] ===== EXTRACTION COMPLETE =====");
    console.log("[LinkProcessor] Result summary:");
    console.log(`[LinkProcessor]   Layers: ${layers.length}`);
    console.log(`[LinkProcessor]   Nodes in layers: ${layers.reduce((sum, layer) => sum + layer.length, 0)}`);
    console.log(`[LinkProcessor]   Edges: ${graphEdges.length}`);
    console.log(`[LinkProcessor]   Isolated nodes: ${isolatedNodes.length}`);
    console.log(`[LinkProcessor]   Root nodes: ${rootNodeIds.length}`);
    layers.forEach((layer, index) => {
      if (layer.length > 0) {
        console.log(`[LinkProcessor]   Layer ${index}: ${layer.length} nodes`);
        layer.forEach((node) => {
          console.log(`[LinkProcessor]     - ${node.data.type}: ${node.data.value || "(empty)"}`);
        });
      }
    });
    console.log("\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550");
    return result;
  }
};

// src/TimeTimelineProcessing.ts
var TimeTimelineProcessor = class {
  constructor(app, plugin, IOCCardsTypes) {
    this.app = app;
    this.plugin = plugin;
    this.IOCCardsTypes = IOCCardsTypes;
  }
  /**
   * Extract IOC data from all canvas text nodes for time-based timeline.
   *
   * Iterates over every node in the active canvas. Each node with a `text`
   * property is parsed via the shared IOCParser. Nodes that match a known
   * IOC type are included in the returned array.
   *
   * The caller (RenderTimelinesModal) sorts the result by time for display.
   *
   * DEBUG: Console logs show processing steps for troubleshooting.
   *
   * @returns Array of parsed IOC node data objects, unsorted
   */
  extractFixedIOCData() {
    console.log("\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550");
    console.log("[TimeProcessor] ===== STARTING TIME TIMELINE EXTRACTION =====");
    const activeLeaf = this.app.workspace.activeLeaf;
    if (!activeLeaf || !activeLeaf.view || activeLeaf.view.getViewType() !== "canvas") {
      console.log("[TimeProcessor] \u2717 No active canvas view found");
      console.log("[TimeProcessor] ===== EXTRACTION FAILED =====");
      return [];
    }
    const canvasView = activeLeaf.view;
    const canvas = canvasView.canvas;
    if (!canvas || !canvas.nodes) {
      console.log("[TimeProcessor] \u2717 No canvas or canvas.nodes found");
      console.log("[TimeProcessor] ===== EXTRACTION FAILED =====");
      return [];
    }
    const totalNodes = canvas.nodes.size || canvas.nodes.length || 0;
    console.log("[TimeProcessor] \u2713 Canvas found with", totalNodes, "total nodes");
    console.log("[TimeProcessor] Processing nodes...");
    const iocData = [];
    let processedCount = 0;
    let iocCount = 0;
    let emptyValueCount = 0;
    canvas.nodes.forEach((node) => {
      processedCount++;
      if (node.text) {
        console.log(`[TimeProcessor] \u2500\u2500\u2500\u2500\u2500 Node ${processedCount}/${totalNodes} \u2500\u2500\u2500\u2500\u2500`);
        console.log("[TimeProcessor] Node ID:", node.id);
        console.log("[TimeProcessor] Parsing node...");
        const parsedData = parseIOCNode(node);
        if (parsedData) {
          iocCount++;
          console.log("[TimeProcessor] \u2713 IOC detected:", parsedData.type);
          console.log("[TimeProcessor]   Value:", parsedData.value ? `"${parsedData.value}"` : "(EMPTY)");
          console.log("[TimeProcessor]   Time:", parsedData.time || "(no time)");
          if (!parsedData.value || !parsedData.value.trim()) {
            emptyValueCount++;
            console.log("[TimeProcessor]   \u26A0\uFE0F  WARNING: This IOC has an EMPTY value!");
          }
          iocData.push(parsedData);
        } else {
          console.log("[TimeProcessor] \u2717 Not an IOC node (no match)");
        }
      }
    });
    console.log("[TimeProcessor] \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500");
    console.log("[TimeProcessor] ===== EXTRACTION SUMMARY =====");
    console.log("[TimeProcessor] Total nodes processed:", processedCount);
    console.log("[TimeProcessor] IOC cards found:", iocCount);
    console.log("[TimeProcessor] IOCs with values:", iocCount - emptyValueCount);
    console.log("[TimeProcessor] IOCs with EMPTY values:", emptyValueCount);
    console.log("[TimeProcessor] Returning", iocData.length, "IOC data objects");
    console.log("[TimeProcessor] ===== EXTRACTION COMPLETE =====");
    console.log("\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550");
    return iocData;
  }
};

// src/RenderTimelinesModal.ts
var RenderTimelinesModal = class extends import_obsidian.Modal {
  constructor(app, plugin) {
    super(app);
    this.plugin = plugin;
    this.activeTab = "time";
    this.timeProcessor = new TimeTimelineProcessor(app, plugin, plugin.iocTypes);
    this.linkProcessor = new LinkTimelineProcessor(app, plugin, plugin.iocTypes);
  }
  /** Builds the modal header with tab buttons and renders the default (time) tab. */
  onOpen() {
    const { contentEl } = this;
    this.modalEl.classList.add("timeline-modal-fullscreen");
    const headerContainer = contentEl.createDiv("timeline-modal-header");
    headerContainer.createEl("h2", { text: "\u{1F550} Attack Timeline Analysis - Full Screen View" });
    const tabContainer = headerContainer.createDiv("timeline-tabs");
    const timeTab = tabContainer.createEl("button", { text: "\u{1F552} Time Timeline", cls: "timeline-tab-button" });
    const linkTab = tabContainer.createEl("button", { text: "\u{1F517} Link Timeline", cls: "timeline-tab-button" });
    this.updateTabStyles(timeTab, linkTab);
    timeTab.addEventListener("click", () => {
      this.activeTab = "time";
      this.updateTabStyles(timeTab, linkTab);
      this.renderTabContent(contentEl);
    });
    linkTab.addEventListener("click", () => {
      this.activeTab = "link";
      this.updateTabStyles(timeTab, linkTab);
      this.renderTabContent(contentEl);
    });
    this.renderTabContent(contentEl);
  }
  /** Toggles the `active` CSS class between the two tab buttons. */
  updateTabStyles(timeTab, linkTab) {
    timeTab.classList.remove("active");
    linkTab.classList.remove("active");
    if (this.activeTab === "time") {
      timeTab.classList.add("active");
    } else if (this.activeTab === "link") {
      linkTab.classList.add("active");
    }
  }
  /**
   * Swaps out the tab content area. Removes the previous content DOM node and
   * creates a fresh one, then delegates to the appropriate renderer.
   */
  renderTabContent(contentEl) {
    const existingContent = contentEl.querySelector(".timeline-tab-content");
    if (existingContent) {
      existingContent.remove();
    }
    const contentArea = contentEl.createDiv("timeline-tab-content");
    if (this.activeTab === "time") {
      this.renderEnhancedTimeTimeline(contentArea);
    } else if (this.activeTab === "link") {
      this.renderEnhancedLayeredTimeline(contentArea);
    }
  }
  /**
   * Renders the chronological Time Timeline. Extracts IOC data from canvas
   * nodes via the time processor, sorts by event timestamp, and renders each
   * IOC as a colored card with a gradient connector to the next card.
   *
   * DEBUG: Console logs show timeline data for troubleshooting.
   */
  renderEnhancedTimeTimeline(container) {
    console.log("[TimeTimeline] renderEnhancedTimeTimeline - Starting render");
    const iocData = this.timeProcessor.extractFixedIOCData();
    console.log("[TimeTimeline] Extracted IOC data - count:", iocData.length);
    console.log("[TimeTimeline] IOC data sample:", iocData.slice(0, 3));
    if (iocData.length === 0) {
      console.log("[TimeTimeline] No IOC cards found, showing empty message");
      container.createEl("p", {
        text: "No IOC cards found in the current canvas. Create some IOC cards first to see the timeline.",
        cls: "timeline-empty-message"
      });
      return;
    }
    iocData.sort((a, b) => new Date(a.time).getTime() - new Date(b.time).getTime());
    console.log("[TimeTimeline] Sorted IOC data by time");
    const timelineContainer = container.createDiv("timeline-container");
    iocData.forEach((ioc, index) => {
      const timelineItem = timelineContainer.createDiv("timeline-item");
      timelineItem.style.setProperty("--ioc-color", ioc.color);
      timelineItem.style.setProperty("--ioc-color-30", `${ioc.color}30`);
      timelineItem.style.background = `linear-gradient(135deg, ${ioc.color}15 0%, ${ioc.color}05 100%)`;
      timelineItem.style.boxShadow = `0 4px 12px ${ioc.color}25`;
      timelineItem.style.borderColor = ioc.color;
      if (index < iocData.length - 1) {
        const connector = timelineItem.createDiv("timeline-connector");
        connector.style.background = `linear-gradient(180deg, ${ioc.color} 0%, ${iocData[index + 1].color} 100%)`;
      }
      const iconContainer = timelineItem.createDiv("timeline-icon");
      iconContainer.innerHTML = ioc.icon;
      iconContainer.style.background = `${ioc.color}20`;
      iconContainer.style.borderColor = ioc.color;
      const detailsContainer = timelineItem.createDiv("timeline-details");
      const titleEl = detailsContainer.createEl("h3", { text: ioc.type });
      titleEl.style.textShadow = `0 1px 3px ${ioc.color}40`;
      console.log("\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550");
      console.log("[TimeTimeline] ===== RENDERING IOC CARD =====");
      console.log("[TimeTimeline] IOC Type:", ioc.type);
      console.log("[TimeTimeline] IOC Value:", JSON.stringify(ioc.value));
      console.log("[TimeTimeline] Value is truthy?", !!ioc.value);
      console.log("[TimeTimeline] Value after trim:", ioc.value ? JSON.stringify(ioc.value.trim()) : "N/A");
      console.log("[TimeTimeline] Will display value?", !!(ioc.value && ioc.value.trim()));
      console.log("[TimeTimeline] IOC Time:", ioc.time);
      const timeEl = detailsContainer.createDiv("timeline-time");
      if (ioc.value && ioc.value.trim()) {
        timeEl.innerHTML = `\u{1F550} Time: ${ioc.time} - Value: ${ioc.value}`;
        console.log("[TimeTimeline] \u2713 DISPLAYING combined time+value:", timeEl.innerHTML);
      } else {
        timeEl.innerHTML = `\u{1F550} Time: ${ioc.time}`;
        console.log("[TimeTimeline] \u2717 NO VALUE - showing time only");
        console.log("[TimeTimeline] Reason: value is", ioc.value === void 0 ? "undefined" : ioc.value === null ? "null" : ioc.value === "" ? "empty string" : "falsy after trim");
      }
      console.log("\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550");
      if (ioc.splunkQuery && ioc.splunkQuery.trim()) {
        const splunkEl = detailsContainer.createDiv("timeline-splunk");
        splunkEl.innerHTML = `\u{1F50D} Splunk Query: ${ioc.splunkQuery}`;
      }
      if (ioc.tactic) {
        const tacticEl = detailsContainer.createDiv("timeline-tactic");
        tacticEl.innerHTML = `\u2694\uFE0F Tactic: ${ioc.tactic}`;
      }
      if (ioc.technique) {
        const techniqueEl = detailsContainer.createDiv("timeline-technique");
        techniqueEl.innerHTML = `\u{1F3AF} Technique: ${ioc.technique}`;
      }
      timelineItem.addEventListener("mouseover", () => {
        timelineItem.style.boxShadow = `0 8px 20px ${ioc.color}35`;
      });
      timelineItem.addEventListener("mouseout", () => {
        timelineItem.style.boxShadow = `0 4px 12px ${ioc.color}25`;
      });
    });
  }
  /**
   * Renders the Link Timeline as a layered DAG with horizontal layout.
   * Each node appears exactly once at its maximum depth, nodes at the same
   * depth are displayed side-by-side, and SVG arrows show all connections.
   *
   * DEBUG: Console logs show link timeline data and rendering steps.
   */
  renderEnhancedLayeredTimeline(container) {
    console.log("[LinkTimeline] renderEnhancedLayeredTimeline - Starting render");
    const linkData = this.linkProcessor.extractEnhancedLinkData();
    console.log("[LinkTimeline] Extracted link data:");
    console.log("  - Layers:", linkData.layers.length);
    console.log("  - Total nodes in layers:", linkData.layers.reduce((sum, layer) => sum + layer.length, 0));
    console.log("  - Edges:", linkData.edges.length);
    console.log("  - Isolated nodes:", linkData.isolatedNodes.length);
    if (linkData.layers.length === 0 && linkData.isolatedNodes.length === 0) {
      console.log("[LinkTimeline] No link data found, showing empty message");
      const emptyMessage = container.createEl("div", { cls: "timeline-empty-message" });
      emptyMessage.innerHTML = `
                <h3>Link Timeline Analysis</h3>
                <p>No connections found between IOC cards.</p>
            `;
      return;
    }
    console.log("[LinkTimeline] Proceeding with DAG rendering");
    const dagContainer = container.createDiv("dag-timeline-container");
    const svgNS = "http://www.w3.org/2000/svg";
    const svgContainer = document.createElementNS(svgNS, "svg");
    svgContainer.classList.add("dag-arrows-svg");
    svgContainer.style.position = "absolute";
    svgContainer.style.top = "0";
    svgContainer.style.left = "0";
    svgContainer.style.width = "100%";
    svgContainer.style.height = "100%";
    svgContainer.style.pointerEvents = "none";
    svgContainer.style.zIndex = "0";
    dagContainer.appendChild(svgContainer);
    const layersContainer = dagContainer.createDiv("dag-layers-container");
    layersContainer.style.position = "relative";
    layersContainer.style.zIndex = "1";
    const nodePositions = /* @__PURE__ */ new Map();
    linkData.layers.forEach((layer, layerIndex) => {
      if (layer.length === 0)
        return;
      const layerRow = layersContainer.createDiv("dag-layer-row");
      layerRow.setAttribute("data-layer", layerIndex.toString());
      layer.forEach((node) => {
        const nodeWrapper = layerRow.createDiv("dag-node-wrapper");
        nodeWrapper.setAttribute("data-node-id", node.nodeId);
        this.renderLayeredNodeCard(nodeWrapper, node.data);
      });
    });
    if (linkData.isolatedNodes.length > 0) {
      const isolatedSection = layersContainer.createDiv("dag-isolated-section");
      const isolatedHeader = isolatedSection.createEl("h4", {
        text: "Isolated Nodes (No Connections)",
        cls: "dag-isolated-header"
      });
      const isolatedContainer = isolatedSection.createDiv("dag-isolated-nodes");
      linkData.isolatedNodes.forEach((node) => {
        const nodeWrapper = isolatedContainer.createDiv("dag-node-wrapper");
        this.renderLayeredNodeCard(nodeWrapper, node);
      });
    }
    setTimeout(() => {
      this.calculateNodePositions(dagContainer, nodePositions);
      this.drawArrows(svgContainer, linkData.edges, nodePositions);
    }, 50);
  }
  /**
   * Calculate the center position of each node for arrow drawing
   */
  calculateNodePositions(container, positions) {
    const containerRect = container.getBoundingClientRect();
    const nodeWrappers = container.querySelectorAll(".dag-node-wrapper[data-node-id]");
    nodeWrappers.forEach((wrapper) => {
      const nodeId = wrapper.getAttribute("data-node-id");
      if (!nodeId)
        return;
      const rect = wrapper.getBoundingClientRect();
      positions.set(nodeId, {
        x: rect.left + rect.width / 2 - containerRect.left,
        y: rect.top + rect.height / 2 - containerRect.top,
        width: rect.width,
        height: rect.height
      });
    });
  }
  /**
   * Draw SVG arrows between connected nodes with improved routing to prevent overlap
   */
  drawArrows(svgContainer, edges, positions) {
    const svgNS = "http://www.w3.org/2000/svg";
    const defs = document.createElementNS(svgNS, "defs");
    const marker = document.createElementNS(svgNS, "marker");
    marker.setAttribute("id", "arrowhead");
    marker.setAttribute("markerWidth", "10");
    marker.setAttribute("markerHeight", "10");
    marker.setAttribute("refX", "9");
    marker.setAttribute("refY", "3");
    marker.setAttribute("orient", "auto");
    marker.setAttribute("markerUnits", "strokeWidth");
    const polygon = document.createElementNS(svgNS, "polygon");
    polygon.setAttribute("points", "0 0, 10 3, 0 6");
    polygon.setAttribute("fill", "var(--text-muted)");
    marker.appendChild(polygon);
    defs.appendChild(marker);
    svgContainer.appendChild(defs);
    const edgesBySource = /* @__PURE__ */ new Map();
    edges.forEach((edge) => {
      if (!edgesBySource.has(edge.fromId)) {
        edgesBySource.set(edge.fromId, []);
      }
      edgesBySource.get(edge.fromId).push(edge);
    });
    edgesBySource.forEach((sourceEdges, fromId) => {
      const fromPos = positions.get(fromId);
      if (!fromPos)
        return;
      if (sourceEdges.length === 1) {
        const edge = sourceEdges[0];
        const toPos = positions.get(edge.toId);
        if (!toPos)
          return;
        this.drawSingleArrow(svgContainer, svgNS, fromPos, toPos, edge);
      } else {
        this.drawMergedArrows(svgContainer, svgNS, fromPos, sourceEdges, positions);
      }
    });
  }
  /**
   * Draw a single arrow where the arrowhead touches the card but the line doesn't.
   * The arrow LINE is kept clear of cards (12px minimum), and the arrowhead (~10px)
   * extends from there to touch the card edge (effectively 0-2px from card).
   *
   * DEBUG: Console logs show arrow routing calculations.
   */
  drawSingleArrow(svgContainer, svgNS, fromPos, toPos, edge) {
    const LINE_CLEARANCE = 12;
    const ARROWHEAD_LENGTH = 10;
    const HORIZONTAL_CLEARANCE = 50;
    const x1 = fromPos.x;
    const y1 = fromPos.y + fromPos.height / 2 + LINE_CLEARANCE;
    const x2 = toPos.x;
    const y2 = toPos.y - toPos.height / 2 - LINE_CLEARANCE;
    console.log("[Arrow] drawSingleArrow - From:", edge.fromId, "To:", edge.toId);
    console.log("[Arrow]   Source pos:", fromPos.x, fromPos.y, "size:", fromPos.width, "x", fromPos.height);
    console.log("[Arrow]   Target pos:", toPos.x, toPos.y, "size:", toPos.width, "x", toPos.height);
    console.log("[Arrow]   Line start:", x1, y1, "(", LINE_CLEARANCE, "px below source)");
    console.log("[Arrow]   Line end:", x2, y2, "(", LINE_CLEARANCE, "px above target, arrowhead reaches", LINE_CLEARANCE - ARROWHEAD_LENGTH, "px)");
    const verticalGap = y2 - y1;
    const horizontalGap = Math.abs(x2 - x1);
    console.log("[Arrow]   Gaps: vertical=", verticalGap, "horizontal=", horizontalGap);
    let pathData;
    if (verticalGap > 50) {
      const exitLength = Math.max(30, verticalGap * 0.3);
      const entryLength = Math.max(30, verticalGap * 0.3);
      const midY1 = y1 + exitLength;
      const midY2 = y2 - entryLength;
      const midY = (midY1 + midY2) / 2;
      const sourceBottom = fromPos.y + fromPos.height / 2;
      const targetTop = toPos.y - toPos.height / 2;
      const safeHorizontalY = Math.max(
        midY,
        sourceBottom + HORIZONTAL_CLEARANCE,
        // Well below source card
        Math.min(midY, targetTop - HORIZONTAL_CLEARANCE)
        // Well above target card
      );
      pathData = `M ${x1} ${y1} L ${x1} ${safeHorizontalY} L ${x2} ${safeHorizontalY} L ${x2} ${y2}`;
      console.log("[Arrow]   Using orthogonal routing at safeHorizontalY=", safeHorizontalY);
    } else {
      const controlOffset = Math.max(60, horizontalGap * 0.5, verticalGap * 0.8);
      pathData = `M ${x1} ${y1} C ${x1} ${y1 + controlOffset}, ${x2} ${y2 - controlOffset}, ${x2} ${y2}`;
      console.log("[Arrow]   Using Bezier curve with controlOffset=", controlOffset);
    }
    const path = document.createElementNS(svgNS, "path");
    path.setAttribute("d", pathData);
    path.setAttribute("stroke", "var(--text-muted)");
    path.setAttribute("stroke-width", "2");
    path.setAttribute("fill", "none");
    path.setAttribute("marker-end", "url(#arrowhead)");
    path.setAttribute("opacity", "0.6");
    path.classList.add("dag-arrow");
    svgContainer.appendChild(path);
    if (edge.label && edge.label.trim()) {
      const labelY = (y1 + y2) / 2;
      const labelX = (x1 + x2) / 2;
      const text = document.createElementNS(svgNS, "text");
      text.setAttribute("x", labelX.toString());
      text.setAttribute("y", labelY.toString());
      text.setAttribute("text-anchor", "middle");
      text.setAttribute("fill", "var(--text-muted)");
      text.setAttribute("font-size", "11px");
      text.setAttribute("font-weight", "600");
      text.textContent = edge.label;
      svgContainer.appendChild(text);
    }
  }
  /**
   * Draw multiple arrows from same source with trunk-and-branch pattern.
   * Trunk and branches keep lines clear of cards (12px), arrowheads touch card edges.
   *
   * DEBUG: Console logs show trunk and branch routing.
   */
  drawMergedArrows(svgContainer, svgNS, fromPos, edges, positions) {
    const LINE_CLEARANCE = 12;
    const HORIZONTAL_CLEARANCE = 50;
    console.log("[Arrow] drawMergedArrows - Source:", edges[0].fromId, "- Branch count:", edges.length);
    const trunkX = fromPos.x;
    const trunkStartY = fromPos.y + fromPos.height / 2 + LINE_CLEARANCE;
    const trunkLength = 50;
    const trunkEndY = trunkStartY + trunkLength;
    console.log("[Arrow]   Trunk: x=", trunkX, "start y=", trunkStartY, "end y=", trunkEndY, "length=", trunkLength);
    const trunk = document.createElementNS(svgNS, "path");
    trunk.setAttribute("d", `M ${trunkX} ${trunkStartY} L ${trunkX} ${trunkEndY}`);
    trunk.setAttribute("stroke", "var(--text-muted)");
    trunk.setAttribute("stroke-width", "3");
    trunk.setAttribute("fill", "none");
    trunk.setAttribute("opacity", "0.7");
    trunk.classList.add("dag-arrow", "dag-arrow-trunk");
    svgContainer.appendChild(trunk);
    edges.forEach((edge, index) => {
      const toPos = positions.get(edge.toId);
      if (!toPos) {
        console.log("[Arrow]   Branch", index, "- Target not found:", edge.toId);
        return;
      }
      const targetX = toPos.x;
      const targetY = toPos.y - toPos.height / 2 - LINE_CLEARANCE;
      console.log("[Arrow]   Branch", index, "- Target:", edge.toId, "at", targetX, targetY);
      const horizontalOffset = targetX - trunkX;
      const verticalGap = targetY - trunkEndY;
      console.log("[Arrow]     Offsets: horizontal=", horizontalOffset, "vertical=", verticalGap);
      let branchPath;
      if (verticalGap > 40) {
        const sourceBottom = fromPos.y + fromPos.height / 2;
        const targetTop = toPos.y - toPos.height / 2;
        const baseMidY = trunkEndY + Math.max(30, verticalGap * 0.4);
        const safeHorizontalY = Math.max(
          baseMidY,
          sourceBottom + HORIZONTAL_CLEARANCE
          // Well below source card
        );
        branchPath = `M ${trunkX} ${trunkEndY} L ${trunkX} ${safeHorizontalY} L ${targetX} ${safeHorizontalY} L ${targetX} ${targetY}`;
        console.log("[Arrow]     Using orthogonal branch routing at safeHorizontalY=", safeHorizontalY);
      } else {
        const controlOffset = Math.max(50, Math.abs(horizontalOffset) * 0.5, verticalGap * 0.7);
        branchPath = `M ${trunkX} ${trunkEndY} C ${trunkX} ${trunkEndY + controlOffset}, ${targetX} ${targetY - controlOffset}, ${targetX} ${targetY}`;
        console.log("[Arrow]     Using Bezier branch with controlOffset=", controlOffset);
      }
      const branch = document.createElementNS(svgNS, "path");
      branch.setAttribute("d", branchPath);
      branch.setAttribute("stroke", "var(--text-muted)");
      branch.setAttribute("stroke-width", "2");
      branch.setAttribute("fill", "none");
      branch.setAttribute("marker-end", "url(#arrowhead)");
      branch.setAttribute("opacity", "0.6");
      branch.classList.add("dag-arrow", "dag-arrow-branch");
      svgContainer.appendChild(branch);
      if (edge.label && edge.label.trim()) {
        const labelX = (trunkX + targetX) / 2;
        const labelY = (trunkEndY + targetY) / 2;
        const text = document.createElementNS(svgNS, "text");
        text.setAttribute("x", labelX.toString());
        text.setAttribute("y", labelY.toString());
        text.setAttribute("text-anchor", "middle");
        text.setAttribute("fill", "var(--text-muted)");
        text.setAttribute("font-size", "11px");
        text.setAttribute("font-weight", "600");
        text.textContent = edge.label;
        svgContainer.appendChild(text);
      }
    });
  }
  /**
   * Renders a single layered node card with full IOC details.
   *
   * DEBUG: Console logs show node rendering details.
   */
  renderLayeredNodeCard(container, node) {
    const nodeColor = node.color || "var(--background-modifier-border)";
    console.log("\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550");
    console.log("[LinkTimeline] ===== RENDERING NODE CARD =====");
    console.log("[LinkTimeline] Node Type:", node.type);
    console.log("[LinkTimeline] Node ID:", node.id);
    console.log("[LinkTimeline] Node Value:", JSON.stringify(node.value));
    console.log("[LinkTimeline] Value is truthy?", !!node.value);
    console.log("[LinkTimeline] Value after trim:", node.value ? JSON.stringify(node.value.trim()) : "N/A");
    console.log("[LinkTimeline] Will display value?", !!(node.value && node.value.trim()));
    console.log("[LinkTimeline] Node Time:", node.time);
    const nodeContainer = container.createDiv("dag-node");
    nodeContainer.style.background = `linear-gradient(135deg, ${nodeColor}15 0%, ${nodeColor}05 100%)`;
    nodeContainer.style.boxShadow = `0 4px 12px ${nodeColor}25`;
    nodeContainer.style.borderColor = nodeColor;
    const nodeHeader = nodeContainer.createDiv("dag-node-header");
    const iconDiv = nodeHeader.createDiv("dag-node-icon");
    iconDiv.innerHTML = node.icon || "";
    iconDiv.style.background = `${nodeColor}20`;
    const nodeType = nodeHeader.createDiv("dag-node-type");
    nodeType.textContent = node.type || "Unknown IOC";
    const nodeDetails = nodeContainer.createDiv("dag-node-details");
    if (node.value && node.value.trim()) {
      console.log("[LinkTimeline] \u2713 DISPLAYING value:", node.value);
      const valueContainer = nodeDetails.createDiv("dag-node-value-container");
      const valueLabel = valueContainer.createDiv("dag-node-value-label");
      valueLabel.textContent = "Value";
      const valueEl = valueContainer.createDiv("dag-node-value-text");
      valueEl.textContent = node.value;
    } else {
      console.log("[LinkTimeline] \u2717 NO VALUE - not displaying");
      console.log("[LinkTimeline] Reason: value is", node.value === void 0 ? "undefined" : node.value === null ? "null" : node.value === "" ? "empty string" : "falsy after trim");
    }
    console.log("\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550");
    if (node.time && node.time.trim()) {
      const timeEl = nodeDetails.createDiv("dag-node-time");
      timeEl.innerHTML = `\u{1F550} Time: ${node.time}`;
    }
    if (node.splunkQuery && node.splunkQuery.trim()) {
      const splunkEl = nodeDetails.createDiv("dag-node-splunk");
      splunkEl.innerHTML = `\u{1F50D} Splunk: ${node.splunkQuery}`;
    }
    if (node.tactic && node.tactic.trim()) {
      const tacticEl = nodeDetails.createDiv("dag-node-tactic");
      tacticEl.innerHTML = `\u2694\uFE0F Tactic: ${node.tactic}`;
    }
    if (node.technique && node.technique.trim()) {
      const techniqueEl = nodeDetails.createDiv("dag-node-technique");
      techniqueEl.innerHTML = `\u{1F3AF} Technique: ${node.technique}`;
    }
    nodeContainer.addEventListener("mouseover", () => {
      nodeContainer.style.boxShadow = `0 8px 20px ${nodeColor}35`;
    });
    nodeContainer.addEventListener("mouseout", () => {
      nodeContainer.style.boxShadow = `0 4px 12px ${nodeColor}25`;
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/RenderIOCCardsModal.ts
var import_obsidian2 = require("obsidian");
var RenderIOCCardsModal = class extends import_obsidian2.Modal {
  constructor(app, iocTypes, onSelect) {
    super(app);
    this.iocTypes = iocTypes;
    this.onSelect = onSelect;
  }
  /** Builds the primary IOC type grid view. */
  onOpen() {
    const { contentEl } = this;
    this.modalEl.classList.add("ioc-type-selector-modal");
    this.modalEl.style.maxWidth = "900px";
    this.modalEl.style.width = "90vw";
    contentEl.createEl("h2", { text: "Select IOC Type" });
    const container = contentEl.createDiv("ioc-type-container");
    const typeCount = Object.keys(this.iocTypes).length;
    const cols = Math.min(Math.ceil(Math.sqrt(typeCount)), 5);
    container.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;
    Object.keys(this.iocTypes).forEach((iocTypeId) => {
      const iocType = this.iocTypes[iocTypeId];
      const button = container.createEl("button", { cls: "ioc-type-button" });
      button.setAttribute("data-ioc-type", iocTypeId);
      button.style.borderLeft = `4px solid ${iocType.color}`;
      const iconContainer = button.createDiv("ioc-button-icon");
      iconContainer.innerHTML = iocType.svg;
      const textContainer = button.createDiv("ioc-button-text");
      textContainer.textContent = iocType.name;
      button.addEventListener("click", () => {
        if (iocTypeId === "hostname") {
          this.showOSSelector(iocTypeId);
        } else {
          this.onSelect(iocTypeId);
          this.close();
        }
      });
    });
  }
  /**
   * Replaces the type grid with an OS selector sub-view.
   * Only reachable when iocTypeId === 'hostname' and the type has os_icons.
   */
  showOSSelector(iocTypeId) {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "Select Operating System" });
    contentEl.createEl("p", { text: "Choose the operating system for this hostname:" });
    const container = contentEl.createDiv("os-selector-container");
    const iocType = this.iocTypes[iocTypeId];
    if (iocType.os_icons) {
      Object.keys(iocType.os_icons).forEach((osType) => {
        const osButton = container.createEl("button", { cls: "os-type-button" });
        osButton.setAttribute("data-os-type", osType);
        const iconContainer = osButton.createDiv("os-button-icon");
        iconContainer.innerHTML = iocType.os_icons[osType];
        const textContainer = osButton.createDiv("os-button-text");
        textContainer.textContent = osType.charAt(0).toUpperCase() + osType.slice(1);
        osButton.addEventListener("click", () => {
          this.onSelect(iocTypeId, osType);
          this.close();
        });
      });
    }
    const backButton = contentEl.createEl("button", {
      text: "\u2190 Back to IOC Types",
      cls: "back-button"
    });
    backButton.addEventListener("click", () => {
      contentEl.empty();
      this.onOpen();
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/RenderIOCCards.ts
var RenderIOCCards = class {
  /**
   * Builds the full markdown+HTML string for a new IOC card.
   * @param iocType  - The IOCField definition from the type registry
   * @param iocTypeId - The snake_case key (needed to detect "hostname" special case)
   * @param osType   - If iocTypeId is "hostname", which OS variant was selected
   */
  static createCardContent(iocType, iocTypeId, osType = null) {
    const now = new Date();
    const timestamp = now.toISOString().replace("T", " ").substring(0, 19);
    let iconSvg = iocType.svg;
    if (iocTypeId === "hostname" && osType && iocType.os_icons) {
      iconSvg = iocType.os_icons[osType] || iocType.svg;
    }
    let content = `<div class="ioc-card-container"><div class="ioc-card-header"
        style="display: flex; align-items: center; gap: 16px; margin-bottom: 30px; padding: 20px;
        background: linear-gradient(135deg, ${iocType.color}22, transparent);
        border-radius: 8px; border-bottom: 3px solid ${iocType.color};">
        <div class="ioc-icon" style="flex-shrink: 0;">${iconSvg}</div><h2 style="margin: 0;
        color: ${iocType.color}; font-size: 24px; font-weight: 700;">${iocType.name}</h2></div>
        <div class="ioc-card-content" style="padding: 0 20px;"></div></div>
`;
    iocType.fields.forEach((field) => {
      content += `${field}: 



`;
    });
    content += `Time of Event: ${timestamp}

`;
    content += `Splunk Query: 

`;
    content += `Mitre Tactic: 

`;
    content += `Mitre Technique: 

`;
    return content;
  }
};

// src/PluginSettings.ts
var import_obsidian3 = require("obsidian");
var DEFAULT_SETTINGS = {
  cardSize: "medium",
  showTimelineButton: true
};
var PluginSettings = class extends import_obsidian3.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "IOC Canvas Plugin Settings" });
    new import_obsidian3.Setting(containerEl).setName("Default card size").setDesc("Set the default size for IOC cards").addDropdown(
      (dropdown) => dropdown.addOption("small", "Small").addOption("medium", "Medium").addOption("large", "Large").setValue(this.plugin.settings.cardSize).onChange(async (value) => {
        this.plugin.settings.cardSize = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian3.Setting(containerEl).setName("Show timeline button").setDesc("Display timeline button in canvas toolbar").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.showTimelineButton).onChange(async (value) => {
        this.plugin.settings.showTimelineButton = value;
        await this.plugin.saveSettings();
      })
    );
  }
};

// src/main.ts
var IOCCanvasPlugin = class extends import_obsidian4.Plugin {
  constructor() {
    super(...arguments);
    /** Typed settings object persisted to data.json. */
    this.settings = DEFAULT_SETTINGS;
    /** Whether the canvas IOC cards are currently in compact/reduced view. */
    this.isReducedView = false;
  }
  // ---------------------------------------------------------------
  // Plugin lifecycle
  // ---------------------------------------------------------------
  /**
   * Called by Obsidian when the plugin is activated.
   *
   * Order of operations:
   *   1. Load persisted settings from data.json.
   *   2. Register ribbon icons (sidebar shortcuts).
   *   3. Register commands (accessible via Ctrl/Cmd+P).
   *   4. Register the single settings tab from PluginSettings.ts.
   *   5. Register the canvas context-menu entry.
   *   6. Listen for active-leaf changes to inject floating buttons.
   *   7. Perform an initial button injection for the currently open leaf.
   */
  async onload() {
    console.log("Loading IOC Canvas Plugin");
    await this.loadSettings();
    this.addRibbonIcon("clock", "Show Attack Timelines", () => {
      new RenderTimelinesModal(this.app, this).open();
    });
    this.addCommand({
      id: "show-timelines",
      name: "Show Attack Timelines",
      callback: () => {
        new RenderTimelinesModal(this.app, this).open();
      }
    });
    this.addCommand({
      id: "show-ioc-cards",
      name: "Show All IOC Cards",
      callback: () => {
        this.openIOCCardSelector();
      }
    });
    this.addSettingTab(new PluginSettings(this.app, this));
    this.registerEvent(
      this.app.workspace.on("file-menu", (menu, file) => {
        if (file instanceof import_obsidian4.TFile && file.extension === "canvas") {
          menu.addItem((item) => {
            item.setTitle("Show Attack Timelines").setIcon("clock").onClick(() => {
              new RenderTimelinesModal(this.app, this).open();
            });
          });
        }
      })
    );
    this.registerEvent(
      this.app.workspace.on("active-leaf-change", () => {
        this.addCanvasButtons();
      })
    );
    this.addCanvasButtons();
  }
  /**
   * Called by Obsidian when the plugin is deactivated or Obsidian closes.
   * Cleans up all DOM elements injected by the plugin so they do not
   * persist after disable/uninstall.
   */
  onunload() {
    console.log("Unloading IOC Canvas Plugin");
    document.querySelectorAll(".ioc-toolbar").forEach((el) => el.remove());
    document.querySelectorAll(".ioc-reduced").forEach((el) => el.classList.remove("ioc-reduced"));
  }
  // ---------------------------------------------------------------
  // Settings persistence
  // ---------------------------------------------------------------
  /** Load settings from data.json, falling back to defaults for any missing keys. */
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  /** Persist the current settings object to data.json. */
  async saveSettings() {
    await this.saveData(this.settings);
  }
  // ---------------------------------------------------------------
  // Canvas floating button injection
  // ---------------------------------------------------------------
  /**
   * Injects control buttons into Obsidian's native canvas control bar.
   *
   * Buttons added:
   *   - Timeline button: opens the attack-timeline modal.
   *   - IOC Cards button: opens the IOC card selector.
   *
   * Uses the .ioc-toolbar class as a duplicate-injection guard.
   *
   * The entire method is wrapped in a try/catch so a failure in button
   * creation never takes down the plugin.
   */
  addCanvasButtons() {
    try {
      const activeView = this.app.workspace.getActiveViewOfType(import_obsidian4.ItemView);
      if (!activeView || activeView.getViewType() !== "canvas") {
        return;
      }
      const canvasView = activeView.containerEl;
      if (!canvasView) {
        return;
      }
      const canvasControls = canvasView.querySelector(".canvas-controls");
      if (!canvasControls) {
        return;
      }
      if (canvasControls.querySelector(".ioc-toolbar")) {
        return;
      }
      const iocToolbar = document.createElement("div");
      iocToolbar.className = "ioc-toolbar";
      const timelineItem = document.createElement("div");
      timelineItem.className = "canvas-control-item";
      timelineItem.setAttribute("aria-label", "Show Attack Timelines");
      timelineItem.setAttribute("title", "Show Attack Timelines");
      timelineItem.addEventListener("click", () => {
        new RenderTimelinesModal(this.app, this).open();
      });
      const timelineIcon = document.createElement("div");
      timelineIcon.className = "clickable-icon";
      timelineIcon.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>';
      timelineItem.appendChild(timelineIcon);
      const cardsItem = document.createElement("div");
      cardsItem.className = "canvas-control-item";
      cardsItem.setAttribute("aria-label", "Add IOC Card");
      cardsItem.setAttribute("title", "Add IOC Card");
      cardsItem.addEventListener("click", () => {
        this.openIOCCardSelector();
      });
      const cardsIcon = document.createElement("div");
      cardsIcon.className = "clickable-icon";
      cardsIcon.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="2" y="3" width="20" height="14" rx="2" ry="2"/><line x1="8" y1="21" x2="16" y2="21"/><line x1="12" y1="17" x2="12" y2="21"/></svg>';
      cardsItem.appendChild(cardsIcon);
      const reduceItem = document.createElement("div");
      reduceItem.className = "canvas-control-item";
      reduceItem.setAttribute("aria-label", "Toggle Reduce View");
      reduceItem.setAttribute("title", "Toggle Reduce View");
      reduceItem.addEventListener("click", () => {
        this.toggleReduceView();
        const icon = reduceItem.querySelector(".clickable-icon");
        if (icon) {
          icon.classList.toggle("is-active", this.isReducedView);
        }
      });
      const reduceIcon = document.createElement("div");
      reduceIcon.className = "clickable-icon";
      reduceIcon.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="4 14 10 14 10 20"/><polyline points="20 10 14 10 14 4"/><line x1="14" y1="10" x2="21" y2="3"/><line x1="3" y1="21" x2="10" y2="14"/></svg>';
      reduceItem.appendChild(reduceIcon);
      iocToolbar.appendChild(timelineItem);
      iocToolbar.appendChild(cardsItem);
      iocToolbar.appendChild(reduceItem);
      canvasControls.appendChild(iocToolbar);
    } catch (err) {
      console.error("IOC Canvas: failed to inject canvas buttons", err);
    }
  }
  // ---------------------------------------------------------------
  // Reduce view toggle
  // ---------------------------------------------------------------
  /**
   * Toggles the reduced/compact view for IOC cards on the active canvas.
   * When reduced, CSS hides everything except the code block value, and
   * nodes are resized to a compact single-line height.
   */
  toggleReduceView() {
    const activeView = this.app.workspace.getActiveViewOfType(import_obsidian4.ItemView);
    if (!activeView || activeView.getViewType() !== "canvas")
      return;
    const canvas = activeView.canvas;
    if (!canvas)
      return;
    this.isReducedView = !this.isReducedView;
    const wrapperEl = canvas.wrapperEl;
    if (wrapperEl) {
      if (this.isReducedView) {
        wrapperEl.classList.add("ioc-reduced");
      } else {
        wrapperEl.classList.remove("ioc-reduced");
      }
    }
    if (canvas.nodes) {
      canvas.nodes.forEach((node) => {
        if (!node.text)
          return;
        if (this.isReducedView) {
          if (!node._iocOriginalHeight) {
            node._iocOriginalHeight = node.height;
          }
          if (node.resize) {
            node.resize({ width: node.width, height: 60 });
          } else {
            node.height = 60;
          }
        } else {
          const originalH = node._iocOriginalHeight || 400;
          if (node.resize) {
            node.resize({ width: node.width, height: originalH });
          } else {
            node.height = originalH;
          }
        }
      });
    }
    canvas.requestFrame();
    canvas.requestSave();
  }
  // ---------------------------------------------------------------
  // IOC card creation helpers
  // ---------------------------------------------------------------
  /**
   * Opens the IOC card selector modal. The callback creates the card on
   * the active canvas.
   */
  openIOCCardSelector() {
    new RenderIOCCardsModal(
      this.app,
      IOC_TYPES,
      (iocTypeId, osType) => {
        this.createIOCCard(iocTypeId, osType);
      }
    ).open();
  }
  /**
   * Creates an IOC card on the active canvas.
   * @param iocTypeId - The snake_case IOC type key from IOC_TYPES
   * @param osType    - Optional OS variant for hostname cards
   */
  createIOCCard(iocTypeId, osType) {
    const activeView = this.app.workspace.getActiveViewOfType(import_obsidian4.ItemView);
    if (!activeView || activeView.getViewType() !== "canvas") {
      new import_obsidian4.Notice("Please open a canvas first");
      return;
    }
    const canvas = activeView.canvas;
    if (!canvas) {
      new import_obsidian4.Notice("Please open a canvas first");
      return;
    }
    const iocType = IOC_TYPES[iocTypeId];
    if (!iocType) {
      new import_obsidian4.Notice("Unknown IOC type: " + iocTypeId);
      return;
    }
    const content = RenderIOCCards.createCardContent(iocType, iocTypeId, osType || null);
    canvas.createTextNode({
      pos: { x: Math.random() * 400, y: Math.random() * 400 },
      size: { width: 400, height: 400 },
      text: content
    });
    canvas.requestSave();
    new import_obsidian4.Notice(`Created ${iocType.name} card`);
  }
};
